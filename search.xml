<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Contiki-Building]]></title>
    <url>%2F2019%2F04%2F02%2FContiki-Building%2F</url>
    <content type="text"><![CDATA[Contiki-BuildingThe Contiki build system Contiki 构建系统 The Contiki build system is designed to make it easy to compile Contiki applications for different hardware platforms or into a simulation platform by simply supplying different parameters to the make command, without having to edit makefiles or modify the application code. - Contiki 构建系统旨在通过简单地为make命令提供不同的参数，轻松为不同的硬件平台或仿真平台编译Contiki应用程序，而无需编辑Makefile文件或修改程序代码。 The file example project in examples/hello-world/ shows how the Contiki build system works. The hello-world.c application can be built into a complete Contiki system by running make in the examples/hello-world/ directory. Running make without parameters will build a Contiki system using the native target. The native target is a special Contiki platform that builds an entire Contiki system as a program that runs on the development system. After compiling the application for the native target it is possible to run the Contiki system with the application by running the file hello-world.native. To compile the application and a Contiki system for the ESB platform the command make TARGET=esb is used. This produces a hello-world.esb file that can be loaded into an ESB board. - 在examples/hello-world/中的示例文件展示了Contiki构建系统的工作原理。通过在examples/hello-world/目录中运行make命令，可以将hello-world.c 应用程序构建到一个完整的Contiki系统中。不使用参数运行make命令将为本机目标构建Contiki系统。本机目标是一个特殊的Contiki平台，它将整个Contiki系统构建为运行在开发系统上的一个程序。在为本机目标编译应用程序之后，可以通过运行hello-world.native文件来运行带有应用程序的Contiki系统。使用命令 make TARGET=esb 为ESB平台编译应用程序和Contiki系统。这会生成一个hello-world.esb文件，可以加载到ESB板中。 To compile the hello-world application into a stand-alone executable that can be loaded into a running Contiki system, the command make hello-world.ce is used. To build an executable file for the ESB platform, make TARGET=esb hello-world.ce is run. - 使用命令 make hello-world.ce 将hello-world 应用程序编译为可以加载到正在运行的Contiki系统中的独立可执行文件。要为ESB平台构建可执行文件，请运行 make TARGET=esb hello-world.ce 。 To avoid having to type TARGET= every time make is run, it is possible to run make TARGET=esb savetarget to save the selected target as the default target platform for subsequent invocations of make. A file called Makefile.target containing the currently saved target is saved in the project’s directory. - 为了避免每次运行make时都必须键入 TARGET= ，可以运行make TARGET=esb savetarget将所选目标保存为后续调用make的默认目标平台。包含当前保存目标的名为Makefile.target的文件保存在项目目录中。 Beside TARGET= there’s DEFINES= which allows to set arbitrary variables for the C preprocessor in form of a comma-separated list. Again it is possible to avoid having to re-type i.e. DEFINES=MYTRACE,MYVALUE=4711 by running make TARGET=esb DEFINES=MYTRACE,MYVALUE=4711 savedefines. A file called Makefile.esb.defines is saved in the project’s directory containing the currently saved defines for the ESB platform. - 除了 TARGET= 还有 DEFINES= 允许以逗号分隔列表的形式为C预处理器设置任意变量。同样可以通过运行make TARGET=esb DEFINES=MYTRACE，MYVALUE=4711 savedefines 来避免重新输入，即 DEFINES=MYTRACE，MYVALUE=4711。 Makefiles used in the Contiki build system The Contiki build system is composed of a number of Makefiles. These are: Makefile: the project’s makefile, located in the project directory. Makefile.include: the system-wide Contiki makefile, located in the root of the Contiki source tree. Makefile.$(TARGET) (where $(TARGET) is the name of the platform that is currently being built): rules for the specific platform, located in the platform’s subdirectory in the platform/ directory. Makefile.$(CPU) (where $(CPU) is the name of the CPU or microcontroller architecture used on the platform for which Contiki is built): rules for the CPU architecture, located in the CPU architecture’s subdirectory in the cpu/ directory. Makefile.$(APP) (where $(APP) is the name of an application in the apps/ directory): rules for applications in the apps/ directories. Each application has its own makefile. Contiki构建系统中使用的Makefile Contiki构建系统由许多Makefile组成。这些是： Makefile：项目的makefile，位于项目目录中。 Makefile.include：系统范围的Contiki makefile，位于Contiki源树的根目录中。 Makefile.$(TARGET) (其中$(TARGET)是当前正在构建的平台的名称)：特定平台的规则，位于platform/ 目录中平台的子目录中。 Makefile.$(CPU) (其中$(CPU)是在构建Contiki的平台上使用的CPU或微控制器架构的名称)：CPU架构的规则，位于CPU架构的 cpu/ 目录子目录中。 Makefile.$(APP) (其中$(APP)是apps/ 目录中应用程序的名称)：apps/ 目录中应用程序的规则, 每个应用程序都有自己的makefile。 The Makefile in the project’s directory is intentionally simple. It specifies where the Contiki source code resides in the system and includes the system-wide Makefile, Makefile.include. The project’s makefile can also define in the APPS variable a list of applications from the apps/ directory that should be included in the Contiki system. The Makefile used in the hello-world example project looks like this: CONTIKI_PROJECT = hello-world all: $(CONTIKI_PROJECT) CONTIKI = ../.. include $(CONTIKI)/Makefile.include - 项目目录中的Makefile非常简单。它指定Contiki源代码驻留在系统中的位置，并包含系统范围的Makefile，Makefile.include。项目的makefile还可以在APPS变量中定义应该包含在Contiki系统中的apps/ 目录中的应用程序列表。hello-world示例项目中使用的Makefile如下所示： CONTIKI_PROJECT = hello-world all: $(CONTIKI_PROJECT) CONTIKI = ../.. include $(CONTIKI)/Makefile.include First, the location of the Contiki source code tree is given by defining the CONTIKI variable. Next, the name of the application is defined. Finally, the system-wide Makefile.include is included. - 首先，通过定义CONTIKI变量给出Contiki源代码树的位置。接下来，定义应用程序的名称。最后，包括系统范围的Makefile.include。 The Makefile.include contains definitions of the C files of the core Contiki system. Makefile.include always reside in the root of the Contiki source tree. When make is run, Makefile.include includes the Makefile.$(TARGET) as well as all makefiles for the applications in the APPS list (which is specified by the project’s Makefile). - Makefile.include包含核心Contiki系统的C文件的定义。Makefile.include始终位于Contiki源树的根目录中。当make运行时，Makefile.include包含Makefile.$(TARGET)以及APPS列表中应用程序的所有makefile(由项目的Makefile指定)。 Makefile.$(TARGET), which is located in the platform/$(TARGET)/ directory, contains the list of C files that the platform adds to the Contiki system. This list is defined by the CONTIKI_TARGET_SOURCEFILES variable. The Makefile.$(TARGET) also includes the Makefile.$(CPU) from the cpu/$(CPU)/ directory. - Makefile.$(TARGET)位于平台 /$(TARGET)/目录中，包含平台添加到Contiki系统的C文件列表。此列表由CONTIKI_TARGET_SOURCEFILES变量定义。Makefile.$(TARGET)还包括来自cpu/ $(CPU)/ 目录的Makefile.$(CPU)。 The Makefile.$(CPU) typically contains definitions for the C compiler used for the particular CPU. If multiple C compilers are used, the Makefile.$(CPU) can either contain a conditional expression that allows different C compilers to be defined, or it can be completely overridden by the platform specific makefile Makefile.$(TARGET). - Makefile.$(CPU)通常包含用于特定CPU的C编译器的定义。如果使用多个C编译器，Makefile.$(CPU)可以包含允许定义不同C编译器的条件表达式，也可以由平台特定的makefile Makefile.$(TARGET)完全覆盖。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ICN 网络学习笔记]]></title>
    <url>%2F2019%2F03%2F28%2FICN%20%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ICN 网络基本概念和组成模块 信息对象/数据对象 数据是最低级别的抽象而信息是更高一级的抽象。为了让数据成为信息，它必须能被解释和具有一定含义。ICN网络概念聚焦的就是信息本身，而非信息所在的存储位置。为了突出这一区别，需要引进一个信息对象的概念。 一个信息对象代表信息本身，与其存储位置和物理结构表征无关。一个信息对象可以有多个不同的表示形式（同一数据采用不同的编码或者压缩格式）：多组唯一的比特模式可以代表同一个信息对象，而且每个信息对象的表示都可以有多种不同的副本，例如，存储在服务器上的一个副本，在客户端点保存的一个副本，或在一个缓存中保留一个副本。 因此，一个信息对象值的是一组相同的信息所具有的表现形式和相应的副本。 实现IO的概念可以有多种不同的方式，比如说采取一种专门的数据结构来实现IO，这种数据结构包含了指向IO所有副本位置的全部指针。这样的实现方式也可以包含额外的元数据，例如，与编码有关的信息或与安全相关的信息。如果IO是由一个专门的数据结构来表示，那么就需要设计一个额外的信息模型，定义IO相关语法和语义。当然，在不同的ICN衍生网络中，IO也可能不需要专门的数据结构来表达。 命名机制 在ICN中个信息命名是很重要的问题。在当前的互联网架构中，主要采用信息数据的存储位置来命名。例如，使用一个与网络节点相关的统一资源定位符（URL）来命名，也可以通过使用IP地址来命名每个存储节点的接口。在ICN网络中，最好使用与位置无关的数据对象标识符来命名数据。命名内容包括为网络中每个内容对象确定一个全球唯一的名称，这样用户就可以在创建一个到接受者的传递路径之前，用他们的名字对象寻址，来确定主机位置或者查询附近的缓存。名字到地址的映射是一对多的关系，因为ICN网络中的数据多个备份可能存在与网络缓存和备份中。 由于ICN网络中一切都是信息，信息对象模型的重点一直放在命名上。命名的目的不仅是在网络中确定唯一的内容对象，而且还包括针对性、可用性、可扩展性和安全性等重要性质。虽然名称结构往往是由反映相关属性的几个部分组成，但从总体上看，有两种类型的命名空间：层次型和扁平型。层次的名字，可以使用类似IP路由查找的最长前缀匹配，内容组织方式类似与DNS。这种树状的层次结构有利于域名的分类和识别，在多层次、结构化的网络中，有利于实现域名的分级查询和管理，从而提高根DNS安全性和区域DNS的灵活性和真实性。这对数字版权管理很有用，层次命名结构显性地指明了文件所有者的信息。然而，层次化命名方式在支持标识与位置分离、支持组播和高效数据分发，以及面对网络攻击的防御方面有局限性。在这种情况下，需要考虑一个扁平型的命名空间。 ICN网络设计中最关键的部分，可能就是一套与位置无关的标识数据身份的命名策略，基本考量包括以下几个方面的特性： 独特性：信息对象必须在全球网络中以一个独特的方式命名。这种独特性对于用名字来说是必要的。 持久性和位置无关性：这个名字是不变的，独立于主机的位置。服务供应商继续提供服务，内容可以被复制或从一个位置托管到另一个位置中，无需中断服务。 可用性和可扩展性：作为一个信息网络，我们可以期望有大量的数据对象，这些对象在网络上可以是互相关联和依赖的。此外，对象不一定必须是静态的，对象可以是可变的，例如：被分散在小片段或从一个版本变化到另一个版本，如天气RSS。除了具有可扩展性，命名方案应是可用与动态对象，也应该允许删除对象。 安全性：ICN网络将安全直接嵌入内容，前提是不假设用户可信，也不通过加密信道来提供安全。为了让用户更灵活地受益于网络各处的副本，安全不能与存储位置直接绑定。基于信息本身的新型安全机制成为必要的选择，基于内容的安全意味着内容和它的名字之间有加密的绑定，以确保信息的对象是可以自证的，也就是说，当用户接收到对象时，它可以迅速验证对象是来自真正的提供方，这种绑定通常通过在名字里面包含内容提供商私钥的哈希值。这样就可以用内容提供商的私钥创建一个数据对象的签名来验证内容的提供者，而内容提供者的私钥由包含在数据对象的元数据中的公钥来验证。内容的保密性和完整性，也通过发布者使用公钥进行签名来保证（但其中一个重要的挑战是在公钥受损或数据被更新时如何撤销数据对象）。ICN中命名方式与安全非常相关，比较流行的方法便是把安全和命名机制结合起来，也就是对象ID（Object ID），下面给出在ICN范畴内5个基本的面相数据安全的技术目标： 保密性：只有授权的个体（用户或系统）可以读取安全信息。 数据完整性：对无意或有意篡改的信息数据及其相应的元数据能够进行鉴别，这也被称为一种自我认证能力。 可信任性：信息数据的所有者和创建者的身份可以被认证（Authentication）或识别（Identification）。这里明确做下区分： 数据所有者的认证：将信息安全的与一个虚拟的实体绑定在一起，虚拟的实体可以是公钥/私钥对等： 数据所有者的身份识别：将信息安全地与一个真实实体绑定在一起，例如，真实实体可以是一个人的身份或者一个机构名称。 可用性：在网络发布出来的信息对象及相关的元数据必须能够被授权的个体访问和获取。 访问控制：管理和限制对信息对象或相应的元数据访问权限。 元数据 除了命名，内容对象还包括元数据所代表的属性。元数据的概念是非常重要的，在内容中心网络，它提供资料对内容对象或内容对象与其他对象间的关系进行说明。例如，与照片相关的元数据可以说明图像分辨率、作者、日期或由软件插入任何其他数据。 元数据属性有多种用途。首先，这些属性的语义可以使应用程序在管理内容对象或理解如何使用它们方面获益。由于对象名称是数字标识，通常需要用户基于关键字或描述进行搜索，这意味着往往在应用程序中存在将人类可以理解的属性映射到对象名称的过程。大多数搜索引擎使用与对象相关的元数据，以分布式的方式实施这种映射。 除了语义，元数据可以提供密码操作的输入，以执行更复杂的安全检查。例如，在内容对象的元数据中包含内容提供商的公钥和数字签名，使接收者可以确定内容对象正是来自真正的供应商。网络还可以依靠元数据信息对象提供QoS保证，尤其是实时流多媒体应用。特别是，我们可以使用元数据实现网络访问控制，或收集网络流量的统计信息用以监测网络健康和其他使用情况。 实现元数据可以使用不同的的方式，由于元数据的定义就是关于数据的数据，任何内容对象都可以是其他内容对象的元数据，换句话说，元数据在网络中是和任何其他的内容对象类似的。这种设计关联内容名称，增加更多维度的描述信息，可以详细了解内容对象的元数据属性，类似额外的类标识符。在实际处理中，为了简单起见，元数据经常被视为在同一级别的名称标签。 内容寻址和转发 在ICN网络中内容检索可以分为两个阶段：内容发现和内容交付。内容发现包括内容对象寻址和查询请求转发；内容交付包括内容对象在网络中的路由和传输的规则。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo 博客迁移]]></title>
    <url>%2F2019%2F03%2F28%2FHexo%20%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[Hexo 博客迁移 1、安装node.js git sudo apt install git nodejs npm 2、安装Hexo sudo npm install -g hexo 3、进入Blog目录 安装npm npm install 4、开启hexo本地服务 hexo s 5、完毕开始写博客 hexo new blogname 6、生成和部署你的博客 hexo generate --deploy 或 hexo g -d]]></content>
  </entry>
  <entry>
    <title><![CDATA[解决复制文件到 Linux 系统时的权限问题]]></title>
    <url>%2F2018%2F07%2F17%2F%E8%A7%A3%E5%86%B3%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E5%88%B0%20Linux%20%E7%B3%BB%E7%BB%9F%E6%97%B6%E7%9A%84%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[递归更改目录权限为755，常规文件权限为644将文件从U盘或移动硬盘复制到linux系统时，会使文件的权限放大，全部变为777的权限。我们的目的是要把目录权限全部设定为755，文件权限全部设定为644。这两者被设定的权限不一致，可以用如下方式解决。 1$chmod 755 -R your_file_name/ -R 的参数表示递归处理，将所有的文件目录和文件都设为755的权限。 1$find your_file_name/ -type f -exec chmod a-x &#123;&#125; \; -type 参数表示查找文件类型，f 代表一般文件；-exec 参数表示对查找结果进行其它命令处理，在此对查找结果进行的处理是 chmod a-x {}，即删除x权限，\\; 是必须带的。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习笔记]]></title>
    <url>%2F2018%2F04%2F05%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Fork Me On Githubstart machinelearningNoteData Normalization 数据标准化是将是将数据按比例缩放，使之落入一个小的特定区间。在某些比较和评价的指标处理中经常会用到，去除数据的单位限制，将其转化为无量纲的纯数值，便于不同单位或量级的指标能够进行比较和加权。其中最典型的就是数据归一化处理，即将数据统一映射到[0,1]区间上。 归一化的目标 把数变为（0, 1）之间的小数 主要是为了数据处理方便提出来的，把数据映射到0～1范围之内处理，更加便捷快速，应该归到数字信号处理范畴之内。 把有量纲表达式变为无量纲表达式 归一化是一种简化计算的方式，即将有量纲的表达式，经过变换，化为无量纲的表达式，成为纯量。Max-Min Normalization 也称为离差标准化，是对原始数据的线性变换，使结果值映射到[0 - 1]之间。转换函数如下： x* = (x - min)/(max - min) 其中max为样本数据的最大值，min为样本数据的最小值。这种方法有个缺陷就是当有新数据加入时，可能导致max和min的变化，需要重新定义。 Zero-Mean Normalization 这种方法给予原始数据的均值（mean）和标准差（standard deviation）进行数据的标准化。经过处理的数据符合标准正态分布，即均值为0，标准差为1，转化函数为： x* = (x - u)/d 其中u为所有样本数据的均值，d为所有样本数据的标准差。 Least Squares 最小二乘法（又称最小平方法）是一种数学优化技术。它通过最小化误差的平方和寻找数据的最佳函数匹配。 利用最小二乘法可以简便地求得未知的数据，并使得这些求得的数据与实际数据之间误差的平方和为最小。 “最小二乘法”是对过度确定系统，即其中存在比未知数更多的方程组，以回归分析求得近似解的标准方法。在这整个解决方案中，最小二乘法演算为每一方程式的结果中，将残差平方和的总和最小化。 Loss function 损失函数（loss function）是用来估量你模型的预测值f(x)与真实值Y的不一致程度，它是一个非负实值函数,通常使用L(Y, f(x))来表示，损失函数越小，模型的鲁棒性就越好。损失函数是经验风险函数的核心部分，也是结构风险函数重要组成部分。模型的结构风险函数包括了经验风险项和正则项，通常可以表示成如下式子： 1$$ \theta^* = \arg \min_\theta \frac&#123;1&#125;&#123;N&#125;&#123;&#125;\sum_&#123;i=1&#125;^&#123;N&#125; L(y_i, f(x_i; \theta)) + \lambda\ \Phi(\theta) $$ 其中，前面的均值函数表示的是经验风险函数，L代表的是损失函数，后面的Φ是正则化项（regularizer）或者叫惩罚项（penalty term），它可以是L1，也可以是L2，或者其他的正则函数。整个式子表示的意思是找到使目标函数最小时的θ值。 Gradient Descent 在求解机器学习算法的模型参数，即无约束优化问题时，梯度下降（Gradient Descent）是最常采用的方法之一，另一种常用的方法是最小二乘法。 1. 梯度 在微积分里面，对多元函数的参数求∂偏导数，把求得的各个参数的偏导数以向量的形式写出来，就是梯度。比如函数f(x,y), 分别对x,y求偏导数，求得的梯度向量就是(∂f/∂x, ∂f/∂y)T,简称grad f(x,y)或者▽f(x,y)。对于在点(x0,y0)的具体梯度向量就是(∂f/∂x0, ∂f/∂y0)T.或者▽f(x0,y0)，如果是3个参数的向量梯度，就是(∂f/∂x, ∂f/∂y，∂f/∂z)T,以此类推。 那么这个梯度向量求出来有什么意义呢？他的意义从几何意义上讲，就是函数变化增加最快的地方。具体来说，对于函数f(x,y),在点(x0,y0)，沿着梯度向量的方向就是(∂f/∂x0, ∂f/∂y0)T的方向是f(x,y)增加最快的地方。或者说，沿着梯度向量的方向，更加容易找到函数的最大值。反过来说，沿着梯度向量相反的方向，也就是 -(∂f/∂x0, ∂f/∂y0)T的方向，梯度减少最快，也就是更加容易找到函数的最小值。 2. 梯度下降与梯度上升 在机器学习算法中，在最小化损失函数时，可以通过梯度下降法来一步步的迭代求解，得到最小化的损失函数，和模型参数值。反过来，如果我们需要求解损失函数的最大值，这时就需要用梯度上升法来迭代了。 梯度下降法和梯度上升法是可以互相转化的。比如我们需要求解损失函数f(θ)的最小值，这时我们需要用梯度下降法来迭代求解。但是实际上，我们可以反过来求解损失函数 -f(θ)的最大值，这时梯度上升法就派上用场了。 3. 梯度下降法算法详解 3.1 梯度下降的直观解释 首先来看看梯度下降的一个直观的解释。比如我们在一座大山上的某处位置，由于我们不知道怎么下山，于是决定走一步算一步，也就是在每走到一个位置的时候，求解当前位置的梯度，沿着梯度的负方向，也就是当前最陡峭的位置向下走一步，然后继续求解当前位置梯度，向这一步所在位置沿着最陡峭最易下山的位置走一步。这样一步步的走下去，一直走到觉得我们已经到了山脚。当然这样走下去，有可能我们不能走到山脚，而是到了某一个局部的山峰低处。 从上面的解释可以看出，梯度下降不一定能够找到全局的最优解，有可能是一个局部最优解。当然，如果损失函数是凸函数，梯度下降法得到的解就一定是全局最优解。 3.2 梯度下降的相关概念 步长（Learning rate）：步长决定了在梯度下降迭代的过程中，每一步沿梯度负方向前进的长度。用上面下山的例子，步长就是在当前这一步所在位置沿着最陡峭最易下山的位置走的那一步的长度。 特征（feature）：指的是样本中输入部分，比如2个单特征的样本（x(0),y(0)）,（x(1),y(1)）,则第一个样本特征为x(0)，第一个样本输出为y(0)。 假设函数（hypothesis function）：在监督学习中，为了拟合输入样本，而使用的假设函数，记为hθ(x)。 损失函数（loss function）：为了评估模型拟合的好坏，通常用损失函数来度量拟合的程度。损失函数极小化，意味着拟合程度最好，对应的模型参数即为最优参数。在线性回归中，损失函数通常为样本输出和假设函数的差取平方。]]></content>
      <categories>
        <category>MachineLearning</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-048. 矩阵A乘以B]]></title>
    <url>%2F2018%2F03%2F26%2FL1-048.%E7%9F%A9%E9%98%B5A%E4%B9%98%E4%BB%A5B%2F</url>
    <content type="text"><![CDATA[L1-048. 矩阵A乘以B给定两个矩阵A和B，要求你计算它们的乘积矩阵AB。需要注意的是，只有规模匹配的矩阵才可以相乘。即若A有Ra行、Ca列，B有Rb行、Cb列，则只有Ca与Rb相等时，两个矩阵才能相乘。 输入格式：输入先后给出两个矩阵A和B。对于每个矩阵，首先在一行中给出其行数R和列数C，随后R行，每行给出C个整数，以1个空格分隔，且行首尾没有多余的空格。输入保证两个矩阵的R和C都是正数，并且所有整数的绝对值不超过100。 输出格式：若输入的两个矩阵的规模是匹配的，则按照输入的格式输出乘积矩阵AB，否则输出“Error: Ca != Rb”，其中Ca是A的列数，Rb是B的行数。 输入样例1：2 31 2 34 5 63 47 8 9 0-1 -2 -3 -45 6 7 8 输出样例1：2 420 22 24 1653 58 63 28 输入样例2：3 238 2643 -50 173 2-11 5799 6881 72 输出样例2：Error: 2 != 3 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;int main() &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; int arr[a][b]; for (int i = 0; i &lt; a; ++i) &#123; for (int j = 0; j &lt; b; ++j) &#123; cin &gt;&gt; arr[i][j]; &#125; &#125; int c, d; cin &gt;&gt; c &gt;&gt; d; int brr[c][d]; for (int i = 0; i &lt; c; ++i) &#123; for (int j = 0; j &lt; d; ++j) &#123; cin &gt;&gt; brr[i][j]; &#125; &#125; if (b != c) &#123; cout &lt;&lt; "Error: " &lt;&lt; b &lt;&lt; " != " &lt;&lt; c &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; a &lt;&lt; " " &lt;&lt; d &lt;&lt; endl; for (int i = 0; i &lt; a; ++i) &#123; int flag = 1; for (int j = 0; j &lt; d; ++j) &#123; int sum = 0; for (int k = 0; k &lt; b; ++k) &#123; sum += arr[i][k] * brr[k][j]; &#125; if (j &lt; d - 1) &#123; cout &lt;&lt; sum &lt;&lt; " "; &#125; else cout &lt;&lt; sum &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-047. 装睡]]></title>
    <url>%2F2018%2F03%2F26%2FL1-047.%E8%A3%85%E7%9D%A1%2F</url>
    <content type="text"><![CDATA[L1-047. 装睡你永远叫不醒一个装睡的人 —— 但是通过分析一个人的呼吸频率和脉搏，你可以发现谁在装睡！医生告诉我们，正常人睡眠时的呼吸频率是每分钟15-20次，脉搏是每分钟50-70次。下面给定一系列人的呼吸频率与脉搏，请你找出他们中间有可能在装睡的人，即至少一项指标不在正常范围内的人。 输入格式：输入在第一行给出一个正整数N（&lt;= 10）。随后N行，每行给出一个人的名字（仅由英文字母组成的、长度不超过3个字符的串）、其呼吸频率和脉搏（均为不超过100的正整数）。 输出格式：按照输入顺序检查每个人，如果其至少一项指标不在正常范围内，则输出其名字，每个名字占一行。 输入样例：4Amy 15 70Tom 14 60Joe 18 50Zoe 21 71 输出样例：TomZoe 1234567891011121314#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; string s; int a, b; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; s &gt;&gt; a &gt;&gt; b; if (a &lt; 15 || a &gt; 20 || b &lt; 50 || b &gt; 70) cout &lt;&lt; s &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-046. 整除光棍]]></title>
    <url>%2F2018%2F03%2F26%2FL1-046.%E6%95%B4%E9%99%A4%E5%85%89%E6%A3%8D%2F</url>
    <content type="text"><![CDATA[L1-046. 整除光棍这里所谓的“光棍”，并不是指单身汪啦~ 说的是全部由1组成的数字，比如1、11、111、1111等。传说任何一个光棍都能被一个不以5结尾的奇数整除。比如，111111就可以被13整除。 现在，你的程序要读入一个整数x，这个整数一定是奇数并且不以5结尾。然后，经过计算，输出两个数字：第一个数字s，表示x乘以s是一个光棍，第二个数字n是这个光棍的位数。这样的解当然不是唯一的,题目要求你输出最小的解。 提示：一个显然的办法是逐渐增加光棍的位数，直到可以整除x为止。但难点在于，s可能是个非常大的数 —— 比如，程序输入31，那么就输出3584229390681和15，因为31乘以3584229390681的结果是111111111111111，一共15个1。 输入格式：输入在一行中给出一个不以5结尾的正奇数x（&lt; 1000）。 输出格式：在一行中输出相应的最小的s和n，其间以1个空格分隔。 输入样例：31 输出样例：3584229390681 15 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int main() &#123; int k; cin &gt;&gt; k; int64_t res = 1; int index = 1; while (k &gt; res) &#123; res = res * 10 + 1; index++; &#125; int64_t ret; while (true) &#123; if (0 == res % k) &#123; ret = res / k; cout &lt;&lt; ret; break; &#125; else &#123; ret = res / k; cout &lt;&lt; ret; res = res % k; res = res * 10 + 1; index++; &#125; &#125; cout &lt;&lt; " " &lt;&lt; index &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-045. 宇宙无敌大招呼]]></title>
    <url>%2F2018%2F03%2F26%2FL1-045.%E5%AE%87%E5%AE%99%E6%97%A0%E6%95%8C%E5%A4%A7%E6%8B%9B%E5%91%BC%2F</url>
    <content type="text"><![CDATA[L1-045. 宇宙无敌大招呼据说所有程序员学习的第一个程序都是在屏幕上输出一句“Hello World”，跟这个世界打个招呼。作为天梯赛中的程序员，你写的程序得高级一点，要能跟任意指定的星球打招呼。 输入格式： 输入在第一行给出一个星球的名字S，是一个由不超过7个英文字母组成的单词，以回车结束。 输出格式： 在一行中输出“Hello S”，跟输入的S星球打个招呼。 输入样例：Mars输出样例：Hello Mars 123456789#include &lt;iostream&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; cout &lt;&lt; "Hello " &lt;&lt; s &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-044. 稳赢]]></title>
    <url>%2F2018%2F03%2F26%2FL1-044.%E7%A8%B3%E8%B5%A2%2F</url>
    <content type="text"><![CDATA[L1-044. 稳赢大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示： 现要求你编写一个稳赢不输的程序，根据对方的出招，给出对应的赢招。但是！为了不让对方输得太惨，你需要每隔K次就让一个平局。 输入格式：输入首先在第一行给出正整数K（&lt;=10），即平局间隔的次数。随后每行给出对方的一次出招：“ChuiZi”代表“锤子”、“JianDao”代表“剪刀”、“Bu”代表“布”。“End”代表输入结束，这一行不要作为出招处理。 输出格式：对每一个输入的出招，按要求输出稳赢或平局的招式。每招占一行。 输入样例：2ChuiZiJianDaoBuJianDaoBuChuiZiChuiZiEnd 输出样例：BuChuiZiBuChuiZiJianDaoChuiZiBu 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int main() &#123; int k; cin &gt;&gt; k; int index = 1; string m[] = &#123;"JianDao", "ChuiZi", "Bu"&#125;; string s; while (cin &gt;&gt; s) &#123; if (s == "End") break; if (index % (k + 1) == 0) &#123; cout &lt;&lt; s &lt;&lt; endl; &#125; else &#123; for (int i = 0; i &lt; 3; ++i) &#123; if (s == m[i]) &#123; cout &lt;&lt; m[(i+1)%3]&lt;&lt; endl; break; &#125; &#125; &#125; index++; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-043. 阅览室]]></title>
    <url>%2F2018%2F03%2F26%2FL1-043.%E9%98%85%E8%A7%88%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[L1-043. 阅览室天梯图书阅览室请你编写一个简单的图书借阅统计程序。当读者借书时，管理员输入书号并按下S键，程序开始计时；当读者还书时，管理员输入书号并按下E键，程序结束计时。书号为不超过1000的正整数。当管理员将0作为书号输入时，表示一天工作结束，你的程序应输出当天的读者借书次数和平均阅读时间。 注意：由于线路偶尔会有故障，可能出现不完整的纪录，即只有S没有E，或者只有E没有S的纪录，系统应能自动忽略这种无效纪录。另外，题目保证书号是书的唯一标识，同一本书在任何时间区间内只可能被一位读者借阅。 输入格式：输入在第一行给出一个正整数N（&lt;= 10），随后给出N天的纪录。每天的纪录由若干次借阅操作组成，每次操作占一行，格式为： 书号（[1, 1000]内的整数） 键值（“S”或“E”） 发生时间（hh:mm，其中hh是[0,23]内的整数，mm是[0, 59]内整数） 每一天的纪录保证按时间递增的顺序给出。 输出格式：对每天的纪录，在一行中输出当天的读者借书次数和平均阅读时间（以分钟为单位的精确到个位的整数时间）。 输入样例：31 S 08:102 S 08:351 E 10:002 E 13:160 S 17:000 S 17:003 E 08:101 S 08:202 S 09:001 E 09:200 E 17:00 输出样例：2 1960 01 60 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; char mark[1001], c; int num, hour, minutes; int startMinute[1001]; int times, minuteSum; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; 1001; j++) &#123; startMinute[j] = mark[j] = 0; &#125; times = minuteSum = 0; while (true) &#123; scanf("%d %c %d:%d", &amp;num, &amp;c, &amp;hour, &amp;minutes); if (num) &#123; if (c == 'S') &#123; mark[num] = 'S'; startMinute[num] = hour*60 + minutes; &#125; else if (c == 'E' &amp;&amp; mark[num] == 'S') &#123; minuteSum += hour*60 + minutes - startMinute[num]; times++; mark[num] = 0; &#125; &#125; else &#123; if (times) &#123; cout &lt;&lt; times &lt;&lt; " " &lt;&lt; (int) ((double) minuteSum/times + 0.5) &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; 0 &lt;&lt; " " &lt;&lt; 0 &lt;&lt; endl; &#125; break; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-042. 日期格式化]]></title>
    <url>%2F2018%2F03%2F26%2FL1-042.%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[L1-042. 日期格式化世界上不同国家有不同的写日期的习惯。比如美国人习惯写成“月-日-年”，而中国人习惯写成“年-月-日”。下面请你写个程序，自动把读入的美国格式的日期改写成中国习惯的日期。 输入格式：输入在一行中按照“mm-dd-yyyy”的格式给出月、日、年。题目保证给出的日期是1900年元旦至今合法的日期。 输出格式：在一行中按照“yyyy-mm-dd”的格式给出年、月、日。 输入样例：03-15-2017 输出样例：2017-03-15 12345678#include &lt;iostream&gt;using namespace std;int main() &#123; int mm, dd, yyyy; scanf("%d-%d-%d", &amp;mm, &amp;dd, &amp;yyyy); printf("%04d-%02d-%02d", yyyy, mm, dd); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-041. 寻找250]]></title>
    <url>%2F2018%2F03%2F26%2FL1-041.%E5%AF%BB%E6%89%BE250%2F</url>
    <content type="text"><![CDATA[L1-041. 寻找250对方不想和你说话，并向你扔了一串数…… 而你必须从这一串数字中找到“250”这个高大上的感人数字。 输入格式：输入在一行中给出不知道多少个绝对值不超过1000的整数，其中保证至少存在一个“250”。 输出格式：在一行中输出第一次出现的“250”是对方扔过来的第几个数字（计数从1开始）。题目保证输出的数字在整型范围内。 输入样例：888 666 123 -233 250 13 250 -222 输出样例：5 123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123; int n; int index = 1; while (cin &gt;&gt; n) &#123; if (n == 250) &#123; break; &#125; index++; &#125; cout &lt;&lt; index &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-040. 最佳情侣身高差]]></title>
    <url>%2F2018%2F03%2F26%2FL1-040.%E6%9C%80%E4%BD%B3%E6%83%85%E4%BE%A3%E8%BA%AB%E9%AB%98%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[L1-040. 最佳情侣身高差专家通过多组情侣研究数据发现，最佳的情侣身高差遵循着一个公式：（女方的身高）×1.09=（男方的身高）。如果符合，你俩的身高差不管是牵手、拥抱、接吻，都是最和谐的差度。 下面就请你写个程序，为任意一位用户计算他/她的情侣的最佳身高。 输入格式：输入第一行给出正整数N（&lt;=10），为前来查询的用户数。随后N行，每行按照“性别 身高”的格式给出前来查询的用户的性别和身高，其中“性别”为“F”表示女性、“M”表示男性；“身高”为区间 [1.0, 3.0] 之间的实数。 输出格式：对每一个查询，在一行中为该用户计算出其情侣的最佳身高，保留小数点后2位。 输入样例：2M 1.75F 1.8 输出样例：1.611.96 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; char x; double h; cin &gt;&gt; x &gt;&gt; h; if (x == 'M') &#123; printf("%.2f\n", h / 1.09); &#125; else if (x == 'F') &#123; printf("%.2f\n", h * 1.09); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 程序设计基础]]></title>
    <url>%2F2018%2F03%2F26%2FJava%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[第 1 章 Java语言概述 Java语言有哪些特点？ 简单易学、面向对象、平台无关性、可靠性、安全性、支持多线程、支持网络编程、编译与解释并存 什么是Java的虚拟机？ 任何一种可以运行Java字节码的软件均可看成是Java的虚拟机 什么是字节码？采用字节码的最大好处是什么？ 字节码是Java虚拟机的指令组，和CPU上的微指令很相似 。字节码最大的好处是可跨平台运行 什么是平台无关性？Java语言是怎样实现平台无关性的？ 编写的应用程序不用修改就可以在不同的软硬件平台上运行。Java语言是靠JVM在目标代码级实现平台无关性的，可以说JVM是Java平台无关的基础 Java语言程序有几种？他们包含哪几个方面？ Application应用程序和Applet小程序 什么是Java程序的主类？ Java应用程序的主类必须包含一个定义为`public static void main(String[] args)`；Java小程序的主类必须是一个继承自系统JApplet或Applet的子类，且该类必须是public类。 第 3 章 Java语言基础 Java语言定义了哪几种基本数据类型？ 8种基本数据类型。byte, short, int, long, float, double, char 表示整数类型数据的关键字有哪几个？他们各占用几个字节？ byte, short, int, long分别占 1, 2, 4, 8个字节 单精度浮点float和双精度浮点double的区别是什么？ 单精度浮点数的数据位是32位，双精度浮点数的数据位是64位，double的精度是float的两倍 字符型常量与字符串常量的主要区别是什么？ 字符型常量是用一对单引号括起来的单个字符，字符串常量是用双引号括起来的一串若干个字符（可以是0个） 简述Java语言对定义标识符的规定有哪些。 标识符可以由字母、数字和下划线、美元符号等组合而成，标识符必须以字母、下划线或美元符号开头，不能以数字开头 Java语言采用何种编码方案？有何特点？ Unicode字符集编码方案，便于西文字符和中文字符的处理 什么是强制类型转换？在什么情况下需要强制类型转换？ 强制类型转换就是将长数据转换为短数据。如果要将较长的数据转换成较短的数据时，就要进行强制类型转换。 自动类型转换得前提是什么？转换是从”短”到”长”的优先级顺序是怎样的？ 转换前的数据类型与转换后的类型兼容，转换后的数据类型的表示范围比转换前的类型大。byte→short→char→int→long→float→double 数字字符串转换为数值型数据时，所使用的方法有哪些？ 转换的方法 功能说明 Byte.parseByte(String s) 将数字字符串转换为字节型数据 Short.parseShort(String s) 将数字字符串转换为短整型数据 Integer.parseInteger(String s) 将数字字符串转换为整型数据 Long.parseLong(String s) 将数字字符串转换为长整型数据 Float.parseFloat(String s) 将数字字符串转换为浮点型数据 Double.parseDouble(String s) 将数字字符串转让为双精度型数据 Boolean.parseBoolean(String s) 将字符串转换为布尔型数据 写出由键盘输入数据的两种基本格式。 在1.5版本之前，Java用BufferedReader来读取输入数据，在1.5版本之后，Java用Scanner来读取输入数据 12345678import java.io.*;public class Buffer &#123; public static void main(String[] args) throws IOException &#123; String str; BufferedReader buf = new BufferedReader(new InputStreamReader(System.in)); str = buf.readLine(); &#125;&#125; 12345678import java.io.*;import java.util.*;public class Scan &#123; public static void main(String[] args) throws IOException &#123; Scanner sc = new Scanner(System.in); double num = sc.nextDouble(); &#125;&#125; 编写程序，从键盘上输入一个浮点数，然后将该浮点数的整数部分输出。 浮点数的输入用double或者float，第一种方法用BufferedReader来读，第二种方法用Scanner来读 123456789import java.io.*;public class Exercise &#123; public static void main(String[] args) throws NumberFormatException, IOException &#123; BufferedReader buff = new BufferedReader(new InputStreamReader(System.in)); double num = Double.parseDouble(buff.readLine()); int i = (int) num; System.out.println(i); &#125;&#125; 123456789import java.util.*;public class Exercise &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); double t = in.nextDouble(); int num = (int) t; System.out.println(num); &#125;&#125; 编写程序，从键盘上输入两个整数，然后计算他们相除后得到的结果并输出。 123456789import java.util.*;public class Exercise &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int a = in.nextInt(); int b = in.nextInt(); System.out.println(a / b); &#125;&#125; 编写程序，从键盘上输入圆柱体的底半径r和高h，然后计算其体积并输出。 这里要用到Math.PI，假设题目给出的半径r和高h都是整形数值 123456789import java.util.*;public class Exercise &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int r = in.nextInt(); int h = in.nextInt(); System.out.println(Math.PI * r * r * h); &#125;&#125; Java语言有哪些基本的运算符？ 算术运行符包括 +、-、*、/、%、++、-- 关系运算符包括 &gt;、&lt;、&gt;=、&lt;=、==、!= 逻辑运算符包括 !、&amp;&amp;、||、&amp;、| 位运算符包括 &gt;&gt;、&lt;&lt;、&gt;&gt;&gt;、&amp;、|、^、~ 赋值运算符包括 = 条件运算符 ?: 分量运算符 . 下标运算符 [] 实例运算符 instanceof 内存分配运算符 new 强制类型转换运算符 (类型) 方法调用运算符 () 逻辑运算符中“逻辑与、逻辑或”和“简洁与、简洁或”的区别是什么？ 非简洁运算在必须计算完左右两个表达式之后，才取结果值；而简洁运算可能只计算左边的表达式而不计算右边的表达式，即对于 &amp;&amp;，只要左边的表达式为 false，就不计算右边的表达式，则整个表达式为 false；对于 ||，只要左边表达式为 true，就不计算右边表达式，则整个表达式为 true。 逻辑运算符与位运算符的区别是什么？ 位运算符的操作数只能为整型或字符型数据，虽然有的位运算符号（如 &amp;、|、^）与逻辑运算符的写法相同，但逻辑运算符的操作数为boolean型的量 什么是运算符的优先级和结合性？ 运算符的优先级决定了表达式中不同运算执行的先后顺序，运算符的结合性决定了并列的多个同级运算符的先后执行顺序 写出下列表达式的值，设x=3, y = 17, yn = true。 (1) x + y * x-- 3 + 17 * 3； 54 (2) -x * y + y -3 * 17 + 17； -34 (3) x &lt; y &amp;&amp; yn 3 &lt; 17 &amp;&amp; true; true (4) x &gt; y || !yn 3 &gt; 17 || false; false (5) y != ++x ? x : y 17 != 4 ? 4 : 17; 4 (6) y++ / --x 17 / 2; 8 (7) --y &gt;&gt;&gt; 3 16 &gt;&gt;&gt; 3; 2 第 4 章 流程控制 将学生的学习成绩按不同的分数段分为优、良、中、及格和不合格五个等级，从键盘上输入一个0~100之间的成绩，输出相应的等级。要求用switch语句实现。 12345678910111213141516171819202122232425import java.util.*;public class Exercise &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int score = in.nextInt(); switch (score / 10) &#123; case 10: case 9: System.out.println("优"); break; case 8: System.out.println("良"); break; case 7: System.out.println("中"); break; case 6: System.out.println("及格"); break; default: System.out.println("不合格"); break; &#125; &#125;&#125; 设学生的学习成绩按如下的分数评定为四个等级：85~100为A，70~84为B，60~69为C，0~59为D。从键盘上输入一个0~100之间的成绩，要求用switch语句根据成绩，评定并输出相应的等级。 1234567891011121314151617181920212223242526import java.util.*;public class Exercise &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int score = in.nextInt(); switch (score / 10) &#123; case 10: case 9: System.out.println("A"); break; case 8: if (score % 10 &gt;= 5) System.out.println("A"); else System.out.println("B"); break; case 7: case 6: System.out.println("C"); break; default: System.out.println("D"); break; &#125; &#125;&#125; 编写一个Java应用程序，输入1~100之间所有既可以被3整除，又可被7整除的数。 12345678public class Exercise &#123; public static void main(String[] args) &#123; for (int i = 1; i &lt;= 100; i++) &#123; if (i % 3 == 0 &amp;&amp; i % 7 == 0) System.out.println(i); &#125; &#125;&#125; 编写一个Java应用程序，在键盘上输入数n，计算并输出1!+2!+…+n!的结果 12345678910111213import java.util.*;public class Exercise &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); long sum = 0, temp = 1; for (int i = 1; i &lt;= n; i++) &#123; temp *= i; sum += temp; &#125; System.out.println(sum); &#125;&#125; 在键盘上输入数n，编程计算sum = 1 – (1 / 2!) + (1 / 3!) - … + ((-1)^(n - 1))*(1 / n!)。 123456789101112131415import java.util.*;public class Exercise &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); double sum = 0; int sign = 1, temp = 1; for (int i = 1; i &lt;= n; i++) &#123; temp *= i; sum += sign * (1.0 / temp); sign = -sign; &#125; System.out.println(sum); &#125;&#125; 水仙花数是指其个位、十位和百位三个数字的立方和等于这个三位数本身，求出所有的水仙花数。 12345678910111213public class Exercise &#123; public static void main(String[] args) &#123; for (int i = 100; i &lt;= 999; i++) &#123; int temp = i, sum = 0; while (temp != 0) &#123; sum += Math.pow(temp % 10, 3); temp /= 10; &#125; if (sum == i) System.out.println(i); &#125; &#125;&#125; 从键盘输入一个整数，判断该数是否是完全数。完全数是指其所有因数（包括1但不包括其本身）的和等于该数自身的数。例如，28 = 1 + 2 + 4 + 7 + 14 就是一个完全数。 12345678910111213import java.util.*;public class Exercise &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int num = in.nextInt(); int sum = 0; for (int i = 1; i &lt; num; i++) &#123; if (num % i == 0) sum += i; &#125; System.out.println(sum == num); &#125;&#125; 计算并输出一个整数各位数字之和。如，5423 的各位数字之和为 5 + 4 + 2 + 3。 12345678910111213import java.util.*;public class Exercise &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int num = in.nextInt(); int sum = 0; while (num != 0) &#123; sum += num % 10; num /= 10; &#125; System.out.println(sum); &#125;&#125; 从键盘上输入一个浮点型数，然后将该浮点数的整数部分和小数部分分别输出。 123456789import java.util.*;public class Exercise &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); double num = in.nextDouble(); int digital = (int) num; System.out.println(digital + " " + (num - digital)); &#125;&#125; 设有一长为 3000m 的绳子，每天减去一半，问需几天时间，绳子的长度会短于 5m。 1234567891011public class Exercise &#123; public static void main(String[] args) &#123; int day = 0; double len = 3000; while (len &gt;= 5) &#123; len /= 2; day++; &#125; System.out.println(day); &#125;&#125; 编程输出如下的数字图案： 1 3 6 10 15 2 5 9 14 4 8 13 7 12 11 123456789101112131415public class Exercise &#123; public static void main(String[] args) &#123; int[][] matrix = new int[5][5]; int k = 1; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt;= i; j++) matrix[i - j][j] = k++; &#125; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 5 - i; j++) System.out.print(matrix[i][j] + " "); System.out.println(); &#125; &#125;&#125; 第 5 章 数组与字符串 简述 Java 内存分配的机制。 Java 语言把内存分为两种：栈内存和堆内存。 在方法中定义的一些基本类型的变量和对象的引用变量都在方法的栈内存中分配，当在一段代码块中定义一个变量时，Java 就在栈内存中为这个变量分配内存空间，当超出变量的的作用域后，Java 会自动释放掉为该变量分配的内存空间。 堆内存用来存放由 new 运算符创建的对象和数组，在堆中分配的的内存，由 Java 虚拟机的自动垃圾回收器来管理。在堆中创建了一个数组或对象后，同时还在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，引用变量实际上保存的是数组或对象在堆内存中的地址（也称为对象的句柄），以后就可以在程序中使用栈的引用变量来访问堆中的数组或对象。 数组的主要特点： - 数组是相同数据类型的元素的集合。 - 数组中的各元素是有先后顺序的，它们在内存中按照这个先后顺序连续存放在一起。 - 数组元素用整个数组的名字和它自己在数组中的顺序位置来表示。例如 a[0] 表示名字为 a 的数组中的第一个元素。 String 类的常用方法 方法 说明 public int length() 返回字符串的长度 public boolean equals(Object anObject) 将给定字符串与当前字符串相比较，若两字符串相等，则返回 true，否则返回 false public String substring(int beginIndex) 返回字符串中从 beginIndex 开始的子串 public String substring(int beginIndex, int endIndex) 返回从 beginIndex 开始到 endIndex 的子串 public char charAt(int index) 返回 index 指定位置的字符 public int indexOf(String str) 返回 str 在字符串中第一次出现的位置 public String toLowerCase() 将字符串中所有的字符都转换为小写字符 public String toUpperCase() 将字符串中所有的字符都转换为大写字符 从键盘输入 n 个数，输出这些数中大于其平均值的数。 1234567891011121314151617import java.util.*;public class Exercise &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int[] num = new int[n]; double aver = 0; for (int i = 0; i &lt; n; i++) &#123; num[i] = in.nextInt(); aver += num[i] * 1.0 / n; &#125; for (int i = 0; i &lt; n; i++) &#123; if (num[i] &gt;= aver) System.out.println(num[i]); &#125; &#125;&#125; 从键盘输入 n 个数，求这 n 个数中最大数与最小数并输出。 1234567891011121314151617import java.util.*;public class Exercise &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int max = Integer.MIN_VALUE; int min = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) &#123; int temp = in.nextInt(); if (temp &gt; max) max = temp; if (temp &lt; min) min = temp; &#125; System.out.println("Max: " + max + "\n" + "Min: " + min); &#125;&#125; 求一个 3 阶方阵的对角线上各元素之和。 123456int[][] matrix = new int[3][3];int sum = 0;for (int i = 0; i &lt; 3; i++) &#123;truesum += matrix[i][i];truesum += matrix[2 - i][i];&#125; 找出 4 × 5 矩阵中值最小和最大元素，并输出其值及所在行号和列号。 1234567891011121314151617181920public class Exercise &#123; public static void main(String[] args) &#123; int[][] matrix; matrix = new int[][]&#123;&#123;12,23,34,15,7&#125;,&#123;23,14,61,45,78&#125;,&#123;3,12,43,54,65&#125;,&#123;34,56,87,54,23&#125;&#125;; int minRow = 0, minCol = 0, maxRow = 0, maxCol = 0; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; if (matrix[minRow][minCol] &gt; matrix[i][j]) &#123; minRow = i; minCol = j; &#125; if (matrix[maxRow][maxCol] &lt; matrix[i][j]) &#123; maxRow = i; maxCol = j; &#125; &#125; &#125; System.out.println("min: " + matrix[minRow][minCol] + "\n" + minRow + " " + minCol + "\n\n" + "max: " + matrix[maxRow][maxCol] + "\n" + maxRow + " " + maxCol); &#125;&#125; 产生 0 ～ 100 之间的 8 个随机整数，并用冒泡排序将其升序排序后输出（冒泡排序算法：每次进行相邻两数的比较，若次序不对，则交换两数的次序）。 12345678910111213141516171819202122import java.util.*;public class Exercise &#123; public static void main(String[] args) &#123; int[] num = new int[8]; Random random = new Random(); for (int i = 0; i &lt; 8; i++) &#123; num[i] = random.nextInt() % 100; &#125; for (int i = 0; i &lt; 7; i++) &#123; for (int j = 0; j &lt; 7 - i; j++) &#123; if (num[j] &gt; num[j + 1]) &#123; int temp = num[j]; num[j] = num[j + 1]; num[j + 1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; 8; i++) &#123; System.out.print(num[i] + " "); &#125; &#125;&#125; 15 个红球和 15 个绿球排成一圈，从第一个球开始数，当数到第 13 个球时就拿出此球，然后再从下一个球开始数，当再数到第 13 个球时又取出此球，如此循环进行，直到仅剩 15 个球为止，问怎样排法才能使每次取出的球都是红球。 12345678910111213141516171819202122public class Exercise &#123; public static void main(String[] args) &#123; int[] ball = new int[30]; for (int j = 0, temp = 0; temp &lt;= 15; temp++) &#123; int count = 1, i = j; while (count &lt; 13 || ball[i] == 1) &#123; if (ball[i] != 1) count++; i++; if (i == 30) i = 0; &#125; ball[i] = 1; j = i + 1; if (j == 30) j = 0; &#125; for (int i = 0; i &lt; 30; i++) &#123; System.out.print(ball[i] + " "); &#125; &#125;&#125; 编写 Java 应用程序，比较命令行中给出的两个字符串是否相等，并输出比较结果。 12345public class Exercise &#123; public static void main(String[] args) &#123; System.out.println(args[0].equals(args[1])); &#125;&#125; 从键盘上输入一个字符串和子串开始位置与长度，截取该字符串的子串并输出。 123456789import java.util.*;public class Exercise &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String s = in.next(); int start = in.nextInt(), len = in.nextInt(); System.out.println(s.substring(start, start + len)); &#125;&#125; 从键盘上输入一个字符串和一个字符，从该字符串中删除给定的字符。 123456789101112import java.util.*;public class Exercise &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String s = in.next(); char c = in.next().charAt(0); for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) != c) System.out.print(s.charAt(i)); &#125; &#125;&#125; 编程统计用户从键盘输入的字符串中所包含的字母，数字和其它字符的个数。 123456789101112131415161718import java.util.*;public class Exercise &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String s = in.nextLine(); int ch = 0, digital = 0, other = 0; for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if ((c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z')) ch++; else if (c &gt;= '0' &amp;&amp; c &lt;= '9') digital++; else other++; &#125; System.out.println(ch + " " + digital + " " + other); &#125;&#125; 将用户从键盘输入的每行数据都显示输出，直到输入字符串“exit”，程序运行结束。 12345678910111213import java.util.*;public class Exercise &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String data = ""; do &#123; data = in.nextLine(); if ("exit".equals(data)) break; System.out.println(data); &#125; while (true); &#125;&#125; 第 6 章 类与对象 类与对象的区别是什么？ 类是对某一类事物的描述，是抽象的、概念上的定义；对象则是实际存在的属该类事物的具体的个体，对象是类的实例化，因而也称为实例（instance）。 如何定义一个类？类的结构是怎样的？ 定义类实际上就是定义类的属性与方法。 1234567891011// 类的一般结构如下：[类修饰符] class 类名称&#123;true[修饰符] 数据类型 成员变量名称;true[修饰符] 返回值的数据类型 方法名(参数1, 参数2, ......)true&#123;truetrue语句序列;truetruereturn [表达式];true&#125;&#125; 定义一个类时所使用的修饰符有哪几个？每个修饰符的作用是什么？是否可以混用？ 定义一个类时所使用的修饰符有 4 个，一个类可以有多个修饰符，且无先后顺序之分，但 abstract 和 final 相互独立，所以不能同时应用在一个类的定义中，每个修饰符的作用如下： 修饰符 含义 public 将一个类声明为公共类，它可以被任何对象访问 abstract 将一个类声明为抽象类，没有实现方法，需要子类提供方法的实现，所以不能创建该类的实例 final 将一个类声明为最终类即非继承类，表示它不能被其他类所继承 缺省 缺省修饰符时，则表示只有在相同包中的对象才能使用这样的类 成员变量量的修饰符有哪些？各修饰符的功能是什么？是否可以混用？ 成员变量的修饰符有 8 个，除了访问控制修饰符有多个外，其他的修饰符都只有一个，每个修饰符的功能如下： 修饰符 含义 public 公共访问控制符。指定该变量为公共的。它可以被任何对象的方法访问 private 私有访问控制符。指定该变量只允许自己类的方法访问，其他任何类（包括子类）中的方法均不能访问此变量 protected 保护访问控制符。指定该变量只可以被它自己的类及其子类或同一包中的其它类访问，在子类中可以覆盖此变量 缺省 缺省访问控制符。表示在同一个包中的其他类可以访问此成员变量，其他包中的类不能访问该成员变量 final 最终修饰符。指定此变量的值不能改变 static 静态修饰符。指定该变量被所有对象共享，即所有实例都可以使用该变量 transient 过度修饰符。指定该变量是一个系统保留，暂无特别作用的临时性变量 volatile 易失修饰符。指定该变量可以同时被几个线程控制和修改 成员方法的修饰符有哪些？各修饰符的功能是什么？是否可以混用？ 成员方法的修饰符有 9 个，成员方法与成员变量同样有多个控制修饰符，当用两个以上的修饰符来修饰一个方法时，需要注意，有的修饰符之间是互斥的，所以不能同时使用。 修饰符 含义 public 公共访问控制符。指定该方法为公共的，它可以被任何对象的方法访问 private 私有访问控制符。指定该方法只允许自己类的方法访问，其他任何类（包括子类）中的方法均不能访问此方法 protected 保护访问控制符。指定该方法只可以被它的类及其子类或同一包中的其他类访问 缺省 缺省访问控制符。表示在同一个包中的其他类可以访问此成员方法，其他包中的类不能访问该成员方法 final 最终修饰符。指定该方法不能被重载 static 静态修饰符。指定不需要实例化一个对象就可以激活的方法 abstract 抽象修饰符。指定该方法只声明方法头，而没有方法体，抽象方法需在子类中被实现 synchronized 同步修饰符。在多线程程序中，该修饰符用于在运行前，对它所属的方法加锁，以防止其他线程访问，运行结束后解锁 native 本地修饰符。指定此方法的方法体是用其他语言（如 C）在程序外部编写的 成员变量与局部变量的区别有哪些？ 由类和方法的定义可知，在类和方法中均可定义属于自己的变量。类中定义的变量是成员变量，而方法中定义的变量是局部变量。 1. 从语法形式上看，成员变量是属于类的，而局部变量是在方法中定义的或是方法的参数；成员变量可以被 public、private、static 等修饰符所修饰，而局部变量则不能被访问控制符及 static 所修饰；成员变量和局部变量都可以被 final 修饰。 2. 从变量在内存中的存储方式上看，成员变量是对象的一部分，而对象是存在与堆内存中的，而局部变量是存在与栈内存中的。 3. 从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而产生，随着方法调用的结束而自动消失。 4. 成员变量如果没有被赋初值，则会自动以类型的默认值赋值（有一种情况例外，被 final 修饰但没有被 static 修饰的成员变量必须显式的赋值）；而局部变量则不会自动赋值，必须显式地赋值后才能使用。 创建一个对象使用什么运算符？对象实体与对象的引用有何不同？ 创建一个对象使用 new 运算符；对象实体是实在存在于堆内存中的，而对象的引用是管理对象实体的句柄存在于栈内存中。 对象的成员如何表示？ 对象的成员通过对象名.对象成员来访问。 在成员变量或成员方法前加上关键字 this 表示什么含义？ this.成员名 表示 对象本身的成员。this 代表调用此成员的对象。 什么是方法的返回值？返回值在类的方法里面的作用是什么？ 方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收产生的结果，使得它可以用于其他的操作。 在方法调用中，使用对象作为参数进行传递时，是“传值”还是“传址”？对象作参数起到什么作用？ 当参数是基本类型数据时，则是传值方式调用，而当参数是引用型的变量时，则是传址方式调用。 什么叫匿名对象？一般在什么情况下使用匿名对象？ 当一个对象被创建之后，在调用该对象的方法时，也可以不定义对象的引用变量，而直接调用对象的方法，这样的对象叫做匿名对象。 使用匿名对象通常有如下两种情况： 1. 如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。 2. 将匿名对象作为实参传递给一个方法调用。 定义一个 Student 类，包含的内容如下： 成员变量：学号，姓名，性别，班干部否，数学，语文，外语 成员方法：输入，总分，平均分 编程实现这个类，并调用相应的方法输入数据，计算总分和平均分。 123456789101112131415161718192021222324252627282930import java.util.*;public class Student &#123; private String id; private String name; private String gender; private String isLeader; private int math; private int chinese; private int english; public void input() &#123; Scanner in = new Scanner(System.in); id = in.next(); name = in.next(); gender = in.next(); isLeader = in.next(); math = in.nextInt(); chinese = in.nextInt(); english = in.nextInt(); in.close(); &#125; public int total() &#123; return math + chinese + english; &#125; public double aver() &#123; return total() / 3.0; &#125;&#125; 以 m 行 n 列二维数组为参数进行方法调用，分别计算二维数组各列元素之和，返回并输出所计算的结果。 123456789public void exercise(int[][] matrix, int m, int n) &#123; int[] sum = new int[n]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; sum[i] += matrix[j][i]; &#125; System.out.println(sum[i]); &#125; &#125; 第 7 章 Java 语言类的特性 一个类的公共成员与私有成员有何区别？ 私有成员无法从该类的外部访问到该类内部的成员，而只能被该类自身访问和修改，而不能被任何其他类包括该类的子类来获取或引用；公共成员则可以被其他的类访问。 什么是方法的重载？ 重载是指在同一个类内具有相同名称的多个方法，这多个同名方法如果参数个数不同，或者是参数个数相同，但类型不同，则这些同名的方法就具有不同的功能。 方法的重载是实现“多态”的一种方法。 一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？ 构造方法的作用是在对象被创建时初始化对象的成员的方法；如果一个类没有声明构造方法，该类也可以被正确实例化，Java 编译器会自动为该类生成一个默认的构造方法。 构造方法有哪些特性？ 1. 构造方法的方法名与类名相同 2. 构造方法没有返回值，但不能加 void 3. 构造方法的主要作用是完成对类对象的初始化工作 4. 构造方法一般不能由编程人员显式地直接调用，而是用 new 来调用 5. 在创建一个类的对象的同时，系统会自动调用该类的构造方法为对象初始化 在一个构造方法内可以调用另一个构造方法吗？如果可以，如何调用？ 可以；Java 语言允许在类内从某一构造方法内调用另一个构造方法；在某一构造方法内调用另一个构造方法时，必须使用 this 关键字来调用，否则编译时将出现错误，而且 this 关键字必须写在构造方法内的第一行的位置。 被 static 修饰的成员被称为静态成员，也称为类成员，而不用 static 修饰的成员称为实例成员。 静态变量与实例变量有哪些不同？ 用 static 修饰符修饰的成员变量称为“静态变量”，静态变量也称类变量。静态变量是隶属于类的变量，而不是属于任何一个类的具体变量，静态变量不需要实例化就可以使用。 实例变量是隶属于对象的变量，是属于具体的一个对象的，是需要把类实例化为对象才可以使用的。 静态方法与实例方法有哪些不同？ 用 static 修饰符修饰的方法是属于类的静态方法，又称为类方法。 静态方法实质是属于整个类的方法，而不加 static 修饰符的方法，是属于具体对象的方法。 在一个静态方法内调用一个非静态成员为什么是非法的？ 静态方法是属于整个类的，所以它不能操纵和处理属于某个对象的成员，而只能处理属于整个类的成员，即静态方法只能访问静态成员变量或静态成员方法。 对象的相等与指向它们的引用相等，两者有什么不同？ 对象的相等指的是对象的内容相等； 指向它们的引用相等指的是引用变量指向的地址相同； == 操作符专门用来比较两个变量的值是否相等； equals 方法是用于比较两个独立对象的内容是否相同。 什么是静态初始化器，其作用是什么？静态初始化器由谁在何时执行？它与构造方法有何不同？ 静态初始化器是由关键字 static 修饰的一对大括号“{}”括起来的语句组。它是用来完成初始化工作的；静态初始化器有 Java 虚拟机在类初始化的时候一次执行； 静态初始化器与构造方法有以下几点不同： 1. 构造方法是对每个新创建的对象初始化，而静态初始化器是对类自身进行初始化。 2. 构造方法是在用 new 运算符创建新对象时由系统自动执行，而静态初始化器一般不能由程序来调用，它是在所属的类被加载入内存时由系统调用执行的。 3. 用 new 运算符创建多少个新对象，构造方法就被调用多少次，但静态初始化器则在类被加载入内存时只执行一次，与创建多少个对象无关。 4. 不同于构造方法，静态初始化器不是方法，因而没有方法名，返回值和参数。 第 8 章 继承抽象类和接口 子类将继承父类的所有成员吗？为什么？ 不是；子类可以从父类那里继承所有非 private 的成员作为自己的成员。 在子类中可以调用父类的构造方法吗？若可以，如何调用？ 可以；在子类的的构造方法中通过 super() 来调用父类特定的构造方法中。 在调用子类的构造方法之前，会先自动调用父类中没有参数的构造方法，其目的是什么？ 目的是为了帮助继承自父类的成员做初始化操作。 在子类中可以访问父类的成员吗？若可以，用什么方式访问？ 可以；在子类中使用 super 不但可以访问父类的构造方法，还可以访问父类的成员变量和成员方法，但 super 不能访问在子类中添加的成员。 用父类对象变量可以访问子类的成员吗？若可以，则只限于什么情况？ 可以；通过父类的对象访问子类的成员，只限于“覆盖”的情况发生时。也就是说，父类与子类的方法名称、参数个数与类型必须是完全相同，才可以通过父类的对象调用子类的方法。 什么是“多态”机制？Java 语言中是如何实现多态的？ 多态是指“一种定义，多种实现”，多态有两种表现形式：重载和覆盖；多态是由方法重载，方法重写，继承，自动转型等引起的一系列特性。 方法的“覆盖”与方法的“重载”有何不同？ 重载是指在同一个类，内定义多个名称相同，但参数个数或类型不同的方法，从而，Java 系统便可根据参数的个数或类型，调用相对应的方法； 覆盖是指在子类中，定义名称、参数个数与类型均与父类完全相同的方法，用来重写父类中同名方法的操作。 this 和 super 分别有什么特殊含义？ super 是从子类调用调用父类的成员，包括构造方法、成员变量和成员方法。 this 是用来调用同一类内的成员，包括构造方法、成员变量和成员方法。 什么是最终类与最终方法？它们的作用是什么？ 在默认情况下，所有的成员变量和成员方法都可以被覆盖，如果父类的成员不希望被子类的成员所覆盖就可以将它们声明为 final。如果用 final 修饰成员变量，则成员变量是最终变量，即常量；如果用 final 修饰成员方法，则该方法为最终方法；如果一个类被 final 修饰符所修饰，则说明这个类不能被其他类所继承，即该类不可能有子类，这种类被称为最终类。 什么是抽象类与抽象方法？使用时应注意哪些问题？ 抽象类是以修饰符 abstract 修饰的类，抽象方法是以 abstract 关键字开头的方法，此方法只声明返回值的数据类型、方法名称与所需要的参数，但没有方法体。 需要注意的是： 1. 由于抽象类是需要被继承的，所以 abstract 类不能用 final 来修饰。也就是说，一个类不能既是最终类，又是抽象类，即关键字 abstract 与 final 不能合用。 2. abstract 不能与 private、static、final 或 native 并列修饰同一方法。 什么是接口？为什么要定义接口？ Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）; 接口实现和类继承的规则不同，为了数据的安全，继承时一个类只有一个直接父类，也就是单继承，但是一个类可以实现多个接口，接口弥补了类的不能多继承缺点，继承和接口的双重设计既保持了类的数据安全也变相实现了多继承。 如何定义接口？接口与抽象类有哪些异同？ 接口与抽象类有以下不同： 1. 接口的数据成员都是静态的，并且必须初始化。 2. 接口中的方法必须全部都声明为 abstract 的，也就是说，接口不能像抽象类一样拥有一般的方法，而必须全部是抽象方法。 接口定义的语法格式如下： 12345[public] interface 接口名称 [extends 父接口列表]&#123;true[public] [static] [final] 数据类型 成员变量名 = 常量；true[public] [abstract] 返回值的数据类型 方法名(参数表)；&#125; 内部类的类型有几种？分别在什么情况下使用？它们所起的作用有哪些？ 内部类分为： 成员内部类、局部内部类、静态嵌套类、匿名内部类 ；内部类的主要作用是将逻辑上相关的类放到一起；而匿名类是一种特殊的内部类，它没有类名，在定义类的同时，就生成该类的一个实例，由于不会在其他地方用到该类，所以不用取名字，因而又被称为匿名内部类。 内部类与外部类的使用有何不同？ 内部类不能与外部类同名，否则编译器无法区分内部类与外部类。如果内部类还有内部类，则内部类的内部类不能与它的任何一层外部类同名。在封装它的类的内部使用内部类，与普通类的使用方式相同，但在外部引用外部类时，则必须在内部类名前冠以其所属外部类的名字才能使用。在用 new 运算符创建内部类时，也要在 new 前面冠以对象变量。 怎样使用匿名内部类对象？ 匿名内部类是指可以利用内部类创建没有名称的对象，它一步完成了声明内部类和创建该类的一个对象，并利用该对象访问到类中的成员。匿名内部类的定义与创建该类的一个实例同时进行，即类的定义前面有一个 new 运算符，而不是使用关键字 class， 同时带上圆括号 “()” 表示创建对象。 创建匿名内部类的用意主要是用来弥补内部类中没有定义到的方法，并可有效地简化程序代码。 使用方法： 123456789( // 创建匿名内部类，并执行所定义的方法truenew 类名() // 括号 “()” 内不允许有参数true&#123;truetrue方法名(参数表)truetrue&#123;truetruetrue方法体语句；truetrue&#125;true&#125;).方法名(参数表)； 什么是包？它的作用是什么？如何创建包？如何引用包中的类？ 包是 Java 语言提供的一种区别类名空间的机制，是类的组织方式，每个包对应一个文件夹，包中还可以在有包，称为包等级。创建一个包需要使用 package 语句，格式为：`package 包名 1[.包名 2[.包名 3]]；`利用 import 语句引用 Java 定义的包及包中的类。 Java 语言中怎样清除对象？能否控制 Java系统中垃圾的回收时间？ 当一个对象不被任何引用类型的变量使用时，它的内存就会被 Java 垃圾回收器回收清楚对象；Java 语言不允许通过程序强迫垃圾回收器立即执行。 第 9 章 异常处理 什么是异常？简述 Java 语言的异常处理机制。 异常是指在程序运行中由代码产生的一种错误； Java 语言的异常处理机制： 1. 发现异常：程序在运行过程中发生由与算法考虑不周或软件设计错误等导致的程序异常事件。 2. 抛出异常：程序在运行过程中，如果发生了异常事件，则产生代表该异常的一个“异常对象”，并把它交给运行系统，再由运行系统寻找相应的代码来处理这一异常。生成异常对象并把它提交给运行系统的过程称为抛出异常。 3. 捕获异常：抛出异常后，运行系统从生成异常对象的代码开始，沿方法的调用栈逐层回溯查找，直到找到包含相应异常处理的方法，并把异常对象提交给该方法为止，这个过程称为捕获异常。 Throwable 类的两个直接子类 Error 和 Exception 的功能各是什么？用户可以捕获到的异常是哪个类的异常？ Error 类及其子类的对象，代表了程序运行时 Java 系统内部的错误。即 Error 类及其子类的对象是由 Java 虚拟机生成并抛出给系统，这种错误有内存溢出错、栈溢出错、动态链接错等。通常 Java 程序不对这种错误进行直接处理，必须交由操作系统处理； Exception 子类则是供应用程序使用的，它是用户程序能够捕捉到的异常情况； 用户可以捕捉的异常是 Exception 异常。 Exception 类有何作用？每个 Exception 类的对象代表什么？ Exception 类对象是 Java 程序抛出和处理的对象，它有各种不同的子类分别对应各种不同类型的异常。 什么是运行时异常？什么是非运行时异常？ Exception 类中的一个子类 RuntimeException 代表运行时异常，它是程序运行时自动地对某些错误做出反应而产生的； 除 RuntimeException 之外，其它则是非运行时异常，这种异常经常是在程序运行过程中由环境原因造成的异常。 抛出异常有哪两种方式？ 1. 系统自动抛出的异常。 2. 指定方法抛出异常。 抛出异常时，为什么要在 catch() 括号内有一个变量 e ？ 抛出异常时，throw 关键字所抛出的是由异常类所产生的对象，因此 throw 语句必须使用 new 运算符来产生对象，catch() 语句中的变量 e 是用来接收由 throw 关键字所抛出的由异常类所产生的对象。 在异常处理机制中，用 catch() 括号内的变量 e 接受异常类对象的步骤有哪些？ 1. try 程序块若是有异常发生时，程序的运行便中断，并抛出“异常类所产生的对象”。 2. 抛出的对象如果属于 catch()括号内欲捕获的异常类，则 catch 会捕捉此异常，然后进到 catch 的块里继续运行。 3. 无论 try 程序块是否有捕捉到异常，或者捕捉到的异常是否与 catch()括号里的异常相同，最后一定会运行 finally 块里的程序代码。finally 的程序代码块运行结束后，程序再回到 try-catch-finally 块之后继续执行。 在什么情况下，方法的头部必须列出可能抛出的异常？ 在方法内没有使用 try-catch 语句捕获异常，且方法内可能会产生异常时，则必须在声明方法的头部列出可能抛出的异常。 若 try 语句结构中有多个 catch() 子句，这些子句的排列顺序与程序执行效果是否有关？为什么？ 有关；由于异常对象与 catch 块的匹配是按照 catch 块的先后排列顺序进行的。若将子类异常的 catch 语句块放在父类异常 catch 语句块的后面，则编译不能通过。 什么是抛出异常？系统定义的异常如何抛出？用户自定义的异常又如何抛出？ 程序在运行过程中，如果发生了异常事件，则产生代表该异常的一个“异常对象”，并把它交给运行系统，再由运行系统寻找相应的代码来处理这一异常。生成异常对象并把它提交给运行系统的过程称为抛出异常； 所有系统定义的运行时异常都可以由系统自动抛出； 用户自定义的异常不能由系统自动抛出，因而必须借助于 throw 语句来定义何种情况算是产生了此种异常对应的错误，并应该抛出这个异常类的对象。 系统定义的异常与用户自定义的异常有何不同？如何使用这两类异常？ 系统定义的异常类主要用来处理系统可以预见的较常见的运行时错误，对于某个应用程序所持有的运行时异常错误，则需要编程人员根据程序的特殊逻辑关系在用户程序里自己创建用户自己定义异常类和异常对象。用户自定义异常类主要用来处理用户程序中可能产生的逻辑错误，使得这种错误能够被系统及时识别并处理，而不致于扩散产生更大的影响，从而使用户程序有更好的容错性能，并使整个系统更加稳定。 第 10 章 Java 语言的输入输出与文件处理 什么是文件的输入输出？ 程序从文件读取数据称为文件的输入；程序向文件写入数据称为文件的输出。 什么是流？Java 语言中分为哪两种流？这两种流有何差异？ 流是指计算机个部件之间的数据流动。在 Java 语言中，把不同类型的输入输出源（键盘、屏幕、文件、网络等）抽象为流，而其中输入或输出的数据称为数据流； 按照数据的传输方向，流可以分为输入流和输出流。从流的内容上划分，流分为字节流和字符流； 将数据从外设或外存（如键盘、鼠标、文件等）传递到应用程序的流称为输入流；将数据从应用程序传递到外设或外存（如屏幕、打印机、文件等）的流称为输出流。对于输入流只能从其读取数据而不能向其写入数据，同样对于输出流只能向其写入数据而不能从其读入数据。 InputStream、OutputStream、Reader 和 Writer 4 个类在功能上有何异同？ InputStream 和 OutputStream 类通常是用来处理 “字节流” 即 “位流” 的，也就是二进制文件，而Reader 和 Writer 类则是用来处理 “字符流” 的， 也就是文本文件。 InputStream、OutputStream、Reader 和 Writer 4 个类均是抽象类，所以不能直接使用这四个类，而是使用它们的子类来创建对象，再利用对象来处理读写操作。 利用基本输入输出流实现从键盘读入一个字符，然后显示在屏幕上。 123456789101112import java.io.*;public class Exercise &#123; public static void main(String[] args) throws IOException&#123; byte[] c = new byte[2]; InputStream in = new DataInputStream(System.in); in.read(c); OutputStream out = new DataOutputStream(System.out); out.write(c); in.close(); out.close(); &#125;&#125; 顺序输入输出流与管道输入输出流的区别什么？ 顺序输入流类 SequenceInputStream 是 InputStream 的直接子类，其功能是将多个输入流顺序连接在一起，形成单一的输入数据流，没有对应的输出数据流存在。在进行输入时，顺序输入流依次打开每个输入流并读取数据，在读取完毕后将该流关闭，然后自动切换到下一个输入流。 管道字节输入流 PipedInputStream 和 管道字节输出流 PipedOutputStream 类提供了利用管道方式进行数据输入输出管理的类。管道流用来将一个程序或线程的输出连接到另一个程序或线程作为输入，使得相应线程能够通过 PipedInputStream 和 PipedOutputStream 类进行数据交换，从而实现程序内部线程间的通信或不同程序间的通信。 Java 语言中定义的三个标准输入输出流是什么？它们对应什么设备？ 标准输入流，标准输出流，标准错误输出流； 标准输入流通常对应的设备是键盘； 标准输出流和标准错误输出流通常对应的设备是显示器。 利用文件输出流创建一个文件 file1.txt，写入字符 “文件已被成功创建！”，然后用记事本打开该文件，看是否正确写入。 123456789101112131415import java.io.File;import java.io.FileOutputStream;import java.io.IOException;public class Exercise &#123; public static void main(String[] args) throws IOException &#123; File file = new File("file1.txt"); FileOutputStream out = new FileOutputStream(file); String s = new String("文件已被创建成功!\n"); byte[] bytes = s.getBytes("UTF-8"); out.write(bytes); out.flush(); out.close(); &#125;&#125; 利用文件输入流打开第 7 题中创建的文件 file1.txt，读出其内容并显示在屏幕上。 123456789101112131415import java.io.File;import java.io.FileInputStream;import java.io.IOException;public class Exercise &#123; public static void main(String[] args) throws IOException &#123; File file = new File("file1.txt"); FileInputStream in = new FileInputStream(file); byte[] bytes = new byte[1024]; while (in.read(bytes) != -1) &#123; System.out.println(new String(bytes)); &#125; in.close(); &#125;&#125; 利用文件输入输出流打开第 7 题中创建的文件 file1.txt，然后在文件末尾追加一行字符串 “又添加了一行文字！”。 1234567891011121314import java.io.File;import java.io.FileOutputStream;import java.io.IOException;public class Exercise &#123; public static void main(String[] args) throws IOException &#123; File file = new File("file1.txt"); FileOutputStream out = new FileOutputStream(file, true); String s = "又添加了一行文字！"; byte[] bytes = s.getBytes("UTF-8"); out.write(bytes); out.close(); &#125;&#125; 产生 15 个 20~9999 之间的随机整数，然后利用 BufferedWriter 类将其写入文件 file2.txt 中；之后再读取该文件中的数据并将它们升序排序。 123456789101112131415161718192021222324252627282930313233343536import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.Arrays;public class Exercise &#123; public static void main(String[] args) throws IOException &#123; File file = new File("file2.txt"); BufferedWriter writer = new BufferedWriter(new FileWriter(file)); for (int i = 0; i &lt; 15; i++) &#123; String s = "" + ((int)(Math.random() * 9979) + 20) + "\n"; writer.write(s); &#125; writer.flush(); writer.close(); BufferedReader reader = new BufferedReader(new FileReader(file)); int[] nums = new int[15]; for (int i = 0; i &lt; 15; i++) &#123; nums[i] = Integer.parseInt(reader.readLine()); &#125; reader.close(); Arrays.sort(nums); writer = new BufferedWriter(new FileWriter(file)); for (int i = 0; i &lt; 15; i++) &#123; String s = "" + (nums[i]) + "\n"; writer.write(s); &#125; writer.flush(); writer.close(); &#125;&#125; Java 语言中使用什么类来对文件与文件夹进行管理？ 在 java.io 包中定义了一个 File 类，专门用来管理磁盘文件或文件夹，而不负责数据的输入输出。 第 11 章 多线程 简述线程的基本概念。程序、进程、线程的关系是什么？ 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程，形成多条执行路径。 程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。线程是进程划分成的更小的运行单位。 什么是多线程？为什么程序的多线程功能是必要的？ 所谓多线程就是同时执行一个以上的线程，一个线程的执行不必等待另一个线程执行完成后才执行，所有线程都可以发生在同一时刻。 单一的进程在执行任务时会出现资源空闲，采用多线程可以让 CPU 在同一段时间之内执行一个程序中的好几个程序段来完成工作，提高效率。 多线程与多任务的差异是什么？ 多任务与多线程是两个不同的概念，多任务是针对操作系统而言的，表示操作系统可以同时运行多个应用程序，而多线程是针对一个进程而言的，表示在一个进程内部可以同时执行多个线程。 线程有哪些基本状态？这些状态是如何定义的？ 新建状态、就绪状态、运行状态、阻塞状态和消亡状态。 新建状态：当线程对象已经被分配了内存空间和其他资源，并已被初始化，但是该线程尚未被调度。 就绪状态：就绪状态也称为可运行状态。处于新建状态的线程被启动后，将进入线程队列排队等待 CPU 时间片，此时它已具备了运行的条件，也就是处于就绪状态。 运行状态：当就绪状态的线程被调度并获得 CPU 资源时，便进入了运行状态。该状态表示线程正在运行，该线程已经拥有了对 CPU 的控制权。 阻塞状态：正在执行的线程如果在某些特殊情况下，将让出 CPU 并暂时中止自己的执行，线程所处于这种不可运行的状态被称为阻塞状态。阻塞状态是因为某种原因，系统不能执行线程的状态，在这种状态下即使 CPU 空闲也不能执行线程。 消亡状态：处于消亡状态的线程不具有继续运行的能力。 Java 程序实现多线程有哪两种途径？ Java 语言中实现多线程的方法有两种：一种是继承 java.lang 包中的 Thread 类，另一种是用户在自己定义的类中实现 Runnable 接口。但不管采用哪种方法，都要用到 Java 语言类库中的 Thread 类以及相关的方法。 在什么情况下，必须以类实现 Runnable 接口来创建线程？ 如果类本身已经继承了某个父类，由于 Java 语言不允许类的多重继承，所以无法再继承 Thread 类，此时就必须以类实现 Runnable 接口来创建线程。 Runnable 接口适合处理多线程访问同一资源的情况，并且可以避免由于 Java 语言的单继承性带来的局限。 什么是线程的同步？程序中为什么要实现线程的同步？是如何实现同步的？ 当一个线程对共享的数据进行操作时，应使之成为一个 “原子操作”，即在没有完成相关的操作之前，不允许其他的线程打断它，否则，就会破坏数据的完整性，必然会得到错误的处理结果，这就是线程的同步。 因为线程间的数据共享使得这些线程共同拥有对内存空间中数据的处理权力，这样会导致因为多个线程同时处理数据而使数据出现不一致，为了解决这一问题而提出同步的概念，即同步是在共享的基础之上的。 在并发程序设计中，对多线程共享的资源或数据称为临界资源或同步资源，而把每个线程中访问临界资源的那一段代码称为临界代码或临界区。简单地说，在一个时刻只能被一个线程访问的资源就是临界资源，而访问临界资源的那段代码就是临界区。临界区必须互斥地使用，即一个线程执行临界区中的代码时，其他线程不准进入临界区，直至该线程退出为止。为了使临界代码对临界资源的访问成为一个不可中断的原子操作，Java 技术利用对象 “互斥锁” 机制来实现线程间的互斥操作以实现同步操作。 假设某家银行可接受顾客的汇款，每次进行一次汇款，便可计算出汇款的总额。现有两名顾客，没人分 3 次，每次 100 元将钱汇入。是编写来模拟顾客的汇款操作。 12345678910111213141516171819202122232425262728293031323334public class Exercise &#123; public static void main(String[] args) &#123; Customer customer1 = new Customer("1 "); Customer customer2 = new Customer("2 "); customer1.start(); customer2.start(); &#125;&#125;class Customer extends Thread &#123; public Customer (String s) &#123; super(s); &#125; public void run() &#123; for (int i = 0; i &lt; 3; i++) &#123; Bank.deposit(100); &#125; &#125;&#125;class Bank &#123; public static int balance = 0; public synchronized static void deposit (int b) &#123; int temp = balance; temp += b; try &#123; Thread.sleep((int) (Math.random() * 1000)); &#125; catch (InterruptedException e) &#123; &#125; balance = temp; System.out.println(Thread.currentThread().getName() + " 汇款后总金额：" + balance); &#125;&#125; 第 12 章 图形界面设计 Swing 组件分为哪三类？ 容器类（container class）、辅助类（helper class）和组件类（component class）。 Swing 的顶层容器包含哪些窗格？大部分的可见组件都放在哪个窗格中？ Swing 的顶层容器主要有 JFrame、JApplet 和 JDialog 等；一般独立应用程序主要使用框架 JFrame 作为容器。 框架组件与面板组件的区别有哪些？ 以 JFrame 为代表的框架是一种带标题栏并且可以改变大小的窗口，而以 JPanel 类为代表的面板类与窗口类似，但它是一种没有标题栏的容器，且不能独立存在，必须包含在另一个容器之中。 颜色类 Color 中提供了哪些表示颜色的变量？ 变量名 代表颜色 black 或 BLACK 黑色 blue 或 BLUE 蓝色 cyan 或 CYAN 蓝青色 darkGray 或 DARK_GRAY 深灰色 gray 或 GRAY 灰色 green 或 GREEN 绿色 lightGray 或 LIGHT_GRAY 浅绿色 megenta 或 MAGENTA 红紫色 orange 或 ORANGE 桔黄色 pink 或 PINK 粉红色 red 或 RED 红色 white 或 WHITE 白色 yellow 或 YELLOW 黄色 字体类 Font 的主要用途有哪些？ 字体类 Font 是 java.awt 包中的类，是用来设置组件所用字体的样式、大小与字形等属性的。 图像图标类 ImageIcon 的主要作用是什么？Java 语言当前支持哪三种图像格式？ 图像图标类 ImageIcon 的主要作用是用来装饰组件的；Java 语言当前支持三种图像格式：GIF、JPEG 和 PNG，这三种图像文件的扩展名分别 gif、jpg 和 png。 Swing 主要用来处理文字输入的组件有几个？这几个组件有何不同点？ 文本编辑组件分为三种： 第一种是单行文本编辑组件，简称文本行，也称文本框，是通过 JTextField 类实现的； 第二种是密码文本行组件，是通过 JPasswordField 类实现的； 第三种是多行文本编辑组件，简称文本区，是通过 JTextArea 类实现的。 在将组件添加到窗口中时，为什么需将组件设置为不透明状态才能将其底色显现出来？ 因为 JFrame 的框架一旦被创建，其中就已经包含一个内容窗格，设置的 JFrame 背景颜色，仍然会被内容窗格遮盖，由框架内容窗格的委托特性可知，在往 JFrame 中添加组件时，组件都加在了内容窗格中。 如何设置才能将窗口的底色显现出来？ 内容窗格可以通过调用 JFrame 的成员方法 getContentPane() 获得，然后再设置内容窗格的背景色，这样才能显现出窗口的背景色。 设计一个窗口，内含一个文本框、三个复选框、两个单选按钮、一个标签和一个按钮。各组件的位置、大小和其上的文字由用户自己设定。 1234567891011121314151617181920212223242526272829303132333435363738import javax.swing.*;import java.awt.*;public class Exercise &#123; public static void main(String[] args) &#123; JFrame window = new JFrame("A Windows"); window.setLayout(new FlowLayout()); JTextField textField = new JTextField(20); window.add(textField); JCheckBox checkBox1 = new JCheckBox("CheckBox1"); JCheckBox checkBox2 = new JCheckBox("CheckBox2"); JCheckBox checkBox3 = new JCheckBox("CheckBox3"); window.add(checkBox1); window.add(checkBox2); window.add(checkBox3); JRadioButton radioButton1 = new JRadioButton("RadioButton1"); JRadioButton radioButton2 = new JRadioButton("RadioButton2"); ButtonGroup bg = new ButtonGroup(); bg.add(radioButton1); bg.add(radioButton2); window.add(radioButton1); window.add(radioButton2); JLabel label = new JLabel("This is a label"); window.add(label); JButton button = new JButton("Button"); window.add(button); window.pack(); window.setVisible(true); window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125;&#125; Java 语言中常用的布局管理器有哪几个？它们各有什么特点？ java.awt 包中共定义了五种布局管理器，每个布局管理器对应一种布局策略，分别是流式布局管理器 FlowLayout、边界式布局管理器 BorderLayout、卡片式布局管理器 CradLayout、网格式布局管理器 GridLayout 和网格包布局管理器 GridBagLayout。javax.swing 包中提供的布局管理器有盒式布局管理器 BoxLayout、重叠布局管理器 OverlayLayout 和弹簧布局管理器 SpringLayout 等。 1. 流式布局管理器 FlowLayout： 流式布局是一种 最基本的布局，它是一种流式页面设计。流式布局管理器 FlowLayout 的布局策略是： 1. 组件按照加入容器的先后顺序从左向右排列。 2. 一行排满之后就自动地转到下一行继续从左向右排列。 3. 每一行中的组件默认设置为居中排列。 FlowLayout 布局管理器是 JPanel 默认的布局管理方式。 2. 边界式布局管理器 BorderLayout： 边界式布局管理器 BorderLayout 将显示区域按地理方位为东（East）、西（West）、南（South）、北（North）、中（Center）5 个区域。在将组件加入容器时，都应该指出把这个组件加入到哪个区域中，若没有指定区域，则默认为中间。若将组件加入到已被其它组件占用的区域，将会取代原先的组件。 3. 网格式布局管理器 GridLayout： 网格式布局管理器 GridLayout 提供的页面布局规则是将容器的空间划分成若干行与列的网格形式，每个网格称为单元格，在容器上添加组件时，它们会按从左到右、从上到下的顺序在网格中排列。网格的行数和列数可以在创建 GridLayout 对象的构造方法中指定。利用 GridLayout 布局策略时，容器中各组件占用一个单元格，所以各组件的宽度相同，同样，所有组件的高度也是相同的。当容器的尺寸发生变化时，各组件的相对位置不变，但各自的尺寸会发生变化。 4. 卡片式布局管理器 CardLayout： 卡片式布局管理器 CardLayout 的页面布局方式是把 “容器” 中的所有组件如同堆叠起来的一副 “扑克牌”，每次只能显示最上面的一张一样，这个被显示的组件将占据所有的容器空间。“容器” 有可能只是一个 JFrame，或者是将 JFrame 细分为数个 “容器”，每个 “容器” 可拥有自己的窗口对象以及布局管理器。所有基于 CardLayout 布局方式在显示区域内每次只有一个组件是可见的。 利用卡片布局管理器时，通常要用到多个容器，其中一个容器使用卡片布局管理器，而另外的容器使用其他的布局管理器。 5. 网格包布局管理器 GridBagLayout： 网格包布局管理器 GridBagLayout 是在网格布局管理器 GridLayout 的基础上发展而来的，所以它与 GridLayout 类似，它们都是用网格的形式来组织组件的。使用 GridBagLayout 布局比较复杂，但其功能比较强大。由于 GridLayout 中每个网格的大小相同，并且强制组件与网格大小相同，从而使得容器中的每个组件也都是相同的大小，显得很不自然，而且组件加入容器也必须按照固定的排列顺序，因此不够灵活。GridBagLayout 布局管理器也是将容器中的组件按行、列的位置摆放，但在 GridBagLayout 布局管理器中允许组件栈用不同行或者不同列的多个单元格，这些被占用的单元格称为组件的显示区域。 6. 盒式布局管理器 BoxLayout： BoxLayout 是一种 Swing 布局管理器，这种布局策略是在一行或一列中摆放组件。如果采用沿水平方向排列组件方式，当组件的总宽度超出容器的宽度时，组件也不会换行，而是沿同一行继续排列组件。如果采用竖直方向排列组件也是一样。这时需要改变容器的大小才能见到所有的组件，即有些组件可能处于不可见状态。 7. 重叠布局管理器 OverlayLayout 和弹簧布局管理器 SpringLayout 简介： 重叠布局管理器 OverlayLayout 和弹簧布局管理器 SpringLayout 均是 Swing 中定义的布局管理器。具有 OverlayLayout 布局管理策略的容器，将加入该容器的所有组件叠放在一起，第一个被加入容器的组件会放在容器的最前面，这样后加入容器的组件会被先加入的组件遮盖住。这时可将前面的组件利用 JComponent.setOpaque(false) 方法将其设置为透明的，则下面组件被遮盖部分就能显示出来。弹簧布局管理器 SpringLayout 的主要思想在组件的周围放置一个灵活的弹簧，这种弹簧可以压缩或伸长，把组件堆放到要求的位置。 第 13 章 事件处理 什么是事件？简述 Java 语言的委托事件模型。 所谓事件（Event），就是用户使用鼠标或键盘对窗口中的组件进行交互时所发生的事情。事件用于描述发生了什么事情，对这些事件作出响应的程序称为事件处理程序。 在 Java 语言中对事件的处理，采用的是委托事件模型机制。 委托事件模型是将事件源（如命令按钮）和对事件做出的具体处理（利用监听者来对事件进行具体的处理）分离下来。一般情况下，组件（事件源）不处理自己的事件，而是将事件处理委托给外部的处理实体（监听者），这是事件处理模型就是事件的委托处理模型，即事件源将事件处理任务委托给监听者。总的来说，委托事件模型是有产生事件的对象（事件源）、事件对象以及事件监听者对象之间的关系所组成。而其中的 “事件监听者” 就是用来处理事件的对象，也就是说，监听者对象会等待事件的发生，并在事件发生时收到通知。事件源会在事件产生时，将关于该事件的信息封装在一个对象中，这就是 “事件对象”，并将该事件对象作为参数传递给事件监听者，监听者就可以根据该 “事件对象” 内的信息决定适当的处理方式，即调用相应的事件处理程序。 若要处理事件，就必须要有事件监听者，通常哪些对象的可以担任监听者？ 1. 让包含 “事件源” 的容器对象来担任监听者。 2. 定义内部类来担任监听者。 3. 使用匿名内部类来担任监听者。 写出组件可能产生的事件的对应关系。 见书中表 13.2 Swing 事件源通常可能触发的事件类型及事件监听者接口。 Java 语言中处理事件的具体方法是什么？ 1. 确认触发的事件，取得事件类的名字，如 ActionEvent，去掉其中的 “Event” 字样，在剩下的部分加入 “Listener”，这就是在类中需要实现的事件监听者接口。 2. 实现上述的接口，针对想要捕获的事件编写方法代码。如要捕获单击按钮事件，就要为 ActionListener 接口里的 actionPerformed() 方法编写代码。 3. 为事件监听者创建一个对象，让组件调用方法完成对它的注册，方法是在监听者接口的名字里加一个前缀 “add”，如 addActionListener()。 在进行事件处理时，可以使用实现多个监听者接口的方式，也可以尽可能地使用继承适配器类型的方式。使用适配器类的好处是什么？ 当需要对某种事件进行处理时，只需让事件处理类继承事件所对应的适配器类，这样只需覆盖本次操作用到的事件处理方法即可，而不必实现无关的事件处理方法。 设计一个窗口，在窗口内放置一个按钮，当不断地单击该按钮时，在其上显示它被单击的次数。 12345678910111213141516171819202122232425262728293031323334import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class Exercise &#123; public static void main(String[] args) &#123; new Window(); &#125;&#125;class Window extends JFrame &#123; private JButton button; private int time; private JLabel label; public Window() &#123; button = new JButton("Click Me"); label = new JLabel("0"); label.setHorizontalAlignment(JLabel.CENTER); time = 0; button.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent actionEvent) &#123; time++; label.setText("" + time); &#125; &#125;); add(button, BorderLayout.NORTH); add(label, BorderLayout.SOUTH); pack(); setVisible(true); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125;&#125; 设计一个窗口，在该窗口中添加一个 JList 组件，该组件中有 5 门课程名称的选项。然后再在窗口中添加一个文本区，当选择 JList 组件中的某个选项后，文本区中显示对该课程的介绍。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import javax.swing.*;import javax.swing.event.ListSelectionEvent;import javax.swing.event.ListSelectionListener;import java.awt.*;public class Exercise &#123; public static void main(String[] args) &#123; new Window(); &#125;&#125;class Window extends JFrame &#123; private JList&lt;String&gt; courses; public Window() &#123; String[] model = &#123;"English", "Chinese", "C Programing Language", "Java Programing Language", "Math"&#125;; courses = new JList&lt;&gt;(model); JScrollPane scrollPane = new JScrollPane(courses); add(scrollPane, BorderLayout.CENTER); JTextArea textArea = new JTextArea(); textArea.setEditable(false); add(textArea, BorderLayout.SOUTH); courses.addListSelectionListener(new ListSelectionListener() &#123; @Override public void valueChanged(ListSelectionEvent listSelectionEvent) &#123; String s =courses.getSelectedValue(); switch (s) &#123; case "English" : textArea.setText("This is English"); break; case "Chinese" : textArea.setText("This is Chinese"); break; case "C Programing Language" : textArea.setText("This is C Programing Language"); break; case "Java Programing Language" : textArea.setText("This is Java Programing Language"); break; case "Math" : textArea.setText("This is Math"); break; &#125; &#125; &#125;); pack(); setVisible(true); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125;&#125; 设计一个窗口，其中包含一个文本区、两个复选框和 3 个横向滑动条，其中滑动条用来调整 R、G、B 三色的分量从 0 ～ 255 变化；两个复选框分别用于设定把滑动条调出的颜色应用于文本区的前景色还是背景色。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import javax.swing.*;import javax.swing.event.ChangeEvent;import javax.swing.event.ChangeListener;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class Exercise &#123; public static void main(String[] args) &#123; new Window(); &#125;&#125;class Window extends JFrame &#123; JCheckBox frontGroundColor = new JCheckBox("frontGroundColor"); JCheckBox backGroundColor = new JCheckBox("backGroundColor"); JTextArea textArea = new JTextArea("选择前景色和背景色，滑动滑动条查看颜色变化", 20, 30); JSlider rJSlider = new JSlider(JSlider.HORIZONTAL, 0, 255, 0); JSlider gJSlider = new JSlider(JSlider.HORIZONTAL, 0, 255, 0); JSlider bJSlider = new JSlider(JSlider.HORIZONTAL, 0, 255, 0); public Window() &#123; setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS)); add(textArea); JPanel select = new JPanel(); select.setLayout(new FlowLayout()); select.add(frontGroundColor); select.add(backGroundColor); add(select); JPanel colorPanel = new JPanel(); colorPanel.setLayout(new BoxLayout(colorPanel,BoxLayout.Y_AXIS)); colorPanel.add(rJSlider); colorPanel.add(gJSlider); colorPanel.add(bJSlider); rJSlider.setMajorTickSpacing(30); rJSlider.setMinorTickSpacing(3); rJSlider.setPaintTicks(true); rJSlider.setPaintLabels(true); gJSlider.setMajorTickSpacing(30); gJSlider.setMinorTickSpacing(3); gJSlider.setPaintTicks(true); gJSlider.setPaintLabels(true); bJSlider.setMajorTickSpacing(30); bJSlider.setMinorTickSpacing(3); bJSlider.setPaintTicks(true); bJSlider.setPaintLabels(true); add(colorPanel); frontGroundColor.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent actionEvent) &#123; if (frontGroundColor.isSelected()) &#123; textArea.setForeground(new Color(rJSlider.getValue(), gJSlider.getValue(), bJSlider.getValue())); &#125; else &#123; textArea.setForeground(new Color(0, 0, 0)); &#125; &#125; &#125;); backGroundColor.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent actionEvent) &#123; if (backGroundColor.isSelected()) &#123; textArea.setBackground(new Color(rJSlider.getValue(), gJSlider.getValue(), bJSlider.getValue())); &#125; else &#123; textArea.setBackground(new Color(255, 255, 255)); &#125; &#125; &#125;); rJSlider.addChangeListener(new ColorListen()); gJSlider.addChangeListener(new ColorListen()); bJSlider.addChangeListener(new ColorListen()); pack(); setVisible(true); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; class ColorListen implements ChangeListener &#123; @Override public void stateChanged(ChangeEvent changeEvent) &#123; if (frontGroundColor.isSelected()) &#123; textArea.setForeground(new Color(rJSlider.getValue(), gJSlider.getValue(), bJSlider.getValue())); &#125; if (backGroundColor.isSelected()) &#123; textArea.setBackground(new Color(rJSlider.getValue(), gJSlider.getValue(), bJSlider.getValue())); &#125; &#125; &#125;&#125; 编写一个应用程序，在其中窗口内包含一个菜单栏和一个文本区。菜单栏包括 “设置” 和 “操作” 两个菜单。“操作” 菜单包括 “退出” 菜单项，当用户选择 “退出” 菜单项时，则关闭窗口退出整个应用程序的运行；“设置” 菜单包括 “字体” 和 “风格” 两个菜单项和一个 “只读” 复选菜单项。“字体” 菜单项包括 “宋体”、“楷体” 和 “黑体” 3 个单选子菜单项，“风格” 菜单项包括 “普通”、“粗体”、“斜体” 等 3 个复选子菜单项。当 “只读” 菜单项未被选中时，用户可以在文本区内输入字符：当 “只读” 菜单项被选中时，用户不能在文本区内输入字符。当用户选择其他菜单项时，文本区内的文字随之变化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.BoxLayout;import javax.swing.ButtonGroup;import javax.swing.JCheckBoxMenuItem;import javax.swing.JFrame;import javax.swing.JMenu;import javax.swing.JMenuBar;import javax.swing.JMenuItem;import javax.swing.JRadioButtonMenuItem;import javax.swing.JTextArea;public class Exercise &#123; public static void main(String[] args) &#123; new Window(); &#125;&#125;class Window extends JFrame &#123; JTextArea textArea = new JTextArea(20, 30); public Window() &#123; setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS)); JMenuBar menuBar = new JMenuBar(); JMenu setting = new JMenu("Setting"); JMenu operating = new JMenu("Operating"); menuBar.add(setting); menuBar.add(operating); JMenuItem exit = new JMenuItem("Exit"); exit.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.exit(0); &#125; &#125;); operating.add(exit); JMenu style = new JMenu("Style"); JMenu font = new JMenu("Font"); ButtonGroup buttonGroup = new ButtonGroup(); JRadioButtonMenuItem ssti = new JRadioButtonMenuItem("宋体"); JRadioButtonMenuItem klti = new JRadioButtonMenuItem("楷体"); JRadioButtonMenuItem hzti = new JRadioButtonMenuItem("黑体"); buttonGroup.add(ssti); buttonGroup.add(klti); buttonGroup.add(hzti); font.add(ssti); font.add(klti); font.add(hzti); JCheckBoxMenuItem normal = new JCheckBoxMenuItem("正常"); JCheckBoxMenuItem black = new JCheckBoxMenuItem("粗体"); JCheckBoxMenuItem till = new JCheckBoxMenuItem("斜体"); style.add(normal); style.add(black); style.add(till); JRadioButtonMenuItem readOnly = new JRadioButtonMenuItem("Read-Only"); setting.add(style); setting.add(font); setting.add(readOnly); add(menuBar); add(textArea); readOnly.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; if (readOnly.isSelected()) &#123; textArea.setEditable(false); &#125; else &#123; textArea.setEditable(true); &#125; &#125; &#125;); addText(normal); addText(black); addText(till); addText(ssti); addText(klti); addText(hzti); addText(readOnly); setVisible(true); pack(); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; private void addText(JMenuItem item) &#123; item.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; textArea.append(item.getText() + "\n"); &#125; &#125;); &#125;&#125; 在 9 题的基础上增加如下的功能：每当用户选中 “只读” 菜单项时，都将 “字体” 和 “风格” 两个菜单项变成灰色，使之不能被选中；而每当 “只读” 菜单项为被选中时，再将 “字体” 和 “风格” 两个菜单项恢复成可选状态。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.BoxLayout;import javax.swing.ButtonGroup;import javax.swing.JCheckBoxMenuItem;import javax.swing.JFrame;import javax.swing.JMenu;import javax.swing.JMenuBar;import javax.swing.JMenuItem;import javax.swing.JRadioButtonMenuItem;import javax.swing.JTextArea;public class Exercise &#123; public static void main(String[] args) &#123; new Window(); &#125;&#125;class Window extends JFrame &#123; JTextArea textArea = new JTextArea(20, 30); public Window() &#123; setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS)); JMenuBar menuBar = new JMenuBar(); JMenu setting = new JMenu("Setting"); JMenu operating = new JMenu("Operating"); menuBar.add(setting); menuBar.add(operating); JMenuItem exit = new JMenuItem("Exit"); exit.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.exit(0); &#125; &#125;); operating.add(exit); JMenu style = new JMenu("Style"); JMenu font = new JMenu("Font"); ButtonGroup buttonGroup = new ButtonGroup(); JRadioButtonMenuItem ssti = new JRadioButtonMenuItem("宋体"); JRadioButtonMenuItem klti = new JRadioButtonMenuItem("楷体"); JRadioButtonMenuItem hzti = new JRadioButtonMenuItem("黑体"); buttonGroup.add(ssti); buttonGroup.add(klti); buttonGroup.add(hzti); font.add(ssti); font.add(klti); font.add(hzti); JCheckBoxMenuItem normal = new JCheckBoxMenuItem("正常"); JCheckBoxMenuItem black = new JCheckBoxMenuItem("黑体"); JCheckBoxMenuItem till = new JCheckBoxMenuItem("斜体"); style.add(normal); style.add(black); style.add(till); JRadioButtonMenuItem readOnly = new JRadioButtonMenuItem("Read-Only"); setting.add(style); setting.add(font); setting.add(readOnly); add(menuBar); add(textArea); readOnly.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; if (readOnly.isSelected()) &#123; textArea.setEditable(false); style.setEnabled(false); font.setEnabled(false); &#125; else &#123; textArea.setEditable(true); style.setEnabled(true); font.setEnabled(true); &#125; &#125; &#125;); addText(normal); addText(black); addText(till); addText(ssti); addText(klti); addText(hzti); addText(readOnly); setVisible(true); pack(); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; private void addText(JMenuItem item) &#123; item.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; textArea.append(item.getText() + "\n"); &#125; &#125;); &#125;&#125; 第 14 章 绘图程序设计 简述 Graphics 类的特征。 Graphics 类是一个特殊类，它是提供与设备无关图形界面的抽象类，它可以在不同平台的屏幕上显示图形和图像。 java 语言中提供的用于显示和重画图形的方法有哪几个？ 用于显示图形的方法是 JComponent 类的 paintComponent() 方法，其格式如下：`protected void paintComponent (Graphics g)` 用于对组件上的图形进行重画可以使用 repaint() 方法，该方法格式如下：`public void repaint ()`。 paintComponent() 在什么情况下会自动被调用？ 1. 在组件首次显示或从隐藏变成显示时。 2. 从缩小的图标还原后。 3. 正在改变窗口的大小时。 第 15 章小程序设计 Java 小程序的基本工作原理是什么？ 将编译好的小程序字节码文件，即 .class 文件保存在特定的 WWW 服务器上，在同一个或另一个 WWW 服务器上保存着嵌有该字节码文件名的 HTML 文件。当某一个浏览器向服务器请求下载嵌入了小程序的 HTML 文件时，该文件从 WWW 服务器上下载到客户端，由 WWW 浏览器解释 HTML 文件中的各种标记，将文件中的信息以一定的格式显示在用户屏幕上。当浏览器遇到 HTML 文件中嵌有小程序的标记时，浏览器会根据这个小程序的名字和位置自动把字节码文件从 WWW 服务器上下载到本地，并利用浏览器本身拥有的 Java 解释器直接执行该字节码文件。 init()、start()、stop() 和 destory() 是小程序中非常重要的 4 个方法，请问它们各自的调用时机和功能是什么？ 1. init() 方法：该方法是在小程序被创建时第一个调用的方法，它只运行一次，主要是用来对小程序设置初值之用。它的原理和一个构造方法差不多。一般进行的操作是：设置初始状态和参数值，添加用户接口组件以及装载图像等。 2. start() 方法：调用完 init() 方法之后，就立即调用 start() 方法。只要小程序画面每出现一次，start() 方法就会被调用一次。如果切换到其它网页浏览，再返回到本页面时，用户使用了浏览器的 Reload（刷新）操作等，start() 方法都会再运行一次。所以对于只打算使用一次的代码，可以放在 init() 方法中，不必定义在这个方法内；而需要经常重复启动的操作则应放在 start() 方法中。在多线程的程序设计中 start() 方法主要用于编写启动线程的代码，如动画、音频的启动运行等。 3. stop() 方法：stop() 方法类似于 start() 方法的 你操作，当浏览器窗口失去焦点变为不活动状态、切换到其他网页浏览或是关闭浏览器时，需要停止小程序的运行，此时系统会自动调用 stop() 方法以暂停小程序的运行，所以 stop() 方法也可以被重复调用。stop() 方法常常用于完成暂停小程序运行并暂时释放小程序所占用的资源的功能。 4. destroy() 方法：当用户退出浏览器时，浏览器运行的小程序也将停止运行，释放内存。此时浏览器会自动调用小程序对象的 destroy() 方法来完成一些释放资源、关闭连接之类的操作等。但在关闭浏览器时会先调用 stop() 方法暂停运行小程序，然后再调用 destroy() 方法来释放被小程序所占用的资源。 如何向小程序传递参数？ Java 应用程序是通过命令行来接受用户参数的，在小程序中这个任务是通过 HTML 文件的一个专门标记 &lt;Param&gt; 来完成的。在 HTML 文件和小程序之间进行参数传递，需要注意以下几点： 1. 在 HTML 文件中通过 Param 标记来设置要向小程序进行传递的参数。 2. 小程序中只能在 init() 方法中调用 getParameter() 方法来接收 HTML 文件传递来的参数。 3. 在 HTML 文件中由 Param 设置的参数名称必须与 getParameter() 方法中接受参数的名成匹配，两者军事区别大小写的。 4. HTML 文件中的每个 Param 标记只能传递一个且为字符串型的参数。而小程序中接收参数的 getParameter() 方法的返回值也是字符串型，所以如果需要的是其它类型的数据，则还需要将字符串转换成相应的类型。 将 Java 的应用程序转换成小程序的主要步骤有哪些？ 将应用程序转换成小程序，其转换步骤如下： 1. 制作一个 HTML 网页文件，带有相应的标记，从而能够下载小程序的代码。 2. 声明一个类，使其继承 Applet 或 JApplet 类。若使用 Swing 组件，则必须继承 JApplet 类，并使其为 public 类型，否则这个小程序不能被下载。 3. 在应用程序中去掉 mian() 方法。 4. 在应用程序中，设置窗口的大小是通过调用 setSize() 方法来实现的；在小程序中设定它的大小是通过在 HTML 文件中设置 Width 和 Height 两个参数来实现的。 5. 小程序在浏览器退出时，它会终止。 6. 如果在应用程序中使用 setTitle() 为窗口中设置标题，那么在转换成小程序时此方法不能使用。 7. 用 init() 方法替换构造方法，在浏览器创建这个小程序类的一个对象时，它调用了 init() 方法。 编写小程序，用 paint() 方法显示一行字符串，小程序包含 “放大” 和 “缩小” 两个按钮。当单击 “放大” 按钮时，显示的字符串的字体放大一号；单击 “缩小” 按钮时，显示的字符串字体缩小一号。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.awt.Container;import java.awt.FlowLayout;import java.awt.Font;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.JApplet;import javax.swing.JButton;import javax.swing.JTextArea;public class Exercise extends JApplet &#123; private String s; private JButton big; private JButton smaller; private int size = 16; private JTextArea textArea; @Override public void init() &#123; s = "This is a string"; big = new JButton("放大"); smaller = new JButton("缩小"); textArea = new JTextArea(s); textArea.setFont(new Font(s, Font.ITALIC, size)); Container c = getContentPane(); c.setLayout(new FlowLayout()); c.add(textArea); c.add(big); c.add(smaller); big.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; size++; textArea.setFont(new Font(s, Font.ITALIC, size)); &#125; &#125;); smaller.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; size--; textArea.setFont(new Font(s, Font.ITALIC, size)); &#125; &#125;); &#125;&#125; 加载与显示图像的操作需要经过哪 3 个步骤？ 1. 声明 Image 类型的对象。 2. 利用 getImage() 方法加载图像。 3. 利用 drawImage() 方法绘制出图像。 第 17 章 Java 网络编程 什么是 URL？URL 地址由哪几部分组成？ URL 是统一资源定位器（Uniform Resource Locator）的英文缩写，它表示 Internet 上某一资源的地址； URL 的基本结构由 5 部分组成，其格式如下： 传输协议://主机名:端口号/文件名#引用 1. 传输协议（protocol）：传输协议是指所使用的协议名，如 HTTP、FTP等。 2. 主机名（hostname）：主机名是指资源所在的计算机。可以是 IP 地址，也可以是计算机的名称或域名。 3. 端口号（portnumber）：一个计算机中可能有多种服务，如 Web 服务、FTP 服务或自己建立的服务等。为了区分这些服务，就需要使用端口号，每一种服务用一个端口号。 4. 文件名（filename）：文件名包括该文件的完整路径。在 HTTP 协议中，有一个默认的文件名 index.html，因此，下列两个地址是等价的。 http://java.sun.com http://java.sun.com/index.html 5. 引用（reference）：引用就是资源内部的某个参考点。如： http://java.sun.com/index.html#chapter1 说明：对于一个 URL 来说，并不是要求它必须包含所有的这 5 部分内容。 什么是 Socket？它与 TCP/IP 协议有何关系？ Socket 通信属于网络底层通信，它是网络上运行的两个程序之间双向通信的一端，它既可以接受请求，也可以发送请求，利用它可以较方便地进行网络上的数据传输。Socket 是实现客户与服务器（Client/Server）模式的通信方式，它首先需要建立稳定的连接，然后以流的方式传输数据，实现网络通信。Socket 原意为 “插座”，在通信领域中译为 “套接字”，意思是将两个物品套在一起，在网络通信里的含义就是建立一个连接； Socket 在 TCP/IP 协议中定义，针对一个特定的连接。 简述流式 Socket 的通信机制。它的最大特点是什么？为什么可以实现无差错通信？ 当两台计算机进行通信时，首先要在两者之间建立一个连接，也就是两者分别运行不同的程序，由一端发出连接请求，另一端等候连接请求。当等候端收到请求并接受请求后，两个程序就建立起一个连接，之后通过这个连接可以进行数据交换。 什么是端口号？服务器和客户端分别如何使用端口号？ 端口号是区分一台主机中的不同应用程序的正整数；服务器和客户端必须为每个程序分配一个唯一的端口号，通过端口号指定要连接的程序。 什么是套接字？其作用是什么？ 套接字是实现客户与服务器模式的通信模式，它首先需要建立稳定的连接，然后以流的方式传输数据，实现网络通信； 套接字是网络上运行的两个程序间双向通信的一端，既可以接受请求，也可以发送请求，利用它可以较方便地进行网络上的数据传输。 编写 Java 程序，使用 InetAddress 类实现根据域名自动到 DNS（域名服务器）上查找 IP 地址的功能。 1234567891011121314151617181920import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.InetAddress;import java.net.UnknownHostException;public class Exercise &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); String dns = bufferedReader.readLine(); bufferedReader.close(); InetAddress inetAddress = null; try &#123; inetAddress = InetAddress.getByName(dns); System.out.println(inetAddress.getHostAddress()); &#125; catch (UnknownHostException e) &#123; System.out.println("Your Input Domain Can't Parse."); &#125; &#125;&#125; 用 Java 程序实现流式 Socket 通信，需要使用哪两个类？它们是如何定义的？应怎样使用？ Socket 类与 ServerSocket 类； Socket 类在 java.net.Socket 继承自 java.lang.Object 类。Socket 类用在客户端，用户通过创建一个 Socket 对象来建立与服务器的连接。 ServerSocket 类在 java.net 包中，java.ner.ServerSocket 继承自 java.lang.Object 类。ServerSocket 类的作用是实现客户机 / 服务器模式的通信方式下服务器端的套接字。 与流式 Socket 相比，数据报通信有何特点？ 数据报是无连接的远程通信服务，它是一种在网络中传输的、独立的、自身包含地址信息的数据单位，不保证传送顺序和内容的准确性。 Java 练习题 编写一个 Application 并定义一个异常类，要求完成如下操作。定义一个 money 类，包括： 存款余额：成员变量 yu； 存款操作：方法 putMoney(double money) 取款操作：方法 getMoney(double money) 获取余额：方法 getYu() 如果存款余额小于取款额时，显示当前余额，并告之不能取款，否则显示取款成功的信息。 12345678910111213141516171819202122232425262728293031323334public class Exercise &#123; public static void main(String[] args) &#123; Money money = new Money(); money.putMoney(1000); try &#123; money.getMoney(500); &#125; catch (MoneyException e) &#123; System.out.println("当前余额为：" + money.getYu() + " 不能取款"); &#125; &#125;&#125;class MoneyException extends Exception &#123; MoneyException() &#123; &#125;&#125;class Money &#123; private double yu = 0; public void putMoney(double money) &#123; yu = yu + money; System.out.println("存款成功！"); &#125; public void getMoney(double money) throws MoneyException&#123; if (!(yu &gt;= money)) throw new MoneyException(); yu = yu - money; System.out.println("取款成功！"); &#125; public double getYu() &#123; return yu; &#125;&#125; 实现两个定时器，一个线程每隔 1s 显示一次，一个线程每隔 3s 显示一次。 1234567891011121314151617181920212223242526272829303132333435public class Exercise &#123; public static void main(String[] args) &#123; Thread1 thread1 = new Thread1(); Thread2 thread2 = new Thread2(); thread1.start(); thread2.start(); &#125;&#125;class Thread1 extends Thread &#123; public void run() &#123; while (true) &#123; System.out.println("第一个线程！"); try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class Thread2 extends Thread &#123; public void run() &#123; while (true) &#123; System.out.println("第二个线程！"); try &#123; sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 编写一个类，类名为 MulThread，定义含一个字符串参数的构造方法，并实现 Runnable 接口，接口中的 run() 方法如下实现，方法先在命令行显示该线程信息，然后随机休眠小于 1s 的时间，最后显示线程结束信息：finished + 线程名。编写一个 Application 程序，创建 MulThread 类的 3 个线程对象 t1, t2, t3，并再启动这 3 个线程。 12345678910111213141516171819202122232425262728293031public class Exercise &#123; public static void main(String[] args) &#123; MulThread th1 = new MulThread("th1"); MulThread th2 = new MulThread("th2"); MulThread th3 = new MulThread("th3"); Thread t1 = new Thread(th1); Thread t2 = new Thread(th2); Thread t3 = new Thread(th3); t1.start(); t2.start(); t3.start(); &#125;&#125;class MulThread implements Runnable &#123; private String string; MulThread (String str) &#123; string = str; &#125; public void run() &#123; System.out.println(string); try &#123; Thread.sleep((int)(Math.random() * 1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("Finished " + string); &#125;&#125; 设计一个窗口，内含一个按钮。开始运行时，按钮显示 “click me ！” 字样，但按下按钮时，按钮上面的文字变成 “click me again ！”，再按一次，则会变成 “click me ！”。如此循环。 123456789101112131415161718192021222324252627282930313233import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.JButton;import javax.swing.JFrame;public class Exercise &#123; public static void main(String[] args) &#123; new Windows(); &#125;&#125;class Windows extends JFrame &#123; JButton button; public Windows()&#123; button = new JButton("Click Me"); this.add(button); button.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent actionEvent) &#123; if(button.getText().equals("Click Me"))&#123; button.setText("Click Me Again"); &#125; else button.setText("Click Me"); &#125; &#125;); this.setVisible(true); this.setBounds(50,50,200,150); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125;&#125; 编写一个应用程序，设计 4 个按钮，分别明明 “加”，“减”，“乘”，“除”；有三个文本框。单击相应的按钮，将两个文本框的数字做运算，在第三个文本框中显示结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import java.awt.Color;import java.awt.Dimension;import java.awt.FlowLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.Box;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JOptionPane;import javax.swing.JTextField;public class Exercise &#123; public static void main(String[] args) &#123; new Calculaor(); &#125;&#125;class Calculaor implements ActionListener&#123; private JButton jb1,jb2,jb3,jb4; private JTextField jt1,jt2,jt3; private JFrame jf; private Box box1,box2,basebox; public Calculaor()&#123; jf=new JFrame("简单计算器"); jf.setBounds(300, 300, 440, 130); jf.setVisible(true); jf.setLayout(new FlowLayout()); jb1 = new JButton("加"); jb2 = new JButton("减"); jb3 = new JButton("乘"); jb4 = new JButton("除"); jb1.addActionListener(this); jb2.addActionListener(this); jb3.addActionListener(this); jb4.addActionListener(this); jt1 = new JTextField(" "); jt2 = new JTextField(" "); jt3 = new JTextField(" "); Dimension dim = new Dimension(100, 20); Dimension dim2 = new Dimension(180, 20); jt1.setPreferredSize(dim); jt2.setPreferredSize(dim); jt3.setPreferredSize(dim2); jt3.setEditable(false); jt3.setBackground(Color.gray); box1 = Box.createHorizontalBox(); box1.add(jt1); box1.add(Box.createHorizontalStrut(10)); box1.add(jt2); box1.add(Box.createHorizontalStrut(10)); box1.add(jt3); box2 = Box.createHorizontalBox(); box2.add(jb1); box2.add(Box.createHorizontalStrut(10)); box2.add(jb2); box2.add(Box.createHorizontalStrut(10)); box2.add(jb3); box2.add(Box.createHorizontalStrut(10)); box2.add(jb4); basebox = Box.createVerticalBox(); basebox.add(box1); basebox.add(Box.createVerticalStrut(10)); basebox.add(box2); jf.add(basebox); jf.validate(); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public void actionPerformed(ActionEvent e) &#123; String temp1 = jt1.getText().trim(); String temp2 = jt2.getText().trim(); if(temp1.equals("")||temp2.equals(""))&#123; JOptionPane.showMessageDialog(jf,"文本框不能为空。"); &#125;else&#123; double a = 0, b = 0; try&#123; a = Double.parseDouble(temp1); b = Double.parseDouble(temp2); &#125;catch(Exception e1)&#123; JOptionPane.showMessageDialog(jf,"您输入了非法字符,请输入正确的数字。"); return; &#125; if(e.getSource() == jb1)&#123; jt3.setText(""+(a + b)); System.out.println("" + (a + b)); &#125;else if(e.getSource() == jb2)&#123; jt3.setText("" + (a - b)); &#125;else if(e.getSource() == jb3)&#123; jt3.setText("" + (a * b)); &#125;else if(e.getSource() == jb4)&#123; jt3.setText("" + (a / b)); &#125; &#125; &#125;&#125; 编写一个图形用户界面的应用程序，包括两个文本框和一个按钮，当单击按钮时，可以把一个文本框中的内容复制到另一个文本框中。 12345678910111213141516171819202122232425262728293031323334353637383940import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class Exercise &#123; public static void main(String[] args) &#123; new Windows(); &#125;&#125;class Windows extends JFrame &#123; JButton button = new JButton("Add"); JTextField textField1 = new JTextField(30); JTextField textField2 = new JTextField(30); public Windows() &#123; Container app = this.getContentPane(); BoxLayout boxLayout = new BoxLayout(app, BoxLayout.X_AXIS); setLayout(boxLayout); add(textField1); JPanel panel = new JPanel(); panel.add(button); add(panel); add(textField2); button.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent actionEvent) &#123; if (textField1.getText().length() &gt; 0) &#123; textField2.setText(textField2.getText() + textField1.getText() + "\n"); textField1.setText(""); &#125; &#125; &#125;); setVisible(true); pack(); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125;&#125; 编写一个应用程序，要求有一个含有菜单的窗口，窗口中有文本区组件。菜单有 “打开文件” 的菜单项，当单击菜单项时，使用输入流将一个名为 “hello.txt” 文件的内容读入到文本区。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.io.*;import javax.swing.*;public class Exercise &#123; public static void main(String[] args) throws IOException&#123; File file = new File("hello.txt"); FileOutputStream out = new FileOutputStream(file); String st = new String("This is a string of characters!"); byte[] bytes = st.getBytes("UTF-8"); out.write(bytes); out.flush(); out.close(); new Window(); &#125;&#125;class Window extends JFrame &#123; JTextArea textArea = new JTextArea(20, 30); public Window() throws IOException&#123; setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS)); JMenuBar menuBar = new JMenuBar(); JButton openFile = new JButton("Open File"); menuBar.add(openFile); add(menuBar); add(textArea); openFile.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent actionEvent) &#123; File file = new File("hello.txt"); FileInputStream in = null; try &#123; in = new FileInputStream(file); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; byte[] bytes = new byte[1024]; try &#123; while (in.read(bytes) != -1) &#123; textArea.setText(new String(bytes)); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); setVisible(true); pack(); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-039. 古风排版]]></title>
    <url>%2F2018%2F03%2F25%2FL1-039.%E5%8F%A4%E9%A3%8E%E6%8E%92%E7%89%88%2F</url>
    <content type="text"><![CDATA[L1-039. 古风排版中国的古人写文字，是从右向左竖向排版的。本题就请你编写程序，把一段文字按古风排版。 输入格式：输入在第一行给出一个正整数N（&lt;100），是每一列的字符数。第二行给出一个长度不超过1000的非空字符串，以回车结束。 输出格式：按古风格式排版给定的字符串，每列N个字符（除了最后一列可能不足N个） 输入样例：4This is a test case 输出样例：asa Tst ihe tsi ce s 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; string s; getchar(); getline(cin, s); int col = ((s.length() - 1) / n + 1); char cs[n][col]; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; col; ++j) &#123; cs[i][j] = ' '; &#125; &#125; int index = 0; for (int j = col - 1; j &gt;= 0; j--) &#123; for (int i = 0; i &lt; n; i++) &#123; if (index &lt; s.length()) cs[i][j] = s[index++]; &#125; &#125; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; col; ++j) &#123; cout &lt;&lt; cs[i][j]; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-038. 新世界]]></title>
    <url>%2F2018%2F03%2F25%2FL1-038.%E6%96%B0%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[L1-038. 新世界这道超级简单的题目没有任何输入。 你只需要在第一行中输出程序员钦定名言“Hello World”，并且在第二行中输出更新版的“Hello New World”就可以了。 123456789#include &lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; "Hello World" &lt;&lt; endl; cout &lt;&lt; "Hello New World" &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-037.A除以B]]></title>
    <url>%2F2018%2F03%2F24%2FL1-037.A%E9%99%A4%E4%BB%A5B%2F</url>
    <content type="text"><![CDATA[L1-037. A除以B真的是简单题哈 —— 给定两个绝对值不超过100的整数A和B，要求你按照“A/B=商”的格式输出结果。 输入格式：输入在第一行给出两个整数A和B（-100 &lt;= A, B, &lt;= 100），数字间以空格分隔。 输出格式：在一行中输出结果：如果分母是正数，则输出“A/B=商”；如果分母是负数，则要用括号把分母括起来输出；如果分母为零，则输出的商应为“Error”。输出的商应保留小数点后2位。 输入样例1：-1 2 输出样例1：-1/2=-0.50 输入样例2：1 -3 输出样例2：1/(-3)=-0.33 输入样例3：5 0 输出样例3：5/0=Error 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main() &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; double res = (double)a / b; if (b &lt; 0) &#123; printf("%d/(%d)=%.2f", a, b, res); &#125; else if (b == 0) &#123; printf("%d/0=Error", a); &#125; else &#123; printf("%d/%d=%.2f", a, b, res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-036. A乘以B]]></title>
    <url>%2F2018%2F03%2F24%2FL1-036.A%E4%B9%98%E4%BB%A5B%2F</url>
    <content type="text"><![CDATA[L1-036. A乘以B看我没骗你吧 —— 这是一道你可以在10秒内完成的题：给定两个绝对值不超过100的整数A和B，输出A乘以B的值。 输入格式：输入在第一行给出两个整数A和B（-100 &lt;= A, B, &lt;= 100），数字间以空格分隔。 输出格式：在一行中输出A乘以B的值。 输入样例：-8 13 输出样例：-104 12345678910import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int a = in.nextInt(); int b = in.nextInt(); System.out.println(a * b); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-035. 情人节]]></title>
    <url>%2F2018%2F03%2F24%2FL1-035.%E6%83%85%E4%BA%BA%E8%8A%82%2F</url>
    <content type="text"><![CDATA[L1-035. 情人节以上是朋友圈中一奇葩贴：“2月14情人节了，我决定造福大家。第2个赞和第14个赞的，我介绍你俩认识…………咱三吃饭…你俩请…”。现给出此贴下点赞的朋友名单，请你找出那两位要请客的倒霉蛋。 输入格式：输入按照点赞的先后顺序给出不知道多少个点赞的人名，每个人名占一行，为不超过10个英文字母的非空单词，以回车结束。一个英文句点“.”标志输入的结束，这个符号不算在点赞名单里。 输出格式：根据点赞情况在一行中输出结论：若存在第2个人A和第14个人B，则输出“A and B are inviting you to dinner…”；若只有A没有B，则输出“A is the only one for you…”；若连A都没有，则输出“Momo… No one is for you …”。 输入样例1：GaoXZhMagiEinstQuarkLaoLaoFatMouseZhaShenfantacylatesumSenSenQuanQuanwhateverwheneverPotatyhahaha. 输出样例1：Magi and Potaty are inviting you to dinner… 输入样例2：LaoLaoFatMousewhoever. 输出样例2：FatMouse is the only one for you… 输入样例3：LaoLao. 输出样例3：Momo… No one is for you … 1234567891011121314151617181920212223242526272829303132333435import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int counter = 0; String A = null, B = null; while (true) &#123; String s = in.nextLine(); if (s.equals(".")) &#123; break; &#125; counter++; if (counter == 2) &#123; A = s; &#125; if (counter == 14) &#123; B = s; &#125; &#125; if (A != null) &#123; if (B != null) &#123; System.out.println(A + " and " + B +" are inviting you to dinner..."); &#125; else &#123; System.out.println(A + " is the only one for you..."); &#125; &#125; else &#123; System.out.println("Momo... No one is for you ..."); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-034. 点赞]]></title>
    <url>%2F2018%2F03%2F24%2FL1-034.%E7%82%B9%E8%B5%9E%2F</url>
    <content type="text"><![CDATA[L1-034. 点赞微博上有个“点赞”功能，你可以为你喜欢的博文点个赞表示支持。每篇博文都有一些刻画其特性的标签，而你点赞的博文的类型，也间接刻画了你的特性。本题就要求你写个程序，通过统计一个人点赞的纪录，分析这个人的特性。 输入格式：输入在第一行给出一个正整数N（&lt;=1000），是该用户点赞的博文数量。随后N行，每行给出一篇被其点赞的博文的特性描述，格式为“K F1 … FK”，其中 1&lt;=K&lt;=10，Fi（i=1, …, K）是特性标签的编号，我们将所有特性标签从1到1000编号。数字间以空格分隔。 输出格式：统计所有被点赞的博文中最常出现的那个特性标签，在一行中输出它的编号和出现次数，数字间隔1个空格。如果有并列，则输出编号最大的那个。 输入样例：43 889 233 25 100 3 233 2 734 3 73 889 22 233 123 输出样例：233 3 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int map[1001];int main() &#123; int n; cin &gt;&gt; n; int a, b; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; a; for (int j = 0; j &lt; a; ++j) &#123; cin &gt;&gt; b; map[b]++; &#125; &#125; int max = 0, index = 0; for (int i = 1; i &lt;= 1000; ++i) &#123; if (max &lt;= map[i]) &#123; index = i; max = map[i]; &#125; &#125; cout &lt;&lt; index &lt;&lt; " " &lt;&lt; max; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-033. 出生年]]></title>
    <url>%2F2018%2F03%2F24%2FL1-033.%E5%87%BA%E7%94%9F%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[L1-033. 出生年以上是新浪微博中一奇葩贴：“我出生于1988年，直到25岁才遇到4个数字都不相同的年份。”也就是说，直到2013年才达到“4个数字都不相同”的要求。本题请你根据要求，自动填充“我出生于y年，直到x岁才遇到n个数字都不相同的年份”这句话。 输入格式：输入在一行中给出出生年份y和目标年份中不同数字的个数n，其中y在[1, 3000]之间，n可以是2、或3、或4。注意不足4位的年份要在前面补零，例如公元1年被认为是0001年，有2个不同的数字0和1。 输出格式：根据输入，输出x和能达到要求的年份。数字间以1个空格分隔，行首尾不得有多余空格。年份要按4位输出。注意：所谓“n个数字都不相同”是指不同的数字正好是n个。如“2013”被视为满足“4位数字都不同”的条件，但不被视为满足2位或3位数字不同的条件。 输入样例1：1988 4 输出样例1：25 2013 输入样例2：1 2 输出样例2：0 0001 12345678910111213141516171819202122232425262728293031import java.text.DecimalFormat;import java.util.HashSet;import java.util.Scanner;import java.util.Set;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int y = in.nextInt(); int n = in.nextInt(); DecimalFormat df = new DecimalFormat("0000"); Set&lt;Integer&gt; set = new HashSet(); int res = y, count = 0; for (int i = y; i &lt;= 3012; i++) &#123; set.clear(); int tmp = i; for (int j = 0; j &lt; 4; j++) &#123; int a = tmp % 10; tmp = tmp / 10; set.add(a); &#125; if (set.size() == n) &#123; res = i; count = i - y; System.out.println(count + " " + df.format(res)); break; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-032. Left-pad]]></title>
    <url>%2F2018%2F03%2F24%2FL1-032.Left-pad%2F</url>
    <content type="text"><![CDATA[L1-032. Left-pad根据新浪微博上的消息，有一位开发者不满NPM（Node Package Manager）的做法，收回了自己的开源代码，其中包括一个叫left-pad的模块，就是这个模块把javascript里面的React/Babel干瘫痪了。这是个什么样的模块？就是在字符串前填充一些东西到一定的长度。例如用“”去填充字符串“GPLT”，使之长度为10，调用left-pad的结果就应该是“*GPLT”。Node社区曾经对left-pad紧急发布了一个替代，被严重吐槽。下面就请你来实现一下这个模块。 输入格式：输入在第一行给出一个正整数N（&lt;=104）和一个字符，分别是填充结果字符串的长度和用于填充的字符，中间以1个空格分开。第二行给出原始的非空字符串，以回车结束。 输出格式：在一行中输出结果字符串。 输入样例1：15 _I love GPLT 输出样例1：____I love GPLT 输入样例2：4 *this is a sample for cut 输出样例2： cut 12345678910111213141516171819202122232425import java.util.Scanner;import static java.lang.System.out;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); String c = in.next(); in.nextLine(); String str = in.nextLine(); if (n &gt; str.length()) &#123; for (int i = 0; i &lt; (n - str.length()); i++) &#123; out.print(c); &#125; out.println(str); &#125; else &#123; for (int i = (str.length() - n); i &lt; str.length(); i++) &#123; out.print(str.charAt(i)); &#125; out.println(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-031. 到底是不是太胖了]]></title>
    <url>%2F2018%2F03%2F24%2FL1-031.%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E5%A4%AA%E8%83%96%E4%BA%86%2F</url>
    <content type="text"><![CDATA[L1-031. 到底是不是太胖了据说一个人的标准体重应该是其身高（单位：厘米）减去100、再乘以0.9所得到的公斤数。真实体重与标准体重误差在10%以内都是完美身材（即 |真实体重-标准体重| &lt; 标准体重x10%）。已知1市斤=0.5公斤。现给定一群人的身高和实际体重，请你告诉他们是否太胖或太瘦了。 输入格式：输入第一行给出一个正整数N（&lt;= 20）。随后N行，每行给出两个整数，分别是一个人的身高H（120 &lt; H &lt; 200；单位：厘米）和真实体重W（50 &lt; W &lt;= 300；单位：市斤），其间以空格分隔。 输出格式：为每个人输出一行结论：如果是完美身材，输出“You are wan mei!”；如果太胖了，输出“You are tai pang le!”；否则输出“You are tai shou le!”。 输入样例：3169 136150 81178 155 输出样例：You are wan mei!You are tai shou le!You are tai pang le! 123456789101112131415161718192021222324252627import java.util.Scanner;import static java.lang.System.out;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int a, b; for (int i = 0; i &lt; n; i++) &#123; a = in.nextInt(); b = in.nextInt(); double tmp = (a - 100) * 0.9 * 2; boolean isfat = Math.abs(b - tmp) &lt; tmp * 0.1; if (isfat) &#123; out.println("You are wan mei!"); &#125; else if (b - tmp &gt; 0) &#123; out.println("You are tai pang le!"); &#125; else if (b - tmp &lt; 0) &#123; out.println("You are tai shou le!"); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-030. 一帮一]]></title>
    <url>%2F2018%2F03%2F24%2FL1-030.%E4%B8%80%E5%B8%AE%E4%B8%80%2F</url>
    <content type="text"><![CDATA[L1-030. 一帮一“一帮一学习小组”是中小学中常见的学习组织方式，老师把学习成绩靠前的学生跟学习成绩靠后的学生排在一组。本题就请你编写程序帮助老师自动完成这个分配工作，即在得到全班学生的排名后，在当前尚未分组的学生中，将名次最靠前的学生与名次最靠后的异性学生分为一组。 输入格式：输入第一行给出正偶数N（&lt;=50），即全班学生的人数。此后N行，按照名次从高到低的顺序给出每个学生的性别（0代表女生，1代表男生）和姓名（不超过8个英文字母的非空字符串），其间以1个空格分隔。这里保证本班男女比例是1:1，并且没有并列名次。 输出格式：每行输出一组两个学生的姓名，其间以1个空格分隔。名次高的学生在前，名次低的学生在后。小组的输出顺序按照前面学生的名次从高到低排列。 输入样例：80 Amy1 Tom1 Bill0 Cindy0 Maya1 John1 Jack0 Linda 输出样例：Amy JackTom LindaBill MayaCindy John 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); Node[] ss = new Node[n]; int a; String b; for (int i = 0; i &lt; n; i++) &#123; a = in.nextInt(); b = in.next(); ss[i] = new Node(a, b); &#125; for (int i = 0; i &lt; n / 2; i++) &#123; if (ss[i].isvisted == false) &#123; int j = n - 1; while (ss[i].a == ss[j].a || ss[j].isvisted == true) &#123; j--; &#125; if (ss[j].isvisted == false) &#123; ss[i].setIsvisted(true); ss[j].setIsvisted(true); System.out.println(ss[i].s + " " + ss[j].s); &#125; &#125; &#125; &#125; static class Node &#123; int a; String s; boolean isvisted = false; Node(int a, String s) &#123; this.a = a; this.s = s; &#125; public void setIsvisted(boolean isvisted) &#123; this.isvisted = isvisted; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-029. 是不是太胖了]]></title>
    <url>%2F2018%2F03%2F24%2FL1-029.%E6%98%AF%E4%B8%8D%E6%98%AF%E5%A4%AA%E8%83%96%E4%BA%86%2F</url>
    <content type="text"><![CDATA[L1-029. 是不是太胖了据说一个人的标准体重应该是其身高（单位：厘米）减去100、再乘以0.9所得到的公斤数。已知市斤是公斤的两倍。现给定某人身高，请你计算其标准体重应该是多少？（顺便也悄悄给自己算一下吧……） 输入格式：输入第一行给出一个正整数H（100 &lt; H &lt;= 300），为某人身高。 输出格式：在一行中输出对应的标准体重，单位为市斤，保留小数点后1位。 输入样例：169 输出样例：124.2 12345678910111213#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main() &#123; double n; cin &gt;&gt; n; printf("%.1f", (n - 100) * 0.9 * 2); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-028. 判断素数]]></title>
    <url>%2F2018%2F03%2F24%2FL1-028.%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[L1-028. 判断素数本题的目标很简单，就是判断一个给定的正整数是否素数。 输入格式：输入在第一行给出一个正整数N（&lt;=10），随后N行，每行给出一个小于231的需要判断的正整数。 输出格式：对每个需要判断的正整数，如果它是素数，则在一行中输出“Yes”，否则输出“No”。 输入样例：211111 输出样例：YesNo 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;bool isPrime(int a) &#123; if (a == 1 || a == 0) return false; for (int i = 2; i &lt; sqrt(a); ++i) &#123; if (a % i == 0) &#123; return false; &#125; &#125; return true;&#125;int main() &#123; int n; cin &gt;&gt; n; int arr[n]; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; arr[i]; &#125; for (int i = 0; i &lt; n; ++i) &#123; if (isPrime(arr[i])) &#123; cout &lt;&lt; "Yes" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "No" &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-027. 出租]]></title>
    <url>%2F2018%2F03%2F24%2FL1-027.%E5%87%BA%E7%A7%9F%2F</url>
    <content type="text"><![CDATA[L1-027. 出租下面是新浪微博上曾经很火的一张图： 一时间网上一片求救声，急问这个怎么破。其实这段代码很简单，index数组就是arr数组的下标，index[0]=2 对应 arr[2]=1，index[1]=0 对应 arr[0]=8，index[2]=3 对应 arr[3]=0，以此类推…… 很容易得到电话号码是18013820100。 本题要求你编写一个程序，为任何一个电话号码生成这段代码 —— 事实上，只要生成最前面两行就可以了，后面内容是不变的。 输入格式：输入在一行中给出一个由11位数字组成的手机号码。 输出格式：为输入的号码生成代码的前两行，其中arr中的数字必须按递减顺序给出。 输入样例：18013820100 输出样例：int[] arr = new int[]{8,3,2,1,0};int[] index = new int[]{3,0,4,3,1,0,2,4,3,4,4}; 123456789101112131415161718192021222324252627282930313233import java.util.Scanner;import java.util.Vector;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String s = in.next(); int[] tel = new int[s.length()]; int[] a = new int[s.length()]; Vector&lt;Integer&gt; vector = new Vector(); for (int i = 0; i &lt; s.length(); i++) &#123; a[s.charAt(i) - '0']++; tel[i] = s.charAt(i) - '0'; &#125; for (int i = s.length() - 1; i &gt;= 0; i--) &#123; if (a[i] &gt; 0) &#123; vector.add(i); &#125; &#125; System.out.print("int[] arr = new int[]&#123;"); for (int i = 0; i &lt; vector.size() - 1; i++) &#123; System.out.print(vector.get(i)+","); &#125; System.out.println(vector.get(vector.size()-1)+"&#125;;"); System.out.print("int[] index = new int[]&#123;"); for (int i = 0; i &lt; s.length() - 1; i++) &#123; System.out.print(vector.indexOf(tel[i]) + ","); &#125; System.out.println(vector.indexOf(tel[s.length()-1])+ "&#125;;"); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-026. I Love GPLT]]></title>
    <url>%2F2018%2F03%2F24%2FL1-026.ILoveGPLT%2F</url>
    <content type="text"><![CDATA[L1-026. I Love GPLT这道超级简单的题目没有任何输入。 你只需要把这句很重要的话 —— “I Love GPLT”——竖着输出就可以了。 所谓“竖着输出”，是指每个字符占一行（包括空格），即每行只能有1个字符和回车。 12345678public class Main &#123; public static void main(String[] args) &#123; String s = "I Love GPLT"; for (int i = 0; i &lt; s.length(); i++) &#123; System.out.println(s.charAt(i)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-025. 正整数A+B]]></title>
    <url>%2F2018%2F03%2F24%2FL1-025.%E6%AD%A3%E6%95%B4%E6%95%B0A%2BB%2F</url>
    <content type="text"><![CDATA[L1-025. 正整数A+B本题的目标很简单，就是求两个正整数A和B的和，其中A和B都在区间[1,1000]。稍微有点麻烦的是，输入并不保证是两个正整数。 输入格式：输入在一行给出A和B，其间以空格分开。问题是A和B不一定是满足要求的正整数，有时候可能是超出范围的数字、负数、带小数点的实数、甚至是一堆乱码。 注意：我们把输入中出现的第1个空格认为是A和B的分隔。题目保证至少存在一个空格，并且B不是一个空字符串。 输出格式：如果输入的确是两个正整数，则按格式“A + B = 和”输出。如果某个输入不合要求，则在相应位置输出“?”，显然此时和也是“?”。 输入样例1：123 456 输出样例1：123 + 456 = 579 输入样例2： 18输出样例2：? + 18 = ?输入样例3：-100 blabla bla…33输出样例3：? + ? = ? 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String s1 = in.nextLine(); String A = s1.split(" ", 2)[0]; String B = s1.split(" ", 2)[1]; int flagA = 0; int flagB = 0; int a = 0; try &#123; a = Integer.valueOf(A); &#125; catch (Exception e) &#123; flagA = 1; &#125; int b = 0; try &#123; b = Integer.valueOf(B); &#125; catch (Exception e) &#123; flagB = 1; &#125; if (!(a &gt;= 1 &amp;&amp; a &lt;= 1000)) flagA = 1; if (!(b &gt;= 1 &amp;&amp; b &lt;= 1000)) flagB = 1; if (flagA == 0 &amp;&amp; flagB ==0) System.out.println(a + " + " + b + " = " + (a + b)); else if (flagA == 0 &amp;&amp; flagB != 0) &#123; System.out.println(a + " + ? = ?"); &#125; else if (flagA != 0 &amp;&amp; flagB == 0) &#123; System.out.println("? + " + b + " = ?"); &#125; else if (flagA != 0 &amp;&amp; flagB != 0) &#123; System.out.println("? + ? = ?"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-024. 后天]]></title>
    <url>%2F2018%2F03%2F24%2FL1-024.%E5%90%8E%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[L1-024. 后天如果今天是星期三，后天就是星期五；如果今天是星期六，后天就是星期一。我们用数字1到7对应星期一到星期日。给定某一天，请你输出那天的“后天”是星期几。 输入格式：输入第一行给出一个正整数D（1 &lt;= D &lt;=7），代表星期里的某一天。 输出格式：在一行中输出D天的后天是星期几。 输入样例：3 输出样例：5 1234567891011121314#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; if (n == 5) &#123; cout &lt;&lt; 7 &lt;&lt; endl; &#125; else cout &lt;&lt; (n + 2) % 7 &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-023. 输出GPLT]]></title>
    <url>%2F2018%2F03%2F24%2FL1-023.%E8%BE%93%E5%87%BAGPLT%2F</url>
    <content type="text"><![CDATA[L1-023. 输出GPLT给定一个长度不超过10000的、仅由英文字母构成的字符串。请将字符重新调整顺序，按“GPLTGPLT….”这样的顺序输出，并忽略其它字符。当然，四种字符（不区分大小写）的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按GPLT的顺序打印，直到所有字符都被输出。 输入格式：输入在一行中给出一个长度不超过10000的、仅由英文字母构成的非空字符串。 输出格式：在一行中按题目要求输出排序后的字符串。题目保证输出非空。 输入样例：pcTclnGloRgLrtLhgljkLhGFauPewSKgt 输出样例：GPLTGPLTGLTGLGLL 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int g = 0, p = 0, l = 0, t = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; if (toupper(s[i]) == 'G') &#123; g++; &#125; else if (toupper(s[i]) == 'P') &#123; p++; &#125; else if (toupper(s[i]) == 'L') &#123; l++; &#125; else if (toupper(s[i]) == 'T') &#123; t++; &#125; &#125; while (g + p + l + t &gt; 0) &#123; if (g &gt; 0) &#123; g--; cout &lt;&lt; "G"; &#125; if (p &gt; 0) &#123; p--; cout &lt;&lt; 'P'; &#125; if (l &gt; 0) &#123; l--; cout &lt;&lt; "L"; &#125; if (t &gt; 0) &#123; t--; cout &lt;&lt; "T"; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-022. 奇偶分家]]></title>
    <url>%2F2018%2F03%2F24%2FL1-022.%E5%A5%87%E5%81%B6%E5%88%86%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[L1-022. 奇偶分家给定N个正整数，请统计奇数和偶数各有多少个？ 输入格式：输入第一行给出一个正整N（&lt;= 1000）；第2行给出N个正整数，以空格分隔。 输出格式：在一行中先后输出奇数的个数、偶数的个数。中间以1个空格分隔。 输入样例：988 74 101 26 15 0 34 22 77 输出样例：3 6 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main() &#123; int n; int a; cin &gt;&gt; n; int countA = 0; int countB = 0; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; a; if (a % 2 == 0) &#123; countB++; &#125; else countA++; &#125; cout &lt;&lt; countA &lt;&lt; " " &lt;&lt; countB &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-021. 重要的话说三遍]]></title>
    <url>%2F2018%2F03%2F24%2FL1-021.%E9%87%8D%E8%A6%81%E7%9A%84%E8%AF%9D%E8%AF%B4%E4%B8%89%E9%81%8D%2F</url>
    <content type="text"><![CDATA[L1-021. 重要的话说三遍这道超级简单的题目没有任何输入。 你只需要把这句很重要的话 —— “I’m gonna WIN!”——连续输出三遍就可以了。 注意每遍占一行，除了每行的回车不能有任何多余字符。 123456789#include &lt;iostream&gt;using namespace std;int main() &#123; for (int i = 0; i &lt; 3; ++i) &#123; cout &lt;&lt; "I'm gonna WIN!" &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-020. 帅到没朋友]]></title>
    <url>%2F2018%2F03%2F24%2FL1-020.%E5%B8%85%E5%88%B0%E6%B2%A1%E6%9C%8B%E5%8F%8B%2F</url>
    <content type="text"><![CDATA[L1-020. 帅到没朋友当芸芸众生忙着在朋友圈中发照片的时候，总有一些人因为太帅而没有朋友。本题就要求你找出那些帅到没有朋友的人。 输入格式：输入第一行给出一个正整数N（&lt;=100），是已知朋友圈的个数；随后N行，每行首先给出一个正整数K（&lt;=1000），为朋友圈中的人数，然后列出一个朋友圈内的所有人——为方便起见，每人对应一个ID号，为5位数字（从00000到99999），ID间以空格分隔；之后给出一个正整数M（&lt;=10000），为待查询的人数；随后一行中列出M个待查询的ID，以空格分隔。 注意：没有朋友的人可以是根本没安装“朋友圈”，也可以是只有自己一个人在朋友圈的人。虽然有个别自恋狂会自己把自己反复加进朋友圈，但题目保证所有K超过1的朋友圈里都至少有2个不同的人。 输出格式：按输入的顺序输出那些帅到没朋友的人。ID间用1个空格分隔，行的首尾不得有多余空格。如果没有人太帅，则输出“No one is handsome”。 注意：同一个人可以被查询多次，但只输出一次。 输入样例1：33 11111 22222 555552 33333 444444 55555 66666 99999 77777855555 44444 10000 88888 22222 11111 23333 88888 输出样例1：10000 88888 23333 输入样例2：33 11111 22222 555552 33333 444444 55555 66666 99999 77777455555 44444 22222 11111 输出样例2：No one is handsome 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main() &#123; int a, b, c; cin &gt;&gt; a; set&lt;string&gt; s, ans; string str; for(int i = 0; i &lt; a; i++) &#123; cin &gt;&gt; b; if(b &gt;= 2) &#123; for(int j = 0; j &lt; b; j++) &#123; cin &gt;&gt; str; s.insert(str); &#125; &#125; else &#123; cin &gt;&gt; str; &#125; &#125; cin &gt;&gt; c; int flag = 0; for(int i = 0; i &lt; c; i++) &#123; cin &gt;&gt; str; if(s.find(str) == s.end() &amp;&amp; ans.find(str) == ans.end()) &#123; ans.insert(str); if(flag == 1) cout &lt;&lt; " "; cout &lt;&lt; str; flag = 1; &#125; &#125; if(flag == 0) cout &lt;&lt; "No one is handsome"; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-019. 谁先倒]]></title>
    <url>%2F2018%2F03%2F24%2FL1-019.%E8%B0%81%E5%85%88%E5%80%92%2F</url>
    <content type="text"><![CDATA[L1-019. 谁先倒划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就输了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。 下面给出甲、乙两人的酒量（最多能喝多少杯不倒）和划拳记录，请你判断两个人谁先倒。 输入格式：输入第一行先后给出甲、乙两人的酒量（不超过100的非负整数），以空格分隔。下一行给出一个正整数N（&lt;=100），随后N行，每行给出一轮划拳的记录，格式为： 甲喊 甲划 乙喊 乙划 其中“喊”是喊出的数字，“划”是划出的数字，均为不超过100的正整数（两只手一起划）。 输出格式：在第一行中输出先倒下的那个人：A代表甲，B代表乙。第二行中输出没倒的那个人喝了多少杯。题目保证有一个人倒下。注意程序处理到有人倒下就终止，后面的数据不必处理。 输入样例：1 168 10 9 125 10 5 103 8 5 1212 18 1 134 16 12 1515 1 1 16 输出样例：A1 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main() &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int arr[c][2], brr[c][2]; for (int i = 0; i &lt; c; ++i) &#123; cin &gt;&gt; arr[i][0] &gt;&gt; arr[i][1] &gt;&gt; brr[i][0] &gt;&gt; brr[i][1]; &#125; int countA = 0, countB = 0; for (int i = 0; i &lt; c; ++i) &#123; if ((arr[i][0] + brr[i][0]) == arr[i][1] &amp;&amp; (arr[i][0] + brr[i][0]) == brr[i][1]) &#123; continue; &#125; if ((arr[i][0] + brr[i][0]) == arr[i][1]) &#123; countA++; &#125; if ((arr[i][0] + brr[i][0]) == brr[i][1]) &#123; countB++; &#125; if (countA &gt; a) &#123; cout &lt;&lt; 'A' &lt;&lt; endl; cout &lt;&lt; countB &lt;&lt; endl; break; &#125; if (countB &gt; b) &#123; cout &lt;&lt; 'B' &lt;&lt; endl; cout &lt;&lt; countA &lt;&lt; endl; break; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-018. 大笨钟]]></title>
    <url>%2F2018%2F03%2F24%2FL1-018.%E5%A4%A7%E7%AC%A8%E9%92%9F%2F</url>
    <content type="text"><![CDATA[L1-018. 大笨钟微博上有个自称“大笨钟V”的家伙，每天敲钟催促码农们爱惜身体早点睡觉。不过由于笨钟自己作息也不是很规律，所以敲钟并不定时。一般敲钟的点数是根据敲钟时间而定的，如果正好在某个整点敲，那么“当”数就等于那个整点数；如果过了整点，就敲下一个整点数。另外，虽然一天有24小时，钟却是只在后半天敲1~12下。例如在23:00敲钟，就是“当当当当当当当当当当当”，而到了23:01就会是“当当当当当当当当当当当当”。在午夜00:00到中午12:00期间（端点时间包括在内），笨钟是不敲的。 下面就请你写个程序，根据当前时间替大笨钟敲钟。 输入格式：输入第一行按照“hh:mm”的格式给出当前时间。其中hh是小时，在00到23之间；mm是分钟，在00到59之间。 输出格式：根据当前时间替大笨钟敲钟，即在一行中输出相应数量个“Dang”。如果不是敲钟期，则输出： Only hh:mm. Too early to Dang.其中“hh:mm”是输入的时间。 输入样例1：19:05 输出样例1：DangDangDangDangDangDangDangDang 输入样例2：07:05 输出样例2：Only 07:05. Too early to Dang. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main() &#123; int a,b; scanf("%d:%d", &amp;a, &amp;b); if (a &gt;= 0 &amp;&amp; (a &lt; 12 || (a == 12 &amp;&amp; b == 0))) &#123; if (a &lt; 10) &#123; if (b &lt; 10) &#123; cout &lt;&lt; "Only 0" &lt;&lt; a &lt;&lt; ":0" &lt;&lt; b &lt;&lt; ". Too early to Dang." &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "Only 0" &lt;&lt; a &lt;&lt; ":" &lt;&lt; b &lt;&lt; ". Too early to Dang." &lt;&lt; endl; &#125; &#125; else &#123; if (b &lt; 10) &#123; cout &lt;&lt; "Only " &lt;&lt; a &lt;&lt; ":0" &lt;&lt; b &lt;&lt; ". Too early to Dang." &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "Only " &lt;&lt; a &lt;&lt; ":" &lt;&lt; b &lt;&lt; ". Too early to Dang." &lt;&lt; endl; &#125; &#125; &#125; else &#123; int c = a % 12; if (b == 0) &#123; for (int i = 0; i &lt; c; ++i) &#123; cout &lt;&lt; "Dang"; &#125; cout &lt;&lt; endl; &#125; else &#123; for (int i = 0; i &lt;= c; ++i) &#123; cout &lt;&lt; "Dang"; &#125; cout &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-017. 到底有多二]]></title>
    <url>%2F2018%2F03%2F24%2FL1-017.%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[L1-017. 到底有多二一个整数“犯二的程度”定义为该数字中包含2的个数与其位数的比值。如果这个数是负数，则程度增加0.5倍；如果还是个偶数，则再增加1倍。例如数字“-13142223336”是个11位数，其中有3个2，并且是负数，也是偶数，则它的犯二程度计算为：3/111.52*100%，约为81.82%。本题就请你计算一个给定整数到底有多二。 输入格式：输入第一行给出一个不超过50位的整数N。 输出格式：在一行中输出N犯二的程度，保留小数点后两位。 输入样例：-13142223336 输出样例：81.82% 12345678910111213141516171819202122232425262728import java.text.DecimalFormat;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String s = in.nextLine(); int r = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == '2') r++; &#125; double a = 1.0; int leng = s.length(); if (s.charAt(0) == '-') &#123; a = 1.5; leng = leng - 1; &#125; int b = 1; if ((s.charAt(s.length()-1) - '0') % 2 == 0) &#123; b = 2; &#125; DecimalFormat df = new DecimalFormat("0.00"); System.out.println(df.format(((double)r/leng)*a*b*100) + "%"); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-016. 查验身份证]]></title>
    <url>%2F2018%2F03%2F23%2FL1-016.%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81%2F</url>
    <content type="text"><![CDATA[L1-016. 查验身份证一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下： 首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值： Z：0 1 2 3 4 5 6 7 8 9 10M：1 0 X 9 8 7 6 5 4 3 2 现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。 输入格式：输入第一行给出正整数N（&lt;= 100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。 输出格式：按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出“All passed”。 输入样例1：432012419880824005612010X19890101123411010819671130186637070419881216001X 输出样例1：12010X19890101123411010819671130186637070419881216001X 输入样例2：2320124198808240056110108196711301862 输出样例2：All passed 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;int main() &#123; int arr[17] = &#123;7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2&#125;; int m[11] = &#123;1,0,10,9,8,7,6,5,4,3,2&#125;; int n; bool isvisted = true; cin &gt;&gt; n; string s[n]; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; s[i]; &#125; for (int i = 0; i &lt; n; ++i) &#123; int sum = 0; int j; for (j = 0; j &lt; 17; ++j) &#123; if (!isdigit(s[i][j])) &#123; cout &lt;&lt; s[i] &lt;&lt; endl; isvisted = false; break; &#125; else &#123; sum += (s[i][j] - '0') * arr[j]; &#125; &#125; if (j == 17) &#123; if (s[i][j] == 'X') &#123; if (m[sum%11] != 10) &#123; cout &lt;&lt; s[i] &lt;&lt; endl; isvisted = false; &#125; &#125; else &#123; if (m[sum%11] != s[i][j] - '0') &#123; cout &lt;&lt; s[i] &lt;&lt; endl; isvisted = false; &#125; &#125; &#125; &#125; if (isvisted) &#123; cout &lt;&lt; "All passed" &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-015. 跟奥巴马一起画方块]]></title>
    <url>%2F2018%2F03%2F23%2FL1-015.%E8%B7%9F%E5%A5%A5%E5%B7%B4%E9%A9%AC%E4%B8%80%E8%B5%B7%E7%94%BB%E6%96%B9%E5%9D%97%2F</url>
    <content type="text"><![CDATA[L1-015. 跟奥巴马一起画方块美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！ 输入格式：输入在一行中给出正方形边长N（3&lt;=N&lt;=21）和组成正方形边的某种字符C，间隔一个空格。 输出格式：输出由给定字符C画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的50%（四舍五入取整）。 输入样例：10 a 输出样例：aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main() &#123; int n; char c; cin &gt;&gt; n &gt;&gt; c; for (int i = 0; i &lt; (n + 1)/ 2; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; cout &lt;&lt; c; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-014. 简单题]]></title>
    <url>%2F2018%2F03%2F23%2FL1-014.%E7%AE%80%E5%8D%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这次真的没骗你 —— 这道超级简单的题目没有任何输入。 你只需要在一行中输出事实：“This is a simple problem.”就可以了。 123456789#include &lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; "This is a simple problem."; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-013. 计算阶乘和]]></title>
    <url>%2F2018%2F03%2F23%2FL1-013.%E8%AE%A1%E7%AE%97%E9%98%B6%E4%B9%98%E5%92%8C%2F</url>
    <content type="text"><![CDATA[L1-013. 计算阶乘和对于给定的正整数N，需要你计算 S = 1! + 2! + 3! + … + N!。 输入格式：输入在一行中给出一个不超过10的正整数N。 输出格式：在一行中输出S的值。 输入样例：3 输出样例：9 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; int tmp = 1; for (int j = i; j &gt; 0; --j) &#123; tmp = tmp * j; &#125; sum += tmp; &#125; cout &lt;&lt; sum; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-012. 计算指数]]></title>
    <url>%2F2018%2F03%2F23%2FL1-012.%E8%AE%A1%E7%AE%97%E6%8C%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[L1-012. 计算指数真的没骗你，这道才是简单题 —— 对任意给定的不超过10的正整数n，要求你输出2n。不难吧？ 输入格式：输入在一行中给出一个不超过10的正整数n。 输出格式：在一行中按照格式“2^n = 计算结果”输出2n的值。 输入样例：5 输出样例：2^5 = 32 12345678910111213#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; 2 &lt;&lt; "^" &lt;&lt; n &lt;&lt; " = " &lt;&lt; pow(2,n); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-011. A-B]]></title>
    <url>%2F2018%2F03%2F23%2FL1-011.A-B%2F</url>
    <content type="text"><![CDATA[L1-011. A-B本题要求你计算A-B。不过麻烦的是，A和B都是字符串 —— 即从字符串A中把字符串B所包含的字符全删掉，剩下的字符组成的就是字符串A-B。 输入格式：输入在2行中先后给出字符串A和B。两字符串的长度都不超过104，并且保证每个字符串都是由可见的ASCII码和空白字符组成，最后以换行符结束。 输出格式：在一行中打印出A-B的结果字符串。 输入样例：I love GPLT! It’s a fun game!aeiou 输出样例：I lv GPLT! It’s fn gm! 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int main() &#123; string s, a; getline(cin, s); getline(cin, a); bool isflag[256]; for (int i = 0; i &lt; 256; ++i) &#123; isflag[i] = false; &#125; for (int i = 0; i &lt; a.length(); ++i) &#123; isflag[a[i]] = true; &#125; for (int i = 0; i &lt; s.length(); ++i) &#123; if (!isflag[s[i]]) &#123; cout &lt;&lt; s[i]; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-010. 比较大小]]></title>
    <url>%2F2018%2F03%2F23%2FL1-010.%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[L1-010. 比较大小本题要求将输入的任意3个整数从小到大输出。 输入格式：输入在一行中给出3个整数，其间以空格分隔。 输出格式：在一行中将3个整数从小到大输出，其间以“-&gt;”相连。 输入样例：4 2 8 输出样例：2-&gt;4-&gt;8 1234567891011121314#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int arr[3]; cin &gt;&gt; arr[0] &gt;&gt; arr[1] &gt;&gt; arr[2]; sort(arr, arr+3); for (int i = 0; i &lt; 2; ++i) &#123; cout &lt;&lt; arr[i] &lt;&lt; "-&gt;"; &#125; cout &lt;&lt; arr[2]; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-009. N个数求和]]></title>
    <url>%2F2018%2F03%2F23%2FL1-009.N%E4%B8%AA%E6%95%B0%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[L1-009. N个数求和本题的要求很简单，就是求N个数字的和。麻烦的是，这些数字是以有理数“分子/分母”的形式给出的，你输出的和也必须是有理数的形式。 输入格式：输入第一行给出一个正整数N（&lt;=100）。随后一行按格式“a1/b1 a2/b2 …”给出N个有理数。题目保证所有分子和分母都在长整型范围内。另外，负数的符号一定出现在分子前面。 输出格式：输出上述数字和的最简形式 —— 即将结果写成“整数部分 分数部分”，其中分数部分写成“分子/分母”，要求分子小于分母，且它们没有公因子。如果结果的整数部分为0，则只输出分数部分。 输入样例1：52/5 4/15 1/30 -2/60 8/3 输出样例1：3 1/3 输入样例2：24/3 2/3 输出样例2：2 输入样例3：31/3 -1/6 1/8 输出样例3：7/24 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int gcd(int a,int b)&#123; //辗转相除法 if(a%b==0) return b; else return gcd(b,a%b);&#125;int lcm(int a,int b)&#123; return a*b/gcd(a,b); //最小公倍数乘最大公约数等于它们的乘积&#125;int main() &#123; int n; cin &gt;&gt; n; long long int fz[n]; long long int fm[n]; for (int i = 0; i &lt; n; ++i) &#123; scanf("%lld/%lld",&amp;fz[i], &amp;fm[i]); &#125; for (int i = 0; i &lt; n; ++i) &#123; long long int tmp = gcd(fz[i], fm[i]); fz[i] = fz[i] / tmp; fm[i] = fm[i] / tmp; &#125; long int gd = 1; for (int i = 0; i &lt; n; ++i) &#123; gd = lcm(gd, fm[i]); &#125; for (int i = 0; i &lt; n; ++i) &#123; fz[i] = fz[i] * (gd / fm[i]); &#125; long long int sum = 0; for (int i = 0; i &lt; n; ++i) &#123; sum += fz[i]; &#125; long long int res1 = sum / gd; long long int res2 = sum % gd; long long int res3 = gcd(res2, gd); long long int fz0 = res2 / res3; long long int fm0 = gd / res3; if (res1 == 0) &#123; if (fz0 == 0) &#123; cout &lt;&lt; 0; &#125; else &#123; if (fm0 &lt; 0) &#123; fm0 = -fm0; fz0 = -fz0; &#125; cout &lt;&lt; fz0 &lt;&lt; "/" &lt;&lt; fm0; &#125; &#125; else if (fz0 == 0) &#123; cout &lt;&lt; res1; &#125; else &#123; if (fm0 &lt; 0) &#123; fz0 = -fz0; fm0 = -fm0; &#125; cout &lt;&lt; res1 &lt;&lt; " " &lt;&lt; fz0 &lt;&lt; "/" &lt;&lt; fm0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-008. 求整数段和]]></title>
    <url>%2F2018%2F03%2F23%2FL1-008.%E6%B1%82%E6%95%B4%E6%95%B0%E6%AE%B5%E5%92%8C%2F</url>
    <content type="text"><![CDATA[L1-008. 求整数段和给定两个整数A和B，输出从A到B的所有整数以及这些数的和。 输入格式：输入在一行中给出2个整数A和B，其中-100&lt;=A&lt;=B&lt;=100，其间以空格分隔。 输出格式：首先顺序输出从A到B的所有整数，每5个数字占一行，每个数字占5个字符宽度，向右对齐。最后在一行中输出全部数字的和。 输入样例：-3 8 输出样例： -3 -2 -1 0 1 2 3 4 5 6 7 8Sum = 30 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int main() &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; int sum = 0; int count = 0; while (a &lt;= b) &#123; for (int i = 0; i &lt; 5 &amp;&amp; a &lt;= b; ++i, ++a) &#123; printf("%5d", a); sum += a; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; "Sum = " &lt;&lt; sum; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-007. 念数字]]></title>
    <url>%2F2018%2F03%2F23%2FL1-007.%E5%BF%B5%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[L1-007. 念数字输入一个整数，输出每个数字对应的拼音。当整数为负数时，先输出“fu”字。十个数字对应的拼音如下： 0: ling1: yi2: er3: san4: si5: wu6: liu7: qi8: ba9: jiu 输入格式：输入在一行中给出一个整数，如： 1234 。 提示：整数包括负数、零和正数。输出格式：在一行中输出这个整数对应的拼音，每个数字的拼音之间用空格分开，行末没有最后的空格。如 yi er san si。 输入样例：-600 输出样例：fu liu ling ling 123456789101112131415161718import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); String s = scan.nextLine(); String[] strings = &#123;"ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu"&#125;; for (int i = 0; i &lt; s.length() - 1; i++) &#123; if (s.charAt(i) == '-') &#123; System.out.print("fu "); &#125; else &#123; System.out.print(strings[s.charAt(i) - '0'] + " "); &#125; &#125; System.out.println(strings[s.charAt(s.length() - 1) - '0']); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-006. 连续因子]]></title>
    <url>%2F2018%2F03%2F23%2FL1-006.%E8%BF%9E%E7%BB%AD%E5%9B%A0%E5%AD%90%2F</url>
    <content type="text"><![CDATA[L1-006. 连续因子一个正整数N的因子中可能存在若干连续的数字。例如630可以分解为3 * 5 * 6 * 7，其中5、6、7就是3个连续的数字。给定任一正整数N，要求编写程序求出最长连续因子的个数，并输出最小的连续因子序列。 输入格式：输入在一行中给出一个正整数N（1&lt;N&lt;2^31）。 输出格式：首先在第1行输出最长连续因子的个数；然后在第2行中按“因子1* 因子2 * ……* 因子k”的格式输出最小的连续因子序列，其中因子按递增顺序输出，1不算在内。 输入样例：630 输出样例：1235*6*7 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; unsigned n; cin &gt;&gt; n; int max = sqrt(n); for (int len = 12; len &gt;= 1; len--) &#123; for (int start = 2; start &lt;= max; ++start) &#123; long long int ans = 1; for (int i = start; i - start &lt;= len - 1; ++i) &#123; ans *= i; &#125; if (n % ans == 0) &#123; cout &lt;&lt; len &lt;&lt; endl &lt;&lt; start; for (int i = start + 1; i - start &lt;= len - 1; ++i) &#123; cout &lt;&lt; "*" &lt;&lt; i; &#125; return 0; &#125; &#125; &#125; cout &lt;&lt; 1 &lt;&lt; endl &lt;&lt; n; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-005. 考试座位号]]></title>
    <url>%2F2018%2F03%2F23%2FL1-005.%E8%80%83%E8%AF%95%E5%BA%A7%E4%BD%8D%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[L1-005. 考试座位号每个PAT考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。 输入格式：输入第一行给出一个正整数N（&lt;=1000），随后N行，每行给出一个考生的信息：“准考证号 试机座位号 考试座位号”。其中准考证号由14位数字组成，座位从1到N编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。 考生信息之后，给出一个正整数M（&lt;=N），随后一行中给出M个待查询的试机座位号码，以空格分隔。 输出格式：对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用1个空格分隔。 输入样例：410120150912233 2 410120150912119 4 110120150912126 1 310120150912002 3 223 4 输出样例：10120150912002 210120150912119 1 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; string strs[n + 1]; int index[n + 1]; string s; int a; int b; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; s &gt;&gt; a &gt;&gt; b; strs[a] = s; index[a] = b; &#125; int x; cin &gt;&gt; x; int v[x]; for (int k = 0; k &lt; x; ++k) &#123; cin &gt;&gt; v[k]; &#125; for (int j = 0; j &lt; x; ++j) &#123; a = v[j]; cout &lt;&lt; strs[a] &lt;&lt; " " &lt;&lt; index[a] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-004. 计算摄氏温度]]></title>
    <url>%2F2018%2F03%2F23%2FL1-004.%E8%AE%A1%E7%AE%97%E6%91%84%E6%B0%8F%E6%B8%A9%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[L1-004. 计算摄氏温度给定一个华氏温度F，本题要求编写程序，计算对应的摄氏温度C。计算公式：C = 5*(F-32)/9。题目保证输入与输出均在整型范围内。 输入格式：输入在一行中给出一个华氏温度。 输出格式：在一行中按照格式“Celsius = C”输出对应的摄氏温度C的整数值。 输入样例：150 输出样例：Celsius = 65 12345678910111213import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); String s = scan.nextLine(); int f = Integer.valueOf(s); int c = 5 * (f - 32) / 9; System.out.println("Celsius = " + c); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-003. 个位数统计]]></title>
    <url>%2F2018%2F03%2F23%2FL1-003._%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[L1-003. 个位数统计给定一个k位整数N = dk-110k-1 + … + d1101 + d0 (0&lt;=di&lt;=9, i=0,…,k-1, dk-1&gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定N = 100311，则有2个0，3个1，和1个3。 输入格式：每个输入包含1个测试用例，即一个不超过1000位的正整数N。 输出格式：对N中每一种不同的个位数字，以D:M的格式在一行中输出该位数字D及其在N中出现的次数M。要求按D的升序输出。 输入样例：100311 输出样例：0:21:33:1 12345678910111213141516171819import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); String s = scan.nextLine(); int[] index = new int[10]; for (int i = 0; i &lt; s.length(); i++) &#123; index[s.charAt(i) - '0']++; &#125; for (int i = 0; i &lt; 10; i++) &#123; if (index[i] != 0) System.out.println(i + ":" + index[i]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-002. 打印沙漏]]></title>
    <url>%2F2018%2F03%2F23%2FL1-002._%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[L1-002. 打印沙漏本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个 “*”，要求按下列格式打印 12345***** *** * ******** 所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。 给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。 输入格式：输入在一行给出1个正整数N（&lt;=1000）和一个符号，中间以空格分隔。 输出格式：首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。 输入样例：19 * 输出样例：123456***** *** * ********2 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); String s = scan.next(); int row = 0; for (int i = 1; i &lt; n; i++) &#123; if ((2*i*(i + 2) + 1) &lt;= n) &#123; row++; &#125; &#125; for (int i = row; i &gt; 0; i--) &#123; for (int j = row - i; j &gt; 0; j--) System.out.print(" "); for (int j = 2 * i + 1; j &gt; 0; j--) &#123; System.out.print(s); &#125; System.out.println(); &#125; if (n != 0) &#123; for (int i = 0; i &lt; row; i++) &#123; System.out.print(" "); &#125; System.out.println(s); &#125; for (int i = 1; i &lt;= row; i++) &#123; for (int j = row - i; j &gt; 0; j--) System.out.print(" "); for (int j = 2 * i + 1; j &gt; 0; j--) &#123; System.out.print(s); &#125; System.out.println(); &#125; System.out.println(n - (2 * row * (row + 2) + 1)); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队程序设计天梯赛 L1-001. Hello World]]></title>
    <url>%2F2018%2F03%2F23%2FL1-001.Hello_World%2F</url>
    <content type="text"><![CDATA[L1-001. Hello World这道超级简单的题目没有任何输入。你只需要在一行中输出著名短句“Hello World!”就可以了。 123456public class Main &#123; public static void main(String[] args) &#123; System.out.println("Hello World!"); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 201709-2 公共钥匙盒]]></title>
    <url>%2F2018%2F03%2F22%2FCCF_201709-2_%E5%85%AC%E5%85%B1%E9%92%A5%E5%8C%99%E7%9B%92%2F</url>
    <content type="text"><![CDATA[问题描述 有一个学校的老师共用N个教室，按照规定，所有的钥匙都必须放在公共钥匙盒里，老师不能带钥匙回家。每次老师上课前，都从公共钥匙盒里找到自己上课的教室的钥匙去开门，上完课后，再将钥匙放回到钥匙盒中。 钥匙盒一共有N个挂钩，从左到右排成一排，用来挂N个教室的钥匙。一串钥匙没有固定的悬挂位置，但钥匙上有标识，所以老师们不会弄混钥匙。 每次取钥匙的时候，老师们都会找到自己所需要的钥匙将其取走，而不会移动其他钥匙。每次还钥匙的时候，还钥匙的老师会找到最左边的空的挂钩，将钥匙挂在这个挂钩上。如果有多位老师还钥匙，则他们按钥匙编号从小到大的顺序还。如果同一时刻既有老师还钥匙又有老师取钥匙，则老师们会先将钥匙全还回去再取出。 今天开始的时候钥匙是按编号从小到大的顺序放在钥匙盒里的。有K位老师要上课，给出每位老师所需要的钥匙、开始上课的时间和上课的时长，假设下课时间就是还钥匙时间，请问最终钥匙盒里面钥匙的顺序是怎样的？输入格式 输入的第一行包含两个整数N, K。 接下来K行，每行三个整数w, s, c，分别表示一位老师要使用的钥匙编号、开始上课的时间和上课的时长。可能有多位老师使用同一把钥匙，但是老师使用钥匙的时间不会重叠。 保证输入数据满足输入格式，你不用检查数据合法性。输出格式 输出一行，包含N个整数，相邻整数间用一个空格分隔，依次表示每个挂钩上挂的钥匙编号。样例输入5 24 3 32 2 7样例输出1 4 3 2 5样例说明 第一位老师从时刻3开始使用4号教室的钥匙，使用3单位时间，所以在时刻6还钥匙。第二位老师从时刻2开始使用钥匙，使用7单位时间，所以在时刻9还钥匙。 每个关键时刻后的钥匙状态如下（X表示空）： 时刻2后为1X345； 时刻3后为1X3X5； 时刻6后为143X5； 时刻9后为14325。样例输入5 71 1 143 3 121 15 122 7 203 18 124 21 195 30 9样例输出1 2 3 5 4评测用例规模与约定 对于30%的评测用例，1 ≤ N, K ≤ 10, 1 ≤ w ≤ N, 1 ≤ s, c ≤ 30； 对于60%的评测用例，1 ≤ N, K ≤ 50，1 ≤ w ≤ N，1 ≤ s ≤ 300，1 ≤ c ≤ 50； 对于所有评测用例，1 ≤ N, K ≤ 1000，1 ≤ w ≤ N，1 ≤ s ≤ 10000，1 ≤ c ≤ 100。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import java.util.Scanner;import java.util.ArrayList;import java.util.Collections;public class Main &#123; private static class Node implements Comparable&lt;Node&gt;&#123; private int key; private int time; private int isget; Node(int k, int t, int f) &#123; key = k; time = t; isget = f; &#125; @Override public int compareTo(Main.Node o) &#123; if (time &gt; o.time) return 1; else if (time == o.time) &#123; if (isget &gt; o.isget) &#123; return 1; &#125; else if (isget == o.isget) &#123; if (key &gt; o.key) &#123; return 1; &#125; else if (key == o.key) &#123; return 0; &#125; else return -1; &#125; else return -1; &#125; return -1; &#125; @Override public String toString() &#123; return "Node&#123;" + "key= " + key + ", time= " + time + ", isget= " + isget + '&#125;'; &#125; &#125; public static void main(String[] args) &#123; Scanner In = new Scanner(System.in); int N = In.nextInt(); int K = In.nextInt(); ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); int[] map = new int[N+1]; for (int i = 0; i &lt;= N; i++) &#123; map[i] = i; &#125; int w, s, c; while (K -- &gt; 0) &#123; w = In.nextInt(); s = In.nextInt(); c = In.nextInt(); nodes.add(new Node(w, s,1)); nodes.add(new Node(w, s + c,0)); &#125; Collections.sort(nodes);// for (int i = 0; i &lt; nodes.size(); i++) &#123;// System.out.println(nodes.get(i).toString());// &#125; for (Node node :nodes) &#123; int isget = node.isget; if (isget == 1) &#123; for (int i = 1; i &lt;= N; i++) &#123; if (node.key == map[i]) &#123; map[i] = 0; break; &#125; &#125; &#125; else &#123; for (int i = 1; i &lt;= N; i++) &#123; if (map[i] == 0) &#123; map[i] = node.key; break; &#125; &#125; &#125; &#125; boolean flag = true; for (int i = 1; i &lt;= N; i++) &#123; if (flag) &#123; System.out.print(map[i]); flag = false; &#125; else &#123; System.out.print(" "+map[i]); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>CCF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 201703-4 地铁修建]]></title>
    <url>%2F2018%2F03%2F22%2FCCF_201703-4_%E5%9C%B0%E9%93%81%E4%BF%AE%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[问题描述 A市有n个交通枢纽，其中1号和n号非常重要，为了加强运输能力，A市决定在1号到n号枢纽间修建一条地铁。 地铁由很多段隧道组成，每段隧道连接两个交通枢纽。经过勘探，有m段隧道作为候选，两个交通枢纽之间最多只有一条候选的隧道，没有隧道两端连接着同一个交通枢纽。 现在有n家隧道施工的公司，每段候选的隧道只能由一个公司施工，每家公司施工需要的天数一致。而每家公司最多只能修建一条候选隧道。所有公司同时开始施工。 作为项目负责人，你获得了候选隧道的信息，现在你可以按自己的想法选择一部分隧道进行施工，请问修建整条地铁最少需要多少天。输入格式 输入的第一行包含两个整数n, m，用一个空格分隔，分别表示交通枢纽的数量和候选隧道的数量。 第2行到第m+1行，每行包含三个整数a, b, c，表示枢纽a和枢纽b之间可以修建一条隧道，需要的时间为c天。输出格式 输出一个整数，修建整条地铁线路最少需要的天数。样例输入6 61 2 42 3 43 6 71 4 24 5 55 6 6样例输出6样例说明 可以修建的线路有两种。 第一种经过的枢纽依次为1, 2, 3, 6，所需要的时间分别是4, 4, 7，则整条地铁线需要7天修完； 第二种经过的枢纽依次为1, 4, 5, 6，所需要的时间分别是2, 5, 6，则整条地铁线需要6天修完。 第二种方案所用的天数更少。评测用例规模与约定 对于20%的评测用例，1 ≤ n ≤ 10，1 ≤ m ≤ 20； 对于40%的评测用例，1 ≤ n ≤ 100，1 ≤ m ≤ 1000； 对于60%的评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 10000，1 ≤ c ≤ 1000； 对于80%的评测用例，1 ≤ n ≤ 10000，1 ≤ m ≤ 100000； 对于100%的评测用例，1 ≤ n ≤ 100000，1 ≤ m ≤ 200000，1 ≤ a, b ≤ n，1 ≤ c ≤ 1000000。 所有评测用例保证在所有候选隧道都修通时1号枢纽可以通过隧道到达其他所有枢纽。 这里采用的是 Kruskal 最小生成树和并查集算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.Scanner;import java.util.ArrayList;import java.util.Collections;public class Main &#123; private int[] flag; private int unionFind(int e) &#123; while (flag[e] != e) &#123; e = flag[e]; &#125; return e; &#125; private static class Rode implements Comparable&lt;Rode&gt;&#123; private int a; private int b; private int w; public Rode(int a, int b, int w) &#123; this.a = a; this.b = b; this.w = w; &#125; @Override public int compareTo(Main.Rode o) &#123; if (this.w &lt; o.w) return -1; else if (this.w &gt; o.w) return 1; else return 0; &#125; &#125; public static void main(String[] args) &#123; Scanner In = new Scanner(System.in); int N = In.nextInt(); int m = In.nextInt(); int ans = 0; Main memb = new Main(); memb.flag = new int[N + 10]; ArrayList&lt;Rode&gt; roads = new ArrayList&lt;&gt;(200010); for (int i = 0; i &lt;= N; i++) &#123; memb.flag[i] = i; &#125; for (int i = 0; i &lt; m; i++) &#123; int a = In.nextInt(); int b = In.nextInt(); int w = In.nextInt(); roads.add(new Rode(a, b, w)); &#125; Collections.sort(roads); for (int i = 0; i &lt; m; i++) &#123; int x = memb.unionFind(roads.get(i).a); int y = memb.unionFind(roads.get(i).b); if (x != y) &#123; if (x &gt; y) memb.flag[x] = y; else memb.flag[y] = x; &#125; ans = roads.get(i).w; if (memb.unionFind(N) == 1) break; &#125; System.out.println(ans); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>CCF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 201709-4 通信网络]]></title>
    <url>%2F2018%2F03%2F22%2FCCF_201709-4_%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[问题描述 某国的军队由N个部门组成，为了提高安全性，部门之间建立了M条通路，每条通路只能单向传递信息，即一条从部门a到部门b的通路只能由a向b传递信息。信息可以通过中转的方式进行传递，即如果a能将信息传递到b，b又能将信息传递到c，则a能将信息传递到c。一条信息可能通过多次中转最终到达目的地。 由于保密工作做得很好，并不是所有部门之间都互相知道彼此的存在。只有当两个部门之间可以直接或间接传递信息时，他们才彼此知道对方的存在。部门之间不会把自己知道哪些部门告诉其他部门。 上图中给了一个4个部门的例子，图中的单向边表示通路。部门1可以将消息发送给所有部门，部门4可以接收所有部门的消息，所以部门1和部门4知道所有其他部门的存在。部门2和部门3之间没有任何方式可以发送消息，所以部门2和部门3互相不知道彼此的存在。 现在请问，有多少个部门知道所有N个部门的存在。或者说，有多少个部门所知道的部门数量（包括自己）正好是N。输入格式 输入的第一行包含两个整数N, M，分别表示部门的数量和单向通路的数量。所有部门从1到N标号。 接下来M行，每行两个整数a, b，表示部门a到部门b有一条单向通路。输出格式 输出一行，包含一个整数，表示答案。样例输入4 41 21 32 43 4样例输出2样例说明 部门1和部门4知道所有其他部门的存在。评测用例规模与约定 对于30%的评测用例，1 ≤ N ≤ 10，1 ≤ M ≤ 20； 对于60%的评测用例，1 ≤ N ≤ 100，1 ≤ M ≤ 1000； 对于100%的评测用例，1 ≤ N ≤ 1000，1 ≤ M ≤ 10000。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.Arrays;import java.util.Scanner;import java.util.ArrayList;public class Main &#123; private static int N; private static ArrayList&lt;Integer&gt;[] line; private static int[][] knows; private static int[] visited; private static int top; private static void dfs(int cur) &#123; knows[top][cur] = knows[cur][top] = visited[cur] = 1; for (int i = 0; i &lt; line[cur].size(); i++) &#123; if (visited[line[cur].get(i)] == 0) &#123; dfs(line[cur].get(i)); &#125; &#125; &#125; public static void main(String[] args) &#123; Scanner In = new Scanner(System.in); N = In.nextInt(); int M = In.nextInt(); int ans = 0; line = new ArrayList[N + 1]; knows = new int[N + 1][N + 1]; visited = new int[N + 1]; for (int i = 0; i &lt; line.length; i++) &#123; line[i] = new ArrayList&lt;Integer&gt;(); &#125; while (M-- &gt; 0) &#123; int l = In.nextInt(); Integer r = In.nextInt(); line[l].add(r); &#125; for (int i = 1; i &lt;= N; i++) &#123; Arrays.fill(visited, 0); top = i; dfs(i); &#125; for (int i = 1; i &lt;= N; i++) &#123; int j = 1; for (; j &lt;= N; j++) &#123; if (knows[i][j] == 0) &#123; break; &#125; &#125; if (j == N + 1) &#123; ans ++; &#125; &#125; System.out.println(ans); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>CCF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 201709-5 除法 Java]]></title>
    <url>%2F2018%2F03%2F22%2FCCF_201709-5_%E9%99%A4%E6%B3%95%2F</url>
    <content type="text"><![CDATA[问题描述 小葱喜欢除法，所以他给了你N个数a1, a2, ⋯, aN，并且希望你执行M次操作，每次操作可能有以下两种： 给你三个数l, r, v，你需要将al, al+1, ⋯, ar之间所有v的倍数除以v。 给你两个数l, r，你需要回答al + al+1 + ⋯ + ar的值是多少。输入格式 第一行两个整数N, M，代表数的个数和操作的次数。 接下来一行N个整数，代表N个数一开始的值。 接下来M行，每行代表依次操作。每行开始有一个整数opt。如果opt=1，那么接下来有三个数l, r, v，代表这次操作需要将第l个数到第r个数中v的倍数除以v；如果opt = 2，那么接下来有两个数l, r，代表你需要回答第l个数到第r个数的和。输出格式 对于每一次的第二种操作，输出一行代表这次操作所询问的值。 样例输入5 31 2 3 4 52 1 51 1 3 22 1 5 样例输出1514评测用例规模与约定 对于30%的评测用例，1 ≤ N, M ≤ 1000； 对于另外20%的评测用例，第一种操作中一定有l = r； 对于另外20%的评测用例，第一种操作中一定有l = 1 , r = N； 对于100%的评测用例，1 ≤ N, M ≤ 105，0 ≤ a1, a2, ⋯, aN ≤ 106, 1 ≤ v ≤ 106, 1 ≤ l ≤ r ≤ N。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.util.Scanner;public class Main &#123; private static int[] arr = new int[100010]; private static long[] tarr = new long[100010]; private static int N; private static int lowbit(int i) &#123; return i &amp; (-i); &#125; private static void toValue(int i, int num) &#123; while (i &lt;= N) &#123; tarr[i] += num; i += lowbit(i); &#125; &#125; private static long sum(int i) &#123; long total = 0; while(i != 0) &#123; total += tarr[i]; i -= lowbit(i); &#125; return total; &#125; private static void fun1(int l, int r, int v) &#123; if (v == 1) return; for (int i = l; i &lt;= r; i++) &#123; if (arr[i] &gt;= v &amp;&amp; arr[i] % v == 0) &#123; toValue(i, arr[i] / v - arr[i]); arr[i] /= v; &#125; &#125; &#125; private static void fun2(int l, int r) &#123; System.out.println(sum(r) - sum(l-1)); &#125; public static void main(String[] args) &#123; Scanner In = new Scanner(System.in); N = In.nextInt(); int M = In.nextInt(); arr = new int[N + 1]; tarr = new long[N + 1]; for (int i = 1; i &lt;= N; i++) &#123; arr[i] = In.nextInt(); toValue(i, arr[i]); &#125; while (M-- &gt; 0) &#123; int opt = In.nextInt(); if (opt == 1) &#123; int a = In.nextInt(); int b = In.nextInt(); int c = In.nextInt(); fun1(a, b, c); &#125; else if (opt == 2) &#123; int l = In.nextInt(); int r = In.nextInt(); fun2(l, r); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>CCF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统知识点整理]]></title>
    <url>%2F2018%2F03%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[数据库系统概论1.1 数据库系统概述 数据：描述事物的符号记录称为数据。 数据库：存放数据的仓库。数据库是长期储存在计算机内，有组织的，可共享的大量数据的集合。 数据库管理系统：是位于用户与操作系统之间的的一层数据管理软件。主要功能有：数据定义功能；数据组织，存储和管理；数据操纵功能；数据库的事务管理和运行管理；数据库的建立和维护功能；其他功能。 数据库系统：是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator）组成的存储、管理、处理和维护数据的系统。 数据库管理技术经历了三个阶段：人工管理、文件系统、数据库系统。 人工管理阶段 数据不保存 应用程序管理数据 数据不共享 数据不具有独立性 文件系统阶段 数据可以长期保存 由文件系统管理数据 数据共享性差，冗余度大 数据独立性差 数据库系统阶段 数据结构化。数据库系统实现整体数据的结构化，这是数据库的主要特征之一，也是数据库系统与文件系统的本质区别 数据的共享性高、冗余度低且抑郁扩充。数据共享可以大大减少数据冗余，节约存储空间，数据共享还能避免数据之间的不相容性与不一致性 数据独立性高。数据独立性包括物理独立性、逻辑独立性。物理独立性是指用户的应用程序与数据库中的物理存储是相互独立的。逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。 数据由数据库管理系统统一管理和控制。数据库管理系统还必须提供以下几个方面的数据控制功能： 数据的安全性保护：是指保护数据以防止不合法使用造成的数据泄密和破坏。 数据的完整性检查：是指数据的正确性】有效性和相容性。 并发控制 数据库恢复 1.2 数据模型 数据模型是对现实世界数据特征的抽象，也就是说数据模型是用来描述数据、组织数据和对数据进行操作的；数据模型是数据库系统的核心和基础。 数据模型应满足三方面的要求：一是比较真实的模拟现实世界，二是容易为人所理解，三是便于在计算机上实现。 根据模型应用的不同目的，可以将这些模型分为两大类：第一类是概念模型，第二类是逻辑模型和物理模型。 第一类概念模型，也称信息模型，它是按用户的观点来对数据和信息建模，主要用于数据库设计。 第二类的逻辑模型主要包括层次模型、网状模型、关系模型、面向对象数据模型和对象关系数据模型、半结构化数据模型等。它是按计算机系统的观点对数据建模，主要用于数据库管理系统的实现。 第二类中的物理模型是对数据最底层的抽象，它描述数据在系统内部的表示方式和存取方法，是面向计算机系统的。 实体：客观存在并可相互区别的事物称为实体 属性：实体具有的某一特征称为属性 码：唯一标识实体的属性集称为码 实体型：具有相同属性的实体必然具有共同的特征和性质，用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。 实体集：同一类型实体的集合称为实体集。 联系：实体内部以及实体之间是有联系的。实体内部的联系通常是指组成实体的个属性之间的联系，实体之间的联系通常是指不同实体集之间的联系。 实体之间的联系有一对一、一对多和多对多等多种联系。 概念模型的一种表示方法：实体-联系方法（Entity-Relationship approach）。该方法用 E - R 图（E - R diagram）来描述现实世界的概念模型，E - R 方法也称为 E - R 模型。 数据模型通常由数据结构、数据操作和数据的完整性约束条件三部分组成。 数据结构：数据结构描述数据库组成对象以及对象之间的联系。 数据操作：数据操作是指数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。数据库主要有查询和更新（包括插入、删除和修改）两大类操作。 数据的完整性约束条件：数据的完整性约束条件是一组完整性规则。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确，有效和相容。 数据库领域中主要的逻辑数据模型有： 层次模型 网状模型 关系模型 面向对象数据模型 对象关系数据模型 半结构化数据模型 其中层次模型和网状模型统称为格式化模型 层次模型的数据结构： 有且只有一个节点没有双亲结点，这个结点称为根节点 根以外的其他结点有且只有一个双亲结点 层次模型像一棵倒立的树，节点的双亲是唯一的 网状模型的数据结构： 允许一个以上的结点无双亲 一个结点可以有多于一个的双亲 关系模型数据结构： 关系（relation）：一个关系对应一张表。 元组（tuple）：表中的一行即为一个元祖。 属性（attribute）：表中的一列即为一个属性 码（key）：也称码键。表中的某个属性组，它可以唯一确定一个元祖。 域（domain）：域是一组具有相同数据类型的值的集合。属性的取值范围来自某个域。 分量：元组中的一个属性值。 关系模式一般表示为：关系名（属性1，属性2，…，属性n） 关系模型要求关系必须是规范化的，关系的每一个分量必须是一个不可分的数据项。 1.3 数据库系统的结构 数据库系统的三级模式结构是指数据库系统是由外模式、模式和内模式三机构成。 外模式：外模式也称子模式或用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。外模式通常是模式的子集，一个数据库可以有多个外模式。数据库管理系统提供外模式数据定义语言（外模式DDL）来严格地定义外模式。 模式：模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。模式实际上是数据库数据在逻辑级上的视图，一个数据库只有一个模式。数据库管理系统提供模式数据定义语言（模式DDL）来严格定义模式。 内模式：内模式也称存储模式，一个数据库只有一个内模式，它是数据物理结构与存储方式的描述，是数据在数据库内部的组织方式。 数据库系统的三级模式是数据的三个抽象级别，他把数据的具体组织留给数据库管理系统管理，使用户能逻辑地、抽象地处理数据，而不关心数据在计算机中的具体表现方式与存储方式。为了能够在系统内部实现这三个抽象层次的联系和转换，数据库管理系统在这三级模式之间提供了两层映像：外模式 / 模式映像和模式/内模式映像。 两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性 外模式 / 模式映像：当模式改变时，有数据库管理员对各个外模式/模式映像做相应的改变，可以是外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。 模式 / 内模式映像：当数据库的存储结构改变时，由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不比改变。保证了数据与程序的物理独立性，简称数据的物理独立性。 1.4 数据库系统的组成 硬件平台级数据库 软件 人员： 数据库管理员：负责全面管理和控制数据库系统 决定数据库中的信息内容和结构 决定数据库的存储结构和存取策略 定义数据的安全性要求和完整性约束条件 监控数据库的使用和运行 数据库的改进和重组、重构 系统分析员：负责应用系统的需求分析和规范说明，要和用户及数据库管理员相结合，确定系统的硬件软件配置，并参与数据库系统的概要设计 数据库设计人员：负责数据库中数据的确定及数据库各级模式的设计。 应用程序员：应用程序员负责设计和编写应用系统的程序模块，并进行调试和安装 用户：这里的用户指最终用户。最终用户通过应用系统的用户接口使用数据库。常用的接口有浏览器、菜单驱动、表格操作、图形显示等。 2.1 关系数据结构及形式定义 域：域是一组具有相同数据类型的值的集合 笛卡尔积：笛卡尔积是域上的一种集合运算 一个域允许的不同取值个数称为这个域的基数 若关系中的某一属性组的值能唯一标识一个元祖，而其子集不能，则称该属性组为候选码，若一个关系有多个候选码，则选定其中一个为主码 关系有三种类型：基本关系（通常又称为基本表或基表）、查询表和视图表。 关系数据库中，关系模式是型，关系是值，关系模式是对关系的描述。 2.2 关系操作 关系模式中常用的关系操作包括查询（query）操作和插入（insert）、删除（delete）、修改（update）操作两大部分 查询操作又可以分为选择（select）、投影（project）、连接（join）、除（divide）、并（union）、差（except）、交（intersection）、笛卡尔积等。其中选择、投影、并、差、笛卡尔积是 5 种基本操作。 关系数据语言分为： 关系代数语言 关系演算语言 元组关系演算语言 域关系演算语言 具有关系代数和关系演算双重特点的语言-结构化查询语言 2.3 关系的完整性 关系模型中有三类完整性约束：实体完整性、参照完整性和用户自定义完整性。其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的两个不变性。 实体完整性规则：若属性（指一个或一组属性）A 是基本关系 R 的主属性，则 A 不能取空值（nullvalue）。所谓空值就是“不知道”或“不存在”或“无意义”的值。 参照完整性规则：若属性（或属性组）F 是基本关系 R 的外码，它与基本关系 S 的主码 K 相对应（基本关系 R 和 S 不一定是不同的关系），则对于 R 中每个元组在 F 上的值必须： 或者取空值（F 的每个属性值均为空值） 或者等于 S 中某个元组的主码值 用户自定义完整性就是针对某一具体关系数据库的约束条件，它反应某一具体应用所涉及的数据必须满足的语义要求。 2.4 关系代数 传统的集合运算是二目运算，包括并、差、交、笛卡尔积 4 种运算。 专门的关系运包括选择、投影、连接、除等运算。 3.1 SQL 概述 SQL 集数据查询、数据操纵、数据定义和数据控制功能于一体，其主要特点包括： 综合统一 高度非过程化 面向集合的操作方式 以同一种语法结构提供多种使用方式 语言简洁，易学易用 支持 SQL 的关系数据库管理系统同样支持关系数据库三级模式结构。其中外模式包括若干视图和部分基本表，数据库模式包括若干基本表，内模式包括若干存储文件。 3.2 学生-课程数据库 学生表：Student（Sno，Sname，Ssex，Sage，Sdept） 课程表：Course（Cno，Cname，Cpno，Ccredit） 学生选课表：SC（Sno，Cno，Grade） 3.3 数据定义 - 创建 删除 修改 模式 CREATE SCHEMA DROP SCHEMA 表 CREATE TABLE DROP TABLE ALTER TABLE 视图 CREATE VIEW DROP VIEW 索引 CREATE INDEX DROP INDEX ALTER INDEX 一个关系数据库管理系统的实例中可以建立多个数据库，一个数据库中可以建立多个模式，一个模式下通常包括多个表、视图和索引等数据库对象。 定义模式： CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt; 删除模式： DROP SCHEMA &lt;模式名&gt;&lt;CASCADE | RESTRICT&gt; 定义基本表： CREATE TABLE &lt;表名&gt; （&lt;列名&gt;&lt;数据类型&gt; [列级完整性约束条件] ...） 建立一个 “学生” 表 Student 1234567CREATE TABLE Student (trueSno CHAR(9) PRIMARY KEY,trueSname CHAR(20) UNIQUE,trueSsex CHAR(2),trueSage SMALLINT,trueSdept CHAR(20)); 数据类型 数据类型 含义 CHAR(n),character(n) 长度为 n 的定长字符串 varchar(n),charactervarying(n) 最大长度为 n 的变长字符串 CLOB 字符串大对象 BLOB 二进制大对象 INT, INTEGER 长整数 smallint 短整数 bigint 大整数 real 单精度浮点数 double persision 双精度浮点数 float(n) 可选精度的浮点数 boolean 逻辑布尔量 date 时间，年月日 time 时间，时分秒 timestamp 时间戳类型 interval 时间间隔类型 模式与表 CREATE TABLE “S-T”.Student(...) / Student 所属的模式是 S-T / 修改基本表 1234ALTER TABLE &lt;表名&gt;[ADD [COLUMN] &lt;新列名&gt;&lt;数据结构&gt; [完整性约束]][DROP [COLUMN] &lt;列名&gt; [CASCADE | RESTRICT]][ALTER COLUMN &lt;列名&gt;&lt;数据结构&gt;]； 向 Student 表增加“入学时间”列，其数据类型为日期 ALTER TABLE Student ADD S_entrance DATE； 将年龄的数据类型由字符型改为整数 ALTER TABLE Student ALTER COLUMN Sage INT； 增加课程名称必须取唯一值的约束条件 ALTER TABLE Course ADD UNIQUE(Cname)； 删除基本表 1DROP TABLE &lt;表名&gt; [RESTRICT | CASCADE]; 删除 Student 表 DROP TABLE Student CASCADE; 建立索引 1CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt;(&lt;列名&gt; ...); 修改索引 ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;; 删除索引 DROP INDEX &lt;索引名&gt; 数据查询 12345SELECT [ALL | DISTINCT] &lt;目标表达式&gt; [,&lt;目标表达式列表&gt;] ...FROM &lt;表名或视图名&gt; [,&lt;表名或视图名&gt; ...] | (&lt;SELECT 语句&gt;) [AS] &lt;别名&gt;[WHERE &lt;条件表达式&gt;][GROUP BY &lt;列名 1&gt; [HAVING &lt;条件表达式&gt;]][ORDER BY &lt;列名 2&gt; [ASC | DESC]]; 查询全体学生的学号和姓名 12SELECT Sno, SnameFROM Student; 查询全体学生的姓名、学号、所在系。 12SELECT Sname, Sno, SdeptFROM Student; 查询全部列 12SELECT *FROM Student; 查询全体学生的姓名及其出生年份 12SELECT Sname, 2017-SageFROM Student; 查询全体学生的姓名、出生年份和所在系，要求用小写字母表示系名 12SELECT Sname, &apos;Year of Brith:&apos;, 2017-Sage, LOWER(Sdept)FROM Student; 查询选修了课程的学生学号（去掉重复行） 12SELECT DISTINCT SnoFROM SC； 查询所有年龄在 20 岁以下的学生姓名及其年龄 123SELECT Sname，SageFROM StudentWHERE Sage &lt; 20; 查询考试成绩不及格的学生的学号 123SELECT DISTINCT SnoFROM SCWHERE Grade &lt; 60; 查询年龄在 20 ～ 23 岁之间的学生的姓名、系别和年龄 123SELECT Sname，Sdept，SageFROM StudentWHERE Sage BETWEEN 20 AND 23； 查询年龄不在 20 ～ 23 之间的学生的姓名、系别和年龄 123SELECT Sname，Sdept，SageFROM StudentWHERE Sage NOT BETWEEN 20 AND 23 ； 查询既不是计算机系、数学系、也不是信息系的学生的姓名和性别 123SELECT Sname，SsexFROM StudentWHERE Sdept NOT IN (&apos;CS&apos;, &apos;MA&apos;, &apos;IS&apos;); 通配符 % 代表任意长度的字符串 通配符 _ 代表任意单个字符 查询学号为 201215121 的学生的详细情况 123SELECT * FROM StudentWHERE Sno LIKE &apos;201215121&apos;; 等价于 WHERE Sno = &apos;201215121&apos;; 查询所有姓刘的学生的姓名、学号和性别 123SELECT Sname，Sno，SsexFROM StudentWHERE Sname LIKE ‘刘%’； 查询所有不是姓刘的学生的姓名、学号和性别 123SELECT Sname， Sno，SsexFROM StudentWHERE Sname NOT LIKE ‘刘%‘； 查询所有有成绩的学生的学号和课程号 123SELECT Sno，CnoFROM SCWHERE Grade IS NOT NULL； 查询选修了3号课程的学生的学号和成绩，查询结果按分数的降序排列 1234SELECT Sno，GradeFROM SCWHERE Cno = ’3‘ORDER BY Grade DESC(default ASC); 查询全体学生情况，查询结果按所在系的系号升序排序，同一系中的学生按年龄降序排序。 123SELECT * FROM StudentORDER BY Sdept, Sage, DESC; 聚集函数 函数名 功能 COUNT([DISTINCT ALL] &lt;列名&gt;) 统计一列中值的个数 COUNT(*) 统计元祖个数 SUM([DISTINCT ALL]] &lt;列名&gt;) 计算一列值的总和 AVG([DISTINCT ALL]] &lt;列名&gt;) 计算一列值的平均值 MAX([DISTINCT ALL]] &lt;列名&gt;) 求一列值中的最大值 MIN([DISTINCT ALL]] &lt;列名&gt;) 求一列值中的最小值 查询学生总数 12SELECT COUNT(*)FROM Student; 查询选修了课程的学生人数 12SELECT COUNT(DISTINCT Sno)FROM SC; 计算选修了一号课程的学生平均成绩 123SELECT AVG(Grade)From SCWHERE Cno=&apos;1&apos;; 查询选修1号课程的学生最高分数 123SELECT MAX(Grade)FROM SCWHERE Cno=&apos;1&apos;; 查询学生201215012选修课程的总学分数。 123SELECT SUM(Ccredit)FROM SC,CourseWHERE Sno=&apos;201215012&apos; AND SC.Cno = Course.Cno; 求各个课程号及相应的选课人数 123SELECT Cno，COUNT(Sno)FROM SCGROUP BY Cno; 查询选修了三门以上课程的学生学号 1234SELECT SnoFROM SCGROUP BY SnoHAVING COUNT(*) &gt; 3; 查询平均成绩大于等于 90 分的学生学号和平均成绩 1234SELECT Sno, AVG(Grade)FROM SCGROUP BY SnoHAVING AVG(Grade) &gt;= 90; 查询每个学生及其选修课的情况 123SELECT Student.*, SC.*FROM Student, SCWHERE Student.Sno = SC.Sno; 查询选修 2 号课程且成绩在 90 分以上的所有学生的学号和姓名 123SELECT Student.Sno, SnameFROM Student,SCWHERE Student.Sno=SC.Sno AND SC.Cno = &apos;2&apos; AND SC.Grade &gt; 90; 查询每个学生的学号、姓名、选修的课程名及成绩 123SELECT Student.Sno, Sname, Cname, GradeFROM Student, SC, CourseWHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno; 3.7 视图 建立视图 123CREATE VIEW &lt;视图名&gt; AS &lt;子查询&gt;[WITH CHECK OPTION]; 建立信息系学生的视图 12345CREATE VIEW IS_StudentASSELECT Sno,sname,SageFROM StudentWHERE Sdept='IS'; 定义一个反映学生出生年份的视图 1234CREATE VIEW BT_S(Sno,Sname, Sbirth)ASSELECT Sno,Sname,2014-SageFROM Student; 数据库安全性 数据库的数据保护主要包括数据的安全性和完整性。 数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏。 数据库的不安全因素 非授权用户对数据库的恶意存取和破坏 以保证数据免受未经授权的访问和破坏，数据库管理系统提供的安全措施主要包括用户身份鉴别、存取控制和视图等技术。 数据库中重要或敏感的数据被泄露 为防止数据泄露，数据库管理系统提供的主要技术有强制存取控制、数据加密存储和加密传输等。 安全环境的脆弱性]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>数据库系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机系统读书笔记]]></title>
    <url>%2F2018%2F03%2F22%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第 1 章 计算机系统漫游信息就是位 + 上下文 源程序实际上就是一个由值 0 和 1 组成的位（又称位比特）序列，8 个字节被组织成一组，称为字节。每个字节表示程序中的某些文本字符。 系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上的传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。 系统的硬件组成- 1. 总线：贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。 2. I/O 设备：I/O （输入/输出）设备是系统与外部世界的联系通道。一般系统都包括四个 I/O 设备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器（简单的说解释磁盘）。每个 I/O 设备都通过一个控制器或适配器与 I/O 总线相连。控制器和适配器之间的区别主要在于他们的封装方式。控制器是 I/O 设备本身或者系统的主印刷电路板（通常称作主板）上的芯片组。二适配器则是一块插在主板插槽上的卡。无论如何，他们的功能都是在 I/O 总线和 I/O 设备之间传递信息。 3. 主存：主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组 **动态随机存取存储器（DRAM）** 芯片组成的。从逻辑上说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。 4. 处理器：**中央处理单元（CPU）** 简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为**程序计数器（PC）**。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该指令的地址）。 高速缓存存储器（cache memory，简称 cache 或高速缓存），作为暂时的集结区域，存放近期可能会需要的信息。 静态随机访问存储器（SRAM） 存储设备形成层次结构 存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。 操作系统管理硬件 我们可以吧操作系统看成是应用程序和硬件之间的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。 操作系统有两个基本功能： 防止硬件被失控的应用程序滥用； 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。 操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。 文件是对 I/O 设备的抽象表示，虚拟内存是对主存和磁盘 I/O 设备的抽象表示，进程是对处理器、主存和 I/O 设备的抽象表示。 进程： 进程是操作系统对一个正在运行程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。 从一个进程到另一个进程的转换是由操作系统 内核（kernel） 管理的。内核是操作系统代码常驻主存的部分。内核是系统管理全部进程所用代码和数据结构的集合。 线程： 在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线都运行在进程的上下文中，并共享同样的代码和全局数据。 虚拟内存： 虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为 虚拟地址空间 。 文件： 文件就是字节序列，仅此而已。每个 I/O 设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。 计算机系统中抽象的重要性 文件是对 I/O 设备的抽象。 虚拟内存是对程序存储器的抽象。 进程是对一个正在运行的程序的抽象。 虚拟机是对整个计算机的抽象。 小结 计算机系统是由硬件和系统软件组成的，他们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，他们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是 ASCII 文本，然后编译器和链接器翻译成二进制可执行文件。 处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O 设备和 CPU 寄存器之间复制复制数据，所以将系统中的存储设备划分成层次结构——CPU 寄存器在顶部，接着是多层的硬件高速缓存器、DRAM 主存和磁盘存储器。在层次模型中，位于更高层的存储设备比底层的存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化 C 程序的性能。 操作系统内核是应用程序和硬盘之间的媒介。他提供三个基本的抽象： 文件是对 I/O 设备的抽象； 虚拟内存是对主存和磁盘的抽象； 进程是处理器、主存和 I/O 设备的抽象。 最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种 I/O 设备。 第二章 信息的表示和处理信息存储- 机器级程序将内存视为一个非常大的字节数组，称为**虚拟内存（virtual memory）**。内存的每个字节都由一个唯一的数字来标识，称为它的**地址（address）**，所有可能地址的集合就称为**虚拟地址空间（virtual address space）**。顾名思义，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现是将动态随机访问存储器（DRAM）、闪存、磁盘存储器，特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。 十六进制表示法- 一个字节由 8 位组成。由于二进制表示法太冗长，而十进制表示法与位模式的互相转化很麻烦。所以以 16 为基数，叫做**十六进制（hexadecimal）数**，来表示位模式。十六进制（简写为‘hex’）使用 ‘0’ ～ ‘9’ 以及字符 ‘A&#39; ~ &#39;F&#39;]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 真题题解]]></title>
    <url>%2F2018%2F03%2F22%2FPAT_%E7%9C%9F%E9%A2%98%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1012. 数字分类 (20)-PAT乙级真题给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字： A1 = 能被5整除的数字中所有偶数的和； A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4…； A3 = 被5除后余2的数字的个数； A4 = 被5除后余3的数字的平均数，精确到小数点后1位； A5 = 被5除后余4的数字中最大数字。 输入格式： 每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N， 随后给出N个不超过1000的待分类的正整数。数字间以空格分隔。 输出格式： 对给定的N个正整数，按题目要求计算A1~A5并在一行中顺序输出。 数字间以空格分隔，但行末不得有多余空格。 若其中某一类数字不存在，则在相应位置输出“N”。 输入样例1： 13 1 2 3 4 5 6 7 8 9 10 20 16 18 输出样例1： 30 11 2 9.7 9 输入样例2： 8 1 2 4 5 6 7 9 16 输出样例2： N 11 2 N 9 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main() &#123; int a1 = 0, a2 = 0, a3 = 0, a5 = 0; float a4 = 0.0; int N; cin &gt;&gt; N; int *a; a = new int[N]; for (int i = 0; i &lt; N; ++i) &#123; cin &gt;&gt; a[i]; &#125; int cnt1 = 0, cnt2 = 0, cnt3 = 0, cnt4 = 0, cnt5 = 0; int temp = 1; for (int i = 0; i &lt; N; ++i) &#123; if (a[i] % 5 == 0 &amp;&amp; a[i] % 2 == 0) &#123; a1 += a[i]; cnt1++; &#125; else if (a[i] % 5 == 1) &#123; a2 = a2 + temp * a[i]; temp = -temp; cnt2++; &#125; else if (a[i] % 5 == 2) &#123; a3++; cnt3++; &#125; else if (a[i] % 5 == 3) &#123; a4 += a[i]; cnt4++; &#125; else if (a[i] % 5 == 4) &#123; if (a5 &lt; a[i]) &#123; a5 = a[i]; &#125; cnt5++; &#125; &#125; if (cnt1 == 0) &#123; cout &lt;&lt; "N "; &#125; else &#123; cout &lt;&lt; a1 &lt;&lt; " "; &#125; if (cnt2 == 0) &#123; cout &lt;&lt; "N "; &#125; else &#123; cout &lt;&lt; a2 &lt;&lt; " "; &#125; if (cnt3 == 0) &#123; cout &lt;&lt; "N "; &#125; else &#123; cout &lt;&lt; a3 &lt;&lt; " "; &#125; if (cnt4 == 0) &#123; cout &lt;&lt; "N "; &#125; else &#123; printf("%.1f ", a4 / cnt4); &#125; if (cnt5 == 0) &#123; cout &lt;&lt; "N"; &#125; else &#123; cout &lt;&lt; a5; &#125; delete[] a; return 0;&#125; 1013. 数素数 (20)-PAT乙级真题令Pi表示第i个素数。现任给两个正整数M &lt;= N &lt;= 10^4，请输出PM到PN的所有素数。 输入格式： 输入在一行中给出M和N，其间以空格分隔。 输出格式： 输出从PM到PN的所有素数，每10个数字占1行，其间以空格分隔，但行末不得有多余空格。 输入样例： 5 27 输出样例： 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;bool isprime(int a) &#123; for (int i = 2; i &lt;= sqrt(a) ; ++i) &#123; if (a % i == 0) return false; &#125; return true;&#125;int main() &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; int vec[10001]; int k = 2; int i = 0; int t = 0; while (t &lt; b) &#123; if (isprime(k)) &#123; t++; if (t &gt;= a) vec[++i] = k; &#125; k++; &#125; int temp = 0; for (int j = 1; j &lt;= i; j++) &#123; if (j % 10 == 1) &#123; ++temp; cout &lt;&lt; vec[j]; continue; &#125; cout &lt;&lt; " " &lt;&lt; vec[j]; if (++temp % 10 == 0) cout &lt;&lt; endl; &#125; return 0;&#125; 1014. 福尔摩斯的约会 (20)-PAT乙级真题大侦探福尔摩斯接到一张奇怪的字条：“我们约会吧！3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm”。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间“星期四 14:04”，因为前面两字符串中第1对相同的大写英文字母（大小写有区分）是第4个字母’D’，代表星期四；第2对相同的字符是’E’，那是第5个英文字母，代表一天里的第14个钟头（于是一天的0点到23点由数字0到9、以及大写字母A到N表示）；后面两字符串第1对相同的英文字母’s’出现在第4个位置（从0开始计数）上，代表第4分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。 输入格式： 输入在4行中分别给出4个非空、不包含空格、且长度不超过60的字符串。 输出格式： 在一行中输出约会的时间，格式为“DAY HH:MM”，其中“DAY”是某星期的3字符缩写,即MON表示星期一，TUE表示星期二，WED表示星期三，THU表示星期四，FRI表示星期五，SAT表示星期六，SUN表示星期日。题目输入保证每个测试存在唯一解。 输入样例： 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm 输出样例： THU 14:04 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;using namespace std;int main() &#123; string a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; unsigned long alen = a.length(); unsigned long blen = b.length(); unsigned long clen = c.length(); unsigned long dlen = d.length(); char tc[2]; int i; i = 0; for (; i &lt; min(alen, blen); i++) &#123; if (a[i] == b[i] &amp;&amp; (a[i] &gt;= 'A' &amp;&amp; a[i] &lt;= 'G')) &#123; tc[0] = a[i]; break; &#125; &#125; for (++i; i &lt; min(alen, blen); ++i) &#123; if (a[i] == b[i] &amp;&amp; ((a[i] &gt;= '0' &amp;&amp; a[i] &lt;= '9') || (a[i] &gt;= 'A' &amp;&amp; a[i] &lt;= 'N'))) &#123; tc[1] = a[i]; break; &#125; &#125; int temp = 0; for (int j = 0; j &lt; min(clen, dlen); ++j) &#123; if (c[j] == d[j] &amp;&amp; ((c[j] &gt;= 'a' &amp;&amp; c[j] &lt;= 'z') || (c[j] &gt;= 'A' &amp;&amp; c[j] &lt;= 'Z'))) &#123; temp = j; break; &#125; &#125; string string1; switch (tc[0]) &#123; case 'A': string1 = "MON"; break; case 'B': string1 = "TUE"; break; case 'C': string1 = "WED"; break; case 'D': string1 = "THU"; break; case 'E': string1 = "FRI"; break; case 'F': string1 = "SAT"; break; case 'G': string1 = "SUN"; break; default: break; &#125; cout &lt;&lt; string1 &lt;&lt; " "; int string2; if (tc[1] - '0' &lt; 10) &#123; string2 = tc[1] - '0'; cout &lt;&lt; '0'; &#125; else &#123; string2 = tc[1] - 'A' + 10; &#125; cout &lt;&lt; string2 &lt;&lt; ":"; if (temp &lt; 10) cout &lt;&lt; "0" &lt;&lt; temp; else cout &lt;&lt; temp; return 0;&#125; 1015. 德才论 (25)-PAT乙级真题题目描述： 宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。” 现给出一批考生的德才分数，请根据司马光的理论给出录取排名。 输入格式： 输入第1行给出3个正整数，分别为：N（&lt;=105），即考生总数；L（&gt;=60），为录取最低分数线，即德分和才分均不低于L的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线L的考生也按总分排序，但排在第三类考生之后。 随后N行，每行给出一位考生的信息，包括：准考证号、德分、才分，其中准考证号为8位整数，德才分为区间[0, 100]内的整数。数字间以空格分隔。 输出格式： 输出第1行首先给出达到最低分数线的考生人数M，随后M行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。 输入样例： 14 60 80 10000001 64 90 10000002 90 60 10000011 85 80 10000003 85 80 10000004 80 85 10000005 82 77 10000006 83 76 10000007 90 78 10000008 75 79 10000009 59 90 10000010 88 45 10000012 80 100 10000013 90 99 10000014 66 60 输出样例： 12 10000013 90 99 10000012 80 100 10000003 85 80 10000011 85 80 10000004 80 85 10000007 90 78 10000006 83 76 10000005 82 77 10000002 90 60 10000014 66 60 10000008 75 79 10000001 64 90 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int num; int de; int cai;&#125;;bool cmp(node a, node b) &#123; if ((a.de + a.cai) != (b.cai + b.de)) &#123; return (a.de + a.cai) &gt; (b.de + b.cai); &#125; else if (a.de != b.de) &#123; return a.de &gt; b.de; &#125; else &#123; return a.num &lt; b.num; &#125;&#125;int main() &#123; int n, l, h; scanf("%d %d %d", &amp;n, &amp;l, &amp;h); vector&lt;node&gt; vec1, vec2, vec3, vec4; node temp = &#123;&#125;; int total = n; for (int i = 0; i &lt; n; ++i) &#123; scanf("%d %d %d", &amp;temp.num, &amp;temp.de, &amp;temp.cai); if (temp.de &lt; l || temp.cai &lt; l) &#123; total--; continue; &#125; if (temp.de &gt;= h &amp;&amp; temp.cai &gt;= h) &#123; vec1.push_back(temp); &#125; else if (temp.de &gt;= h &amp;&amp; temp.cai &lt; h) &#123; vec2.push_back(temp); &#125; else if (temp.de &lt; h &amp;&amp; temp.cai &lt; h &amp;&amp; temp.de &gt;= temp.cai) &#123; vec3.push_back(temp); &#125; else &#123; vec4.push_back(temp); &#125; &#125; sort(vec1.begin(), vec1.end(), cmp); sort(vec2.begin(), vec2.end(), cmp); sort(vec3.begin(), vec3.end(), cmp); sort(vec4.begin(), vec4.end(), cmp); printf("%d\n", total); for (int j = 0; j &lt; vec1.size(); j++) &#123; printf("%d %d %d\n", vec1[j].num, vec1[j].de, vec1[j].cai); &#125; for (int j = 0; j &lt; vec2.size(); j++) &#123; printf("%d %d %d\n", vec2[j].num, vec2[j].de, vec2[j].cai); &#125; for (int j = 0; j &lt; vec3.size(); j++) &#123; printf("%d %d %d\n", vec3[j].num, vec3[j].de, vec3[j].cai); &#125; for (int j = 0; j &lt; vec4.size(); j++) &#123; printf("%d %d %d\n", vec4[j].num, vec4[j].de, vec4[j].cai); &#125; return 0;&#125; 1016. 部分A+B (15)-PAT乙级真题正整数A的“DA（为1位整数）部分”定义为由A中所有DA组成的新整数PA。例如：给定A = 3862767，DA = 6，则A的“6部分”PA是66，因为A中有2个6。 现给定A、DA、B、DB，请编写程序计算PA + PB。 输入格式： 输入在一行中依次给出A、DA、B、DB，中间以空格分隔，其中0 &lt; A, B &lt; 10^10。 输出格式： 在一行中输出PA + PB的值。 输入样例1： 3862767 6 13530293 3 输出样例1： 399 输入样例2： 3862767 1 13530293 8 输出样例2： 0 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;int main() &#123; string a, b; int m, n; cin &gt;&gt; a &gt;&gt; m &gt;&gt; b &gt;&gt; n; int alen = a.length(); int blen = b.length(); int countA = 0; int countB = 0; for (int i = 0; i &lt; alen; ++i) &#123; if ((a[i] - '0') == m) &#123; countA++; &#125; &#125; for (int i = 0; i &lt; blen; ++i) &#123; if ((b[i] - '0') == n) &#123; countB++; &#125; &#125; int ca = 0; int cb = 0; if (countA != 0) &#123; ca = m; &#125; if (countB != 0) &#123; cb = n; &#125; for (int i = 1; i &lt; countA; ++i) &#123; ca = 10 * ca + m; &#125; for (int i = 1; i &lt; countB; ++i) &#123; cb = cb * 10 + n; &#125; cout &lt;&lt; ca + cb; return 0;&#125; 1017. A除以B (20)-PAT乙级真题本题要求计算A/B，其中A是不超过1000位的正整数，B是1位正整数。你需要输出商数Q和余数R， 使得A = B * Q + R成立。 输入格式： 输入在1行中依次给出A和B，中间以1空格分隔。 输出格式： 在1行中依次输出Q和R，中间以1空格分隔。 输入样例： 123456789050987654321 7 输出样例： 17636684150141093474 3 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main() &#123; string s; int a; cin &gt;&gt; s &gt;&gt; a; int len = s.length(); int t = 0; int temp = 0; t = (s[0] - '0') / a; if ((t != 0 &amp;&amp; len &gt; 1) || len == 1) &#123; cout &lt;&lt; t; &#125; temp = (s[0] - '0') % a; for (int i = 1; i &lt; len; ++i) &#123; t = (temp * 10 + s[i] - '0') / a; cout &lt;&lt; t; temp = (temp * 10 + s[i] - '0') % a; &#125; cout &lt;&lt; " " &lt;&lt; temp; return 0;&#125; 1001. A+B Format (20)-PAT甲级真题Calculate a + b and output the sum in standard format — that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space. Output For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input -1000000 9 Sample Output -999,991 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main() &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; string s = to_string(a + b); int len = s.length(); for (int i = 0; i &lt; len; ++i) &#123; cout &lt;&lt; s[i]; if (s[i] == '-') continue; if ((i + 1) % 3 == len % 3 &amp;&amp; i != len - 1) cout &lt;&lt; ','; &#125; return 0;&#125; 1002. A+B for Polynomials (25)-PAT甲级真题This time, you are supposed to find A+B where A and B are two polynomials. Input Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000. Output For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input 2 1 2.4 0 3.2 2 2 1.5 1 0.5 Sample Output 3 2 1.5 1 2.9 0 3.2 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;int main() &#123; float c[1001] = &#123;0&#125;; int k1, k2, t; float temp; cin &gt;&gt; k1; for (int i = 0; i &lt; k1; ++i) &#123; scanf("%d %f", &amp;t, &amp;temp); c[t] += temp; &#125; cin &gt;&gt; k2; for (int i = 0; i &lt; k2; ++i) &#123; scanf("%d %f", &amp;t, &amp;temp); c[t] += temp; &#125; int count = 0; for (int i = 0; i &lt; 1001; ++i) &#123; if (c[i] != 0) count++; &#125; cout &lt;&lt; count; if (count != 0) cout &lt;&lt; " "; for (int i = 1000; i &gt;= 0; --i) &#123; if (c[i] != 0 &amp;&amp; count &gt; 0)&#123; printf("%d %.1f", i, c[i]); count--; if (count &gt;= 1) printf(" "); &#125; &#125; return 0;&#125; PAT 1070. 结绳(25)-乙级给定一段一段的绳子，你需要把它们串成一条绳。每次串连的时候，是把两段绳子对折，再如下图所示套接在一起。这样得到的绳子又被当成是另一段绳子，可以再次对折去跟另一段绳子串连。每次串连后，原来两段绳子的长度就会减半。 给定N段绳子的长度，你需要找出它们能串成的绳子的最大长度。 输入格式： 每个输入包含1个测试用例。每个测试用例第1行给出正整数N (2 &lt;= N &lt;= 104)；第2行给出N个正整数，即原始绳段的长度，数字间以空格分隔。所有整数都不超过104。 输出格式： 在一行中输出能够串成的绳子的最大长度。结果向下取整，即取为不超过最大长度的最近整数。 输入样例： 8 10 15 12 3 4 13 1 15 输出样例： 14 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; vec(n); for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; vec[i]; &#125; sort(vec.begin(), vec.end()); int result = vec[0]; for (int i = 1; i &lt; n; ++i) &#123; result = (result + vec[i]) / 2; &#125; cout &lt;&lt; result; return 0;&#125; L1-020. 帅到没朋友-PAT团体程序设计天梯赛GPLT当芸芸众生忙着在朋友圈中发照片的时候，总有一些人因为太帅而没有朋友。本题就要求你找出那些帅到没有朋友的人。 输入格式： 输入第一行给出一个正整数N（&lt;=100），是已知朋友圈的个数；随后N行，每行首先给出一个正整数K（&lt;=1000），为朋友圈中的人数，然后列出一个朋友圈内的所有人——为方便起见，每人对应一个ID号，为5位数字（从00000到99999），ID间以空格分隔；之后给出一个正整数M（&lt;=10000），为待查询的人数；随后一行中列出M个待查询的ID，以空格分隔。 注意：没有朋友的人可以是根本没安装“朋友圈”，也可以是只有自己一个人在朋友圈的人。虽然有个别自恋狂会自己把自己反复加进朋友圈，但题目保证所有K超过1的朋友圈里都至少有2个不同的人。 输出格式： 按输入的顺序输出那些帅到没朋友的人。ID间用1个空格分隔，行的首尾不得有多余空格。如果没有人太帅，则输出“No one is handsome”。 注意：同一个人可以被查询多次，但只输出一次。 输入样例1： 3 3 11111 22222 55555 2 33333 44444 4 55555 66666 99999 77777 8 55555 44444 10000 88888 22222 11111 23333 88888 输出样例1： 10000 88888 23333 输入样例2： 3 3 11111 22222 55555 2 33333 44444 4 55555 66666 99999 77777 4 55555 44444 22222 11111 输出样例2： No one is handsome 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main() &#123; int a, b, c; cin &gt;&gt; a; set&lt;string&gt; s, ans; string str; for(int i = 0; i &lt; a; i++) &#123; cin &gt;&gt; b; for(int j = 0; j &lt; b; j++) &#123; cin &gt;&gt; str; if (b &gt;= 2) s.insert(str); &#125; &#125; cin &gt;&gt; c; int flag = 0; for(int i = 0; i &lt; c; i++) &#123; cin &gt;&gt; str; if(s.find(str) == s.end() &amp;&amp; ans.find(str) == ans.end()) &#123; ans.insert(str); if(flag == 1) cout &lt;&lt; " "; cout &lt;&lt; str; flag = 1; &#125; &#125; if(flag == 0) cout &lt;&lt; "No one is handsome"; return 0;&#125; CCCC-GPLT L1-033. 出生年 天梯赛以上是新浪微博中一奇葩贴：“我出生于1988年，直到25岁才遇到4个数字都不相同的年份。”也就是说，直到2013年才达到“4个数字都不相同”的要求。本题请你根据要求，自动填充“我出生于y年，直到x岁才遇到n个数字都不相同的年份”这句话。 输入格式： 输入在一行中给出出生年份y和目标年份中不同数字的个数n，其中y在[1, 3000]之间，n可以是2、或3、或4。注意不足4位的年份要在前面补零，例如公元1年被认为是0001年，有2个不同的数字0和1。 输出格式： 根据输入，输出x和能达到要求的年份。数字间以1个空格分隔，行首尾不得有多余空格。年份要按4位输出。注意：所谓“n个数字都不相同”是指不同的数字正好是n个。如“2013”被视为满足“4位数字都不同”的条件，但不被视为满足2位或3位数字不同的条件。 输入样例1： 1988 4 输出样例1： 25 2013 输入样例2： 1 2 输出样例2： 0 0001 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main() &#123; int y, n; cin &gt;&gt; y &gt;&gt; n; for (int i = y; i &lt;= 3012; ++i) &#123; set&lt;int&gt; s; int num = i; for (int j = 0; j &lt; 4; ++j) &#123; s.insert(num % 10); num /= 10; &#125; if (s.size() == n) &#123; printf("%d %04d", i - y, i); break; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 乙级真题题解 1006~1011]]></title>
    <url>%2F2018%2F03%2F22%2FPAT_%E4%B9%99%E7%BA%A7%E7%9C%9F%E9%A2%98%E9%A2%98%E8%A7%A3_1006~1011%2F</url>
    <content type="text"><![CDATA[1006. 换个格式输出整数 (15)-PAT乙级真题让我们用字母B来表示“百”、字母S表示“十”，用“12…n”来表示个位数字n（&lt;10），换个格式来输出任一个不超过3位的正整数。例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“十”、以及个位的4。 输入格式： 每个测试输入包含1个测试用例，给出正整数n（&lt;1000）。 输出格式： 每个测试用例的输出占一行，用规定的格式输出n。 输入样例1： 234 输出样例1： BBSSS1234 输入样例2： 23 输出样例2： SS123 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int i = 0; int b[3] = &#123;0&#125;; while (n) &#123; b[i++] = n % 10; n = n / 10; &#125; for (int j = 0; j &lt; b[2]; ++j) &#123; cout &lt;&lt; "B"; &#125; for (int k = 0; k &lt; b[1]; ++k) &#123; cout &lt;&lt; "S"; &#125; for (int l = 1; l &lt;= b[0]; ++l) &#123; cout &lt;&lt; l; &#125; return 0;&#125; 1007. 素数对猜想 (20)-PAT乙级真题让我们定义 dn 为：dn = pn+1 – pn，其中 pi 是第i个素数。显然有 d1=1 且对于n&gt;1有 dn 是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。 现给定任意正整数N (&lt; 105)，请计算不超过N的满足猜想的素数对的个数。 输入格式：每个测试输入包含1个测试用例，给出正整数N。 输出格式：每个测试用例的输出占一行，不超过N的满足猜想的素数对的个数。 输入样例： 20 输出样例： 4 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;bool isPrime(int a) &#123; for (int i = 2; i * i &lt;= a; ++i) &#123; if (a % i == 0) return false; &#125; return true;&#125;int main() &#123; int n; cin &gt;&gt; n; int count = 0; for (int i = 5; i &lt;= n; ++i) &#123; if(isPrime(i - 2) &amp;&amp; isPrime(i)) count++; &#125; cout &lt;&lt; count; return 0;&#125; 1008. 数组元素循环右移问题 (20)-PAT乙级真题一个数组A中存有N（N&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M&gt;=0）个位置，即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动 的方法？ 输入格式：每个输入包含一个测试用例，第1行输入N ( 1&lt;=N&lt;=100)、M（M&gt;=0）；第2行输入N个整数, 之间用空格分隔。 输出格式：在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。 输入样例： 6 2 1 2 3 4 5 6 输出样例： 5 6 1 2 3 4 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; a[i]; &#125; if (m != n &amp;&amp; m != 0) &#123; if (m &gt; n) m = m - n; reverse(a.begin(), a.begin() + n); reverse(a.begin(), a.begin() + m); reverse(a.begin() + m, a.begin() + n); &#125; for (int j = 0; j &lt; n -1; ++j) &#123; cout &lt;&lt; a[j] &lt;&lt; " "; &#125; cout &lt;&lt; a[n - 1]; return 0;&#125; 1009. 说反话 (20)-PAT乙级真题题目描述： 给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。 输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用1个空格分开，输入保证句子末尾没有多余的空格。 输出格式：每个测试用例的输出占一行，输出倒序后的句子。 输入样例： Hello World Here I Come 输出样例： Come I Here World Hello 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() &#123; stack&lt;string&gt; v; string s; while(cin &gt;&gt; s) &#123; v.push(s); &#125; cout &lt;&lt; v.top(); v.pop(); while (!v.empty()) &#123; cout &lt;&lt; " " &lt;&lt; v.top(); v.pop(); &#125; return 0;&#125; 1010. 一元多项式求导 (25)-PAT乙级真题设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为n*xn-1。） 输入格式：以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。 输出格式：以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是0，但是表示为“0 0”。 输入样例： 3 4 -5 2 6 1 -2 0 输出样例： 12 3 -10 1 6 0 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int main() &#123; int a, b; bool isFirst = false; while (cin &gt;&gt; a &gt;&gt; b) &#123; if (b == 0) continue; if (isFirst) cout &lt;&lt; " "; else isFirst = true; cout &lt;&lt; a * b &lt;&lt; " " &lt;&lt; b - 1; &#125; if (!isFirst) cout &lt;&lt; "0 0"; return 0;&#125; 1011. A+B和C (15)-PAT乙级真题题目描述： 给定区间[-2^31, 2^31]内的3个整数A、B和C，请判断A+B是否大于C。 输入格式： 输入第1行给出正整数T(&lt;=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。 输出格式： 对每组测试用例，在一行中输出“Case #X: true”如果A+B&gt;C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。 输入样例： 4 1 2 3 2 3 4 2147483647 0 2147483646 0 -2147483648 -2147483647 输出样例： Case #1: false Case #2: true Case #3: true Case #4: false 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; long long int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; "Case #" &lt;&lt; i + 1 &lt;&lt; ": "; if (a + b &gt; c) cout &lt;&lt; "true"; else cout &lt;&lt; "false"; cout &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 乙级真题题解 1001~1005]]></title>
    <url>%2F2018%2F03%2F22%2FPAT_%E4%B9%99%E7%BA%A7%E7%9C%9F%E9%A2%98%E9%A2%98%E8%A7%A31001~1005%2F</url>
    <content type="text"><![CDATA[1001. 害死人不偿命的(3n+1)猜想 (15)-PAT乙级真题卡拉兹(Callatz)猜想： 对任何一个自然数n，如果它是偶数，那么把它砍掉一半； 如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去， 最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布 了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似 很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)， 以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展…… 我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n， 简单地数一下，需要多少步（砍几下）才能得到n=1？ 输入格式： 每个测试输入包含1个测试用例，即给出自然数n的值。 输出格式： 输出从n计算到1需要的步数。 输入样例： 3 输出样例： 5 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int count = 0; while (n != 1) &#123; if (n % 2 != 0) &#123; n = 3 * n + 1; &#125; n = n / 2; count++; &#125; cout &lt;&lt; count; return 0;&#125; 1002. 写出这个数 (20)-PAT乙级真题读入一个自然数n，计算其各位数字之和，用汉语拼音写出和的每一位数字。 输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。这里保证n小于10100。 输出格式： 在一行内输出n的各位数字之和的每一位，拼音数字间有1 空格，但一行中最后一个拼音 数字后没有空格。 输入样例： 1234567890987654321123456789 输出样例： yi san wu 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; unsigned long len; len = s.length(); int *a; a = new int[len]; int sum = 0; string str[10] = &#123; "ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu" &#125;; for (int i = 0; i &lt; len; ++i) &#123; a[i] = s[i] - '0'; sum = sum + a[i]; &#125; int *b; b = new int[len]; int j = 0; if (sum == 0) &#123; cout &lt;&lt; "ling"; &#125; else &#123; while (sum != 0) &#123; b[j++] = sum % 10; sum = sum / 10; &#125; &#125; for (int k = j - 1; k &gt;= 1; k--) &#123; cout &lt;&lt; str[b[k]] &lt;&lt; " "; &#125; cout &lt;&lt; str[b[0]]; delete[] a; delete[] b; return 0;&#125; 1003. 我要通过！(20)-PAT乙级真题“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。 得到“答案正确”的条件是： 1. 字符串中必须仅有P, A, T这三种字符，不可以包含其它字符； 2. 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串； 3. 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。 现在就请你为PAT写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。 输入格式： 每个测试输入包含1个测试用例。第1行给出一个自然数n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过100，且不包含空格。 输出格式： 每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出YES，否则输出NO。 输入样例： 8 PAT PAAT AAPATAA AAPAATAAAA xPATx PT Whatever APAAATAA 输出样例： YES YES YES YES NO NO NO NO 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;using namespace std;bool judge(string str) &#123; unsigned long len; len = str.length(); if (len &lt;= 2) return false; bool book[3] = &#123;false&#125;; for (int i = 0; i &lt; len; i++) &#123; if(str[i] == 'P') book[0] = true; else if(str[i] == 'A') book[1] = true; else if(str[i] == 'T') book[2] = true; else return false; if (str[i] == 'P') &#123; for (int j = 0; j &lt; i; j++) &#123; if (str[j] != 'A') return false; &#125; if (str [i+1] != 'A') return false; for (int k = i + 2; k &lt; len; k++) &#123; if (str[k] != 'A') &#123; if (str[k] != 'T') &#123; return false; &#125; if ((len - 1 - k) != ((k - 1 - i) * i)) return false; for (int m = k + 1; m &lt; len; m++) &#123; if (str[m] != 'A') return false; &#125; &#125; &#125; &#125; &#125; return !(!book[0] || !book[1] || !book[2]);&#125;int main() &#123; int n; cin &gt;&gt; n; string s; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s; if(judge(s)) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; &#125; return 0;&#125; 1004. 成绩排名 (20)-PAT乙级真题读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。 输入格式：每个测试输入包含1个测试用例，格式为 第1行：正整数n 第2行：第1个学生的姓名 学号 成绩 第3行：第2个学生的姓名 学号 成绩 … … … 第n+1行：第n个学生的姓名 学号 成绩 其中姓名和学号均为不超过10个字符的字符串，成绩为0到100之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。 输出格式：对每个测试用例输出2行，第1行是成绩最高学生的姓名和学号，第2行是成绩最低学生的姓名和学号，字符串间有1空格。 输入样例： 3 Joe Math990112 89 Mike CS991301 100 Mary EE990830 95 输出样例： Mike CS991301 Joe Math990112 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int max = -1, min = 101, score; string maxName, minName, maxNum, minNum, name, num; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; name; cin &gt;&gt; num; cin &gt;&gt; score; if (max &lt; score) &#123; max = score; maxName = name; maxNum = num; &#125; if (min &gt; score) &#123; min = score; minName = name; minNum = num; &#125; &#125; cout &lt;&lt; maxName &lt;&lt; " " &lt;&lt; maxNum &lt;&lt; endl &lt;&lt; minName &lt;&lt; " " &lt;&lt; minNum; return 0;&#125; 1005. 继续(3n+1)猜想 (25) PAT乙级真题卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。 当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这4个数已经在验证3的时候遇到过了，我们称5、8、4、2是被3“覆盖”的数。我们称一个数列中的某个数n为“关键数”，如果n不能被数列中的其他数字所覆盖。 现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。 输入格式：每个测试输入包含1个测试用例，第1行给出一个正整数K(&lt;100)，第2行给出K个互不相同的待验证的正整数n(1&lt;n&lt;=100)的值，数字间用空格隔开。 输出格式：每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用1个空格隔开，但一行中最后一个数字后没有空格。 输入样例： 6 3 5 6 7 8 11 输出样例： 7 6 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int cmp(int a, int b) &#123; return a &gt; b;&#125;int main() &#123; int n; cin &gt;&gt; n; int *a = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; a[i]; &#125; int t; sort(a, a + n, cmp); for (int i = 0; i &lt; n; ++i) &#123; t = a[i]; while (t != 1 &amp;&amp; t != 999) &#123; if (t % 2 == 0) &#123; t = t / 2; &#125; else &#123; t = (t * 3 + 1) / 2; &#125; for (int j = 0; j &lt; n; ++j) &#123; if (t == a[j] &amp;&amp; j != i) a[j] = 999; &#125; &#125; &#125; sort(a, a + n, cmp); int temp = 0; for (int k = n - 1; k &gt;= 0; --k) &#123; if (a[k] != 999) temp = k; &#125; for (int l = temp; l &lt; n - 1; ++l) &#123; cout &lt;&lt; a[l] &lt;&lt; " "; &#125; cout &lt;&lt; a[n - 1]; delete[] a; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2F2018%2F03%2F22%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[计算机网络第 一 章 概述本章的重要概念 计算机网络（可简称为网络）把许多计算机连接在一起，而互联网则把许多网络连接在一起，是网络的网络。Internet 第是世界上最大的互联网。 以小写字母 i 开始的 internet （互联网或互连网）是通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。 以大写字母 I 开始的 Internet （因特网）是专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用 TCP/IP 协议族作为通信规则，且其前身是美国的 APPANET。 因特网现在采用存储转发的分组交换技术，以及三层因特网服务提供者（ISP）结构。 因特网按工作方式可划分为边缘部分与核心部分。主机在网络的边缘部分，其作用是进行信息处理。路由器在网络的核心部分，其作用是按存储转发方式进行分组交换。 计算机通信是计算机中的进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式和对等连接方式（P2P方式）。 客户和服务器都是指通信中所涉及的两个应用进程。客户是服务请求方，服务器是服务提供方。 按作用范围的不同，计算机网络分为广域网 WAN、城域网 MAN、局域网 LAN 和 个人局域网 PAN。 计算机网络最常用的性能指标是：速率、带宽、吞吐量、时延（发送时延、传播时延、处理时延、排队时延）、时延带宽积、往返时间和信道（或网络）利用率。 网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层及其协议的集合，称为网络的体系结构。 五层协议的体系结构由应用层、运输层、网络层（或网际层）、数据链路层和物理层组成。运输层最重要的协议是传输控制协议 TCP 和用户数据报协议 UDP， 而网络层最重要的协议是网际协议 IP。 第 二 章 物理层本章的重要概念 物理层的主要任务就是确定与传输媒体的接口有关的一些特性，如机械特性、电气特性、功能特性和过程特性。 一个数据通信系统可划分为三大部分，即源系统、传输系统和目的系统。源系统包括源点（或源站、信源）和发送器，目的系统包括接收器和终点（或目的站、或信宿）。 通信的目的是传送消息，如语音、文字、图像、视频等都是消息。数据是运送消息的实体。信号则是数据的电气或电磁的表现。 根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。代表数字信号不同离散数值的基本波形称为码元。 根据双方信息交互方式的不同，通信可以划分为单向通信（或单工通信）、双向交替通信（或半双工通信）和双向同时通信（或全双工通信）。 来自信源的信号叫做基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅、调频和调相。还有更复杂的调制方法，如正交振幅调制。 要提高数据在信道上的传输速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能总是被任意地提高。 传输媒体可分为两大类，即导引型传输媒体（双绞线、同轴电缆或光纤）和非导引型传输媒体（无线或红外或大气激光）。 常用的信道复用技术有频分复用、时分复用、统计时分复用、码分复用和波分复用（光的频分复用）。 最初在数字传输系统中使用的传输标准是脉冲编码调制 PCM。现在高速的数字传输系统使用同步光纤网 SONET（美国标准）或同步数字系列 SDH （国际标准）。 用户到因特网的带宽接入方法有非对称数字用户线 ADSL（用数字技术对现有的模拟电话用户线进行改造）、光纤同轴混合网 HFC（在有线电视网的基础上开发的）和 FTTx（即光纤到…）。 为了有效地利用光纤资源，在光纤干线和用户之间广泛使用无缘光网络 PON。无源光网络无须配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络 EPON 和吉比特无源光网络 GPON。 第 三 章 数据链路层本章的重要概念 链路是从一个结点到相邻结点的一段物理线路，数据链路则是在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）。 数据链路层使用的信道主要有点对点信道和广播信道两种。 数据链路层传送的协议数据单元是帧。数据链路层的三个基本问题则是：封装成帧，透明传输和差错检测。 循环冗余检验 CRC 是一种检错方法，而帧检验序列 FCS 是添加在数据后面的冗余码。 点对点协议 PPP 是数据链路层使用的最多的一种协议，它的特点是：简单；只检测差错，而不是纠正差错；不使用序号，也不进行流量控制；可同时支持多种网络层协议。 PPPoE 是为宽带上网的主机使用的链路层协议。 局域网的优点是：具有广播功能，从一个站点可根据方便地访问全网；便于系统的扩展和逐渐地演变；提高了系统的可靠性、可用性和生存性。 共享通信媒体资源的方法有二：一是静态划分信道（各种复用技术），而是动态媒体借入控制，又称为多点接入（随机接入或受控接入）。 IEEE 802 委员会曾把局域网的数据链路层拆成两个子层，即逻辑链路控制（LLC）子层（与传输媒体无关）和媒体接入控制（MAC）子层（与传输媒体有关）。但现在 LLC 子层已成为历史。 计算机与外界局域网的通信要通过通信适配器，它又称为网络接口卡或网卡。计算机的硬件地址就在适配器的 ROM 中。 以太网采用的协议是具有冲突检测的载波监听多点接入 CSMA/CD。协议的要点是：发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。因此，每一个站在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。以太网上各站点都平等地争用以太网信道。 目前的以太网基本上都是使用集线器的双绞线以太网。这种以太网在物理上是星形网，但在逻辑上则是总线形网。集线器工作在物理层，它的每个接口仅仅简单地转发比特，不进行碰撞检测。 以太网的硬件地址，即 MAC 地址实际上就是适配器地址或适配器标识符，与主机所在地点无关。源地址和目的地址都是 48 位长。 以太网的适配器具有过滤功能，它只接收单波帧，或广播帧，或多播帧。 使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络）。 使用网桥可以在数据链路层扩展以太网（扩展后的以太网仍然是一个网络）。网桥在转发帧时，不改变帧的源地址。网桥的优点是：对帧进行转发和过滤，增大吞吐量；扩大了网络物理范围；提高了可靠性；可互连不同的物理层、不同 MAC 子层和不同速率的以太网。网桥的缺点是：增加了时延；可能会产生广播风暴。 交换式集线器常称为以太网交换机或二层交换机（工作在数据链路层）。它就是一个多接口的网桥，而每个接口都是直接与某台单主机或另一个集线器相连，且工作在双全工方式。以太网交换机能同时连通许多对的接口，使每一对相互通信的主机都能想独占通新媒体那样，无碰撞的传输数据。 高速以太网有 100 Mb/s 的快速以太网，吉比特以太网和 10 Gb/s 的10 吉比特以太网。最近还发展到 100 吉比特以太网。在宽带接入技术中，也常使用以太网进行接入。 第 四 章 网络层本章重要概念 TCP/IP 体系中的网路层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组可能出错、丢失、重复和失序。进程之间的通信的可靠性由运输层负责。 IP 网是虚拟的，因为从网络层上看，IP 网好像是一个统一的、抽象的网络（实际上是异构的）。IP 层抽象的互联网屏蔽了下层网络很复杂的细节，使我们能够使用统一的、抽象的 IP 地址处理主机之间的通信问题。 在互联网上的交付有两种：在本网络上的直接交付（不经过路由器）和其他网络的间接交付（经过至少一个路由器，但最后一次一定是直接交付）。 一个 IP 地址在整个因特网范围内唯一的。分类 IP 地址包括 A 类、B 类和 C 类地址（单播地址），以及 D 类地址（多播地址）。E 类地址未使用。 分类的 IP 地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别位指明 IP 地址的类别。 IP 地址是一种分等级的地址结构。IP 地址管理机构在分配 IP 地址时只分配网络号，而主机号则由得到该网络号的单位自行分配。路由器仅根据目的主机所连接的网络号转发分组 IP 地址标志一台主机（或路由器）和一条链路的接口。多归属主机同时连接到两个或更多的网络上。这样的主机同时具有两个或更多的 IP 地址，其网络号必须是不同的。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的 IP 地址。 按照因特网的观点，用转发器或网桥连接起来的若干个局域网仍为一个网络。所有分配到网络号的网络（不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网）都是平等的。 物理地址（即硬件地址）是数据链路层和物理层使用的地址，而 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址（用软件实现的），在数据链路层看不见数据报的 IP 地址。 IP 数据报分为首部和数据两部分，首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的（源地址、目的地址】总长度等重要字段都在固定首部中）。一些长度可变的可选字段放在固定首部的后面。 IP 首部中的生存时间字段给出了 IP 数据报在因特网中所能经过的最大路由器数，可防止 IP 数据报在互联网中无限制的兜圈子。 地址解析协议 ARP 把 IP 地址解析为硬件地址，它解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。ARP 的告诉缓存可以大大减少网络上的通信量。 在因特网中，我们无法仅根据硬件地址寻找到在某个网络上的某台主机。因此，从 IP 地址到硬件地址的解析是非常必要的。 无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好方法。CIDR 记法把 IP 地址后面加上斜线 “/”，然后写上前缀所占的位数。前缀（或网络前缀）用来指名网络，前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的 IP 地址组成一个 “CIDR 地址块”。IP 地址的分配都以 CIDR 地址块为单位。 CIDR 的 32 位地址掩码（或子网掩码）由一串 1 和一串 0 组成，而 1 的个数就是前缀的长度。只要把 IP 地址和地址掩码逐位进行 “逻辑与（AND）”运算，就很容易得出网络地址。A 类地址的默认地址掩码是 255.0.0.0 。B 类地址的默认地址掩码是 255.255.0.0 。C 类地址的默认地址掩码是 255.255.255.0 。 路由聚合（把许多前缀相同的地址用一个来代替）有利于减少路由表中的项目，减少路由器之间的路由选择信息的交换，从而提高了整个因特网的性能。 “转发” 和 “路由选择” 有区别。“转发” 是单个路由器的动作。“路由选择” 是许多路由器共同协作的过程，这些路由器 相互交换信息，目的是生成路由表，再从路由表导出转发表。若采用自适应路由选择算法，则当网络拓扑变化时，路由表和转发表都能够自动更新。在许多情况下，可以不考虑转发表和路由表的区别，而都使用路由表这一名词。 自治系统（AS）就是在单一的技术管理下的一组路由器。一个自治系统对其他自治系统表现出的是一个单一的和一致的路由选择策略。 路由选择协议有两大类：内部网关协议（或自治系统内部的路由选择协议），如 RIP 和 OSPF；外部网关协议（或自治系统之间的路由选择协议），如 BGP-4。 RIP 是分布式的基于距离向量的路由选择协议，只适用于小型互联网。RIP 按固定的时间间隔与相邻路由器交换信息。交换信息是自己当前的路由表，即到达本自治系统中所有网络的（最短）距离，以及到每个网络应经过的下一跳路由器。 OSPF 是分布式的链路状态协议，适用于大型互联网。OSPF 只在链路状态发生变化时，才用向本自治系统中的所有路由器，用洪泛法发送与本路由器相邻的所有路由器的链路状态信息。“链路状态” 指明本路由器都和哪些路由器相邻，以及该链路的 “度量”。“度量” 可表示费用、距离、时延、带宽等，可统称为 “代价”。所有的路由器最终都能建立一个全网的拓扑结构图。 BGP-4 是不同 AS 的路由器之间交换路由信息的协议，是一种路径向量路由选择协议。BGP 力求寻找一条能够到达目的网络（可达）且比较好的路由（不兜圈子），而并非要寻找一条最佳路由。 网际控制报文协议 ICMP 是 IP 层的协议。ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去。使用 ICMP 并不是实现了可靠传输。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。 ICMP 的一个重要应用就是分组网间探测 PING，用来测试两台主机之间的连通性。PING 使用了 ICMP 回送请求与回送回答报文。 与单播相比，在一对多的通信中， IP 多播可大大节约网络资源。IP 多播使用 D 类 IP 地址。IP 多播需要使用网际组织管理协议 IGMP 和多播路由选择协议。 虚拟专用网 VPN 利用公用的因特网作为本机构各专用网之间的通信载体。VPN 内部使用因特网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过因特网进行通信。所有通过因特网传送的数据都必须加密。 使用网络地址转换 NAT 技术，可以在专用网络内部使用专用 IP 地址，而仅在连接到因特网的路由器使用全球 IP 地址。这样就大大节约了宝贵的 IP 地址。 第 五 章 运输层本章的重要概念 运输层提供提供应用进程间的逻辑通信，也就是说，运输层的通信并不是真正在两个运输层之间直接传送数据。运输层向应用层屏蔽了下面网络的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。 网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。 运输层有两个主要的协议：TCP 和 UDP。它们都有复用和分用，以及检错的功能。当运输层采用面向连接的 TCP 协议时，尽管下面的网络层是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工通信的可靠信道。当运输层采用无连接的 UDP 协议时，这种逻辑通信信道仍然是一条不可靠信道。 运输层用一个 16 位端口号来标志一个端口。端口号只具有本地意义，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在因特网的不同计算机中，相同的端口号是没有关联的。 两台计算机中的进程要互相通信，不仅要知道对方的 IP 地址（为了找到对方的计算机），而且还要知道对方的端口号（为了找到对方计算机中的应用进程）。 运输层的端口号分为服务器端使用的端口号（0 ～ 1023 指派给熟知端口，1024 ～ 49151 是登记端口号）和客户端暂时使用的端口号（49152 ～ 65535）。 UDP 的主要特点是：（1）无连接；（2）尽最大努力交付；（3）面向报文；（4）无拥塞控制；（5）支持一对一、一对多、多对一和多对多的交互通信；(6）首部开销小（只有四个字段：源端口、目的端口、长度、检验和）。 TCP 的主要特点是：（1）面向连接；（2）每一条 TCP 连接只能是点对点的（一对一）；（3）提供可靠交付的服务；（4）提供全双工通信；（5）面向字节流。 TCP 用主机的 IP 地址加上主机上的端口号作为 TCP 连接的端点。这样的端点就叫做套接字（Socket）或插口。套接字用（IP 地址：端口号）来表示。 停止等待协议能够在不可靠的传输网络上实现可靠的通信。每发送完一个分组就停止发送，等待对方确认。在收到确认后再发送下一个分组。分组需要进行编号。 超时重传是指只要超过了一段时间仍然没有收到确认，就重传前面发送过的的分组（认为刚才发送的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。 在停止等待协议中，若接收方收到重复分组，就丢弃该分组但同时还要发送确认。 连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已正确收到了。 TCP 报文段首部的前 20 个字节是固定的，后面有 4N 字节是根据需要而增加的选项（N 是整数）。在一个 TCP 连接中传送的字节流中每一个字节都按顺序编号。首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号。 TCP 首部中的确认号是期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 N，则表明：到序号 N - 1 为止的所有数据都已正确收到。 TCP 首部中的窗口字段指出了现在允许对方发送的的数据量。窗口值是经常在动态变化着的。 TCP 使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到了确认，而发送窗口前沿的前面部分表示不允许发送的。发送窗口后沿的变化情况有两种可能，即不动（ 没有收到新的确认）和前移（收到了新的确认）。发送窗口前沿通常是不断向前移动的。 流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。 在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做拥塞。拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。 流量控制是一个端到端的问题，是接收端抑制发送端发送数据的速率，以便使接收端来得及接收。拥塞控制是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 为了进行拥塞控制，TCP 的发送方要维持一个拥塞窗口 cwnd 的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态的在变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。 TCP 的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层，也可以使路由器采用适当的分组丢弃策略（（如随机早期检测 RED），以减少网络拥塞的发生。 运输连接有三个阶段，即：连接建立，数据传送和连接释放。 主动发起 TCP 的连接建立的应用进程叫做客户，而被动等待建立的应用进程叫做服务器。TCP 的连接建立采用三次握手机制。服务器要确认客户的连接请求，然后客户要对服务器的确认进行确认。 TCP 的连接释放采用四次握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后就进入半关闭状态。方另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了 TCP 连接。 第 六 章 应用层本章重要概念 应用层协议是为了解决某一类应用问题，而问题的解决又是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。应用层规定了应用进程在通信时所遵循的协议。应用层的许多协议都是基于客户服务器方式的。客户是服务请求方，服务器是服务提供方。 域名系统 DNS 是因特网使用的命名系统，用来把便于人们使用的机器名字转换为 IP 地址。DNS 是一个联机分布式数据库系统，并采用客户服务器方式。 域名到 IP 地址的解析是由分布在因特网上的许多域名服务器程序（即域名服务器）共同完成的。 因特网采用层次树状结构的命名方法，任何一台连接在因特网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。域名中的点和点分十进制 IP 地址中的点没有关系。 域名服务器分为根域名服务器、顶级域名服务器、权限域名服务器和本地域名服务器。 文件传送协议 FTP 使用 TCP 可靠的运输服务。FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。在进行文件传输时，FTP 的客户和服务器之间要建立两个并行的 TCP 连接：控制连接和数据连接。实际用于传输文件的是数据连接。 万维网 WWW 是一个大规模的、联机式的信息储藏所，可以非常方便地从因特网上的一个站点链接到另一个站点。 万维网的客户程序向因特网中的服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。在客户程序主窗口上显示出的万维网文档称为页面。 万维网使用统一资源定位符 URL 来标志万维网上的各种文档，并使每一个文档在整个因特网的范围内具有唯一的标识符 URL。 万维网客户程序与服务器程序之间进行交互所使用的协议是超文本传输协议 HTTP。HTTP 使用 TCP 连接进行可靠地传送。但 HTTP 协议本身是无连接、无状态的。HTTP/1.1 协议使用了持续连接（分为非流水线方式和流水线方式）。 万维网使用超文本标记语言 HTML 来显示各种万维网页面。 万维网静态文档是指在文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程中，内容不会改变。动态文档是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建。 活动文档技术可以使浏览器屏幕连续更新。活动文档程序可与用户直接交互，并可连续地改变屏幕的显示。 在万维网中用来进行搜索的工具叫做搜索引擎。搜索引擎大体上可划分为全文检索搜索引擎和分类目录搜索引擎两大类。 电子邮件是因特网上使用最多的和最受用户欢迎的的一种应用。电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮箱服务器进行读取。相当于 “电子信箱”。 一个电子邮件系统有三个主要组成构件，即：用户代理、邮件服务器，以及邮件协议（包括邮件发送协议，如 SMTP ，和邮件读取协议，如 POP3 ）。用户代理和邮件服务器都要运行这两种协议。 电子邮件的用户代理就是用户与电子邮件系统的接口，它向用户提供一个很友好的视窗界面来发送和接受邮件。 从用户代理把邮件传送到邮件服务器，以及在邮件服务器之间的传送，都要使用 SMTP 协议。但用户代理从邮件服务器读取邮件时，则要使用 POP3 （或 IMAP）协议。 基于万维网的电子邮件使用户能够利用浏览器收发电子邮件。用户浏览器和邮件服务器之间的邮件传送使用 HTTP 协议，而在邮件服务器之间邮件的传送仍然使用 SMTP 协议。 简单网络管理协议 SNMP 由三部分组成，即： 1. SNMP 本身，负责读取和改变各代理中的对象名及其状态数值。 2. 管理信息结构 SMI，定义命名对象和定义对象类型（包括范围和长度）的通用规则，以及把对象和对象的值进行编码的基本编码规则 BER。 3. 管理信息库 MIB，在被管理的实体中创建了命名对象，并规定了其类型。 系统调用接口是应用进程的控制权和操作系统的控制权进行转换的一个接口，又称为应用编程接口 API。API 就是应用程序和操作系统之间的接口。 套接字是应用进程和运输层协议之间的接口，是应用进程为了获得网络通信服务而与操作系统进行交互时使用的一种机制。 第 七 章 网络安全本章重要概念 计算机网络上的通信面临的威胁可分为两大类，即被动攻击（如截获）和主动攻击（如中断、篡改、伪造）。主动攻击的类型有更改报文流、拒绝服务、伪造初始化、恶意程序（病毒、蠕虫、木马）等。 计算机网络安全主要有以下一些内容：保密性、安全协议的设计和访问控制。 密码编码学是密码体制的设计学，而密码分析学则是在未知密钥的情况下从密文推演出明文或密钥的技术。密码编码学与密码分析学结合起来即为密码学。 如果不论截取者获得了多少密文，都无法唯一地确定出对应的明文，则这一密码体制称为无条件安全的（或理论上是不可破的）。在无任何限制的条件下，目前几乎所有实用的密码体制均是可破的。如果一个密码体制中的密码不能在一定时间内被可以使用的计算资源破译，则这一密码体制称为在计算上是安全的。 对称密钥密码体制是加密密钥与解密密钥相同的密码体制（如数据加密标准 DES 和国际数据加密算法 IDEA）。这种加密的保密性仅取决与对密钥的保密，而算法是公开的。 公钥密码体制（又称为公开密钥密码体制）使用不同的加密密钥与解密密钥。加密密钥（即公钥）是向公众公开的，而解密密钥（即私钥或密钥）则是需要保密的。加密算法和解密算法也都是公开的。 目前最著名的公钥密码体制是 RSA 体制，它是基于数论中的大数分解问题的体制。 任何加密方法的安全性取决与密钥的长度，以及攻破密文所需要的计算量，而不是简单地取决与加密的体制（公钥密码体制或传统加密体制）。 数字签名必须保证能够实现以下三点功能： 1. 报文鉴别，即接收者能够核实发送者对报文的签名； 2. 报文的完整性，即接收者确信所能收到到数据和发送者发送的完全一样而没有被篡改过； 3. 不可否认，即发送者事后不能抵赖对报文的签名。 鉴别是要验证通信的对方的确是自己所要通信的对象，而不是其他的冒充者。鉴别与授权是不同的概念。 报文摘要 MD 是进行报文鉴别的一种简单方法。目前广泛使用的是 MD5 。 密钥管理包括：密钥的产生、分配、注入、验证和使用。密钥分配（或密钥分发）是密钥管理中最大的问题。密钥必须通过最安全的通路进行分配。目前常用的密钥分配方式是设立密钥分配中心 KDC。 认证中心 CA 是一个值得信赖的机构，用来将公钥与其对应的实体（人或机器）进行绑定。每个实体都有 CA 发来的证书，里面有公钥及其拥有者的标识信息（人名或 IP 地址）。此证书被 CA 进行了数字签名。任何用户都可从可信的地方获得认证中心 CA 的公钥。 在网络层使用安全协议 IPsec 支持，它包括鉴别首部协议 AH 和封装安全有效载荷协议 ESP。AH 协议提供源点鉴别和数据完整性，但不能保密。而 ESP 协议提供源点鉴别、数据完整性和保密。IPsec 支持 IPv4 和 IPv6。在 IPv6 中，AH 和 ESP 都是都是扩展首部的一部分。IPsec 数据报的工作方式有运输方式和隧道方式。 运输层的安全协议有 SSL （安全套接字层）和 TLS （运输层安全）。SSL 最新的版本是 SSL 3.0 ，它是保护万维网 HTTP 通信量公认的事实上的标准。SSL 不仅被所有常用的浏览器和万维网服务器所支持，而且也是 TLS 的基础。 PGP 是一个完整的电子邮件安全软件包，包括加密、鉴别、电子签名和压缩等技术。PGP 并没有使用什么新的概念，它只是把现有的一些加密算法（如 RSA 公钥加密算法或 MD5 报文摘要算法）综合在一起而已。 防火墙是一种特殊编程的路由器，安装在一个网点和网络的其余部分之间，目的是实施访问控制策略。防火墙里面的网络称为 “可信的网络”，而把防火墙外面的网络称为 “不可信的网络”。防火墙的功能有两个：一个是阻止（主要的），另一个是允许。 防火墙技术分为：网络级防火墙，用来防止整个网络出现外来非法的入侵（属于这类的有分组过滤和授权服务器）；应用级防火墙，用来进行访问控制（用应用网关或代理服务器来区分各种应用）。 入侵检测系统 IDS 是在入侵已经开始，但还没有造成危害或在造成更大危害前，及时检测到入侵，以便尽快阻止入侵，把危害降低到最小。 第 九 章 无线网络和移动网络本章的重要概念 无线局域网可分为两大类。第一类是有固定基础设施的，第二类是无固定基础设施的。 无线局域网的标准是 IEEE 的 802.11 系列。使用 802.11 系列协议的局域网又称为 Wi-Fi 。 802.11 无线以太网标准使用星形拓扑，其中心叫做接入点 AP ，它就是基本服务集内的基站。 应当弄清几种不同的接入：固定接入、移动接入、便携接入和游牧接入。 802.11 无线以太网在 MAC 层使用 CSMA/CA 协议。不能使用 CSMA/CD 的原因是：在无线局域网中，并非所有的站点都能够听见对方（例如，当有障碍物出现在站点之间时），因此无法实现碰撞检测。使用 CSMA/CA 协议是为了尽量减小碰撞发生的概率。 802.11 无线局域网在使用 CSMA/CA 的同时，还使用停止等待协议。 802.11 标准规定，所有的站在完成发送后，必须再等待一段帧间间隔时间才能发送下一帧。帧间间隔的长短取决于该站要发送的帧的优先级。 在 802.11 无线局域网的 MAC 帧首部中有一个持续期字段，用来填入在本帧结束后还要占用信道多少时间（以微秒为单位）。 802.11 标准允许要发送数据的站对信道进行预约，即在发送数据帧之前先发送 RTS 帧请求发送。在收到响应允许发送的 CTS 帧后，就可发送数据帧。 802.11 的 MAC 帧共有三种类型，即控制帧、数据帧和管理帧、需要注意的是，MAC 帧有四个地址字段。再有固定基础设施的无线局域网中，只使用其中的三个地址字段，即源地址、目的地址和 AP 地址。 几种无线网络简介：无线个人区域网（蓝牙系统、ZigBee 和超高速 WPAN）。无线城域网 WiMAX。 当计算机移动到外地时，移动 IP 技术允许该计算机仍然保留其原来的 IP 地址。移动 IP 使用了一些新概念，如永久地址，或归属地址、归属网络；被访问或外地网络；归属代理、外地代理；转交地址、同址转交地址等。 移动 IP 使用了几种协议，如移动站到外地代理的协议，外地代理到归属代理的登记协议，归属代理数据报封装协议，外地代理拆封协议等。 移动 IP 的路由器选择有间接路由选择和直接路由选择，后者需要使用通信者代理和锚外地代理。 蜂窝移动通信网中对移动用户的路由选择需要弄清一些概念：归属位置寄存器 HLR 和来访用户位置寄存器 VLR，移动站漫游号码 MSRN，归属网络交换中心，归属 MSC，锚 MSC，被访网络的 MSC。 第 十 章 下一代因特网本章的重要概念 要解决 IP 地址耗尽的问题，最根本的办法就是采用具有更大地址空间的新版本的 IP 协议，即 IPv6. IPv6 所带来的主要变化是： 1. 更大的地址空间（采用 128 位的地址）； 2. 灵活的首部格式； 3. 改进的选项； 4. 支持即插即用； 5. 支持资源的预分配； 6. IPv6 首部改为 8 字节对齐； IPv6 数据报在基本首部的后面允许有零个或多个扩展首部，再后面是数据。所有的扩展首部和数据合起来叫做数据报的有效的有效载荷或净负荷。 IPv6 数据报的目的地址可以是以下三种基本类型地址之一：单播、多播和任播。 IPv6 的地址使用冒号十六进制记法。 向 IPv6 过渡只能采用逐步演进的办法，必须使新安装的 IPv6 系统能够向后兼容。向 IPv6 过渡可以使用双协议栈或使用隧道技术。 MPLS 的特点： 1. 支持面向连接的服务质量。 2. 支持流量工程，平衡网络负载。 3. 有效地支持虚拟专用网 VPN。 MPLS 在入口结点给每一 IP 数据报打上固定长度的 “标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记对换），因而转发速率大大加快。 目前 P2P 工作方式下的文件共享在因特网流量中已占据最大的份额，比万维网应用所占的比例大得多。 BT 是很流行的一种 BT 应用。BT 采用“最稀罕的优先”的技术，可以尽早把最稀罕的文件块收集到。此外，凡当前以最高数据率向某个对等方传送文件块的相邻对等方，该对等方就优先把所请求的文件块传送给这些相邻对等方。这样做的结果是，这些对等方相互之间都能够以令人满意的速率交换文件块。当对等方的数量很大时，采用 P2P 方式下载大文件，要比传统的客户-服务器方式快的多。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在 Ubuntu 中关闭触摸板]]></title>
    <url>%2F2018%2F03%2F22%2F%E5%9C%A8Ubuntu%E4%B8%AD%E5%85%B3%E9%97%AD%E8%A7%A6%E6%91%B8%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[1sudo rmmod psmouse 禁用触摸板 1sudo modprobe psmouse 启用触摸板]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五大常用算法：分支限界法]]></title>
    <url>%2F2018%2F03%2F22%2F%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、基本描述 类似于回溯法，也是一种在问题的解空间树 T 上搜索问题解的算法，但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是则是找出满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。 - 分支搜索算法 所谓“分支”就是采用广度优先的策略，一次搜索E-节点的所有分支，也就是所有相邻节点，抛弃不满足约束条件的节点，其余节点加入活节点表。然后从表中选择一个节点作为下一个E-节点，继续搜索。 选择下一个E-节点的方式不同，则会有几种不同的分支搜索方式。 FIFO 搜索 LIFO 搜索 优先队列式搜索 二、分支限界法的一般过程 由于求解目标不同，导致分支限界法与回溯法在解空间树 T 上的搜索方式也不相同。回溯法以深度优先的方式搜索解空间树Ｔ，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树Ｔ。 分支限界法的搜索策略是：在扩展节点处，先生成其所有的儿子节点（分支），然后再从当前的活节点表中选择下一个扩展节点，为了有效地选择下一扩展节点，以加速搜索的进程，在每一活节点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活节点表中选择一个最有利的的节点作为扩展节点，使搜索朝着解空间树上最优解的分支推进，以便尽快地找出一个最优解。 分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。问题的解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树，在搜索问题的解空间树时，分支限界法与回溯法对当前扩展节点所使用的扩展方式不同。在分支限界法中，每一个活节点只有一次机会称为扩展节点。活节点一旦成为扩展节点，就一次性产生其所有儿子节点。在这些儿子节点中，那些导致不可行解或导致非最优解的儿子节点被舍弃，其余儿子节点被加入活节点表中。此后，从活节点表中取下一节点成为当前扩展节点，并重复上述节点扩展过程。这个过程一直持续到找到所有求的解或活节点表为空时为止。 三、回溯法和分支限界法的一些区别 有一些问题其实无论用回溯法还是分支限界法都可以得到很好的解决，但是另外一些则不然。也许我们需要具体一些的分析——到底何时使用分支限界而何时使用回溯法呢？ 回溯法和分支限界法的一些区别： 方法对解空间树的搜索方式 储存节点的常用数据结构 节点储存特性常用应用 回溯法深度优先搜索堆栈活节点的所有可行子节点被遍历后才被从栈中弹出，找出满足约束条件的所有解 分支限界法广度优先或最小消耗优先搜索队列 ，优先队列每个节点只有一次成为活节点的机会找出满足约束条件的一个解或特定意义下的最优解]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>分支限界法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五大常用算法：动态规划]]></title>
    <url>%2F2018%2F03%2F22%2F%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[一、基本概念 动态规划过程是：每次决策依赖于当前状态，有随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。 二、基本思路及策略 基本思想于分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。 由于动态规划解决的问题多数有重叠子问题这一特点，为了减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个数组中。 与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是相互独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。 三、适用的情况 能采用动态规划求解的问题的一般要具有三个性质： 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势） 四、求解的基本步骤 动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线（通常是求解最优的活动路线）。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤： 1初始状态-&gt; 结束状态 : -&gt; 决策1 -&gt; 决策2 -&gt;...-&gt; 决策n -&gt; 划分阶段：按照问题的时间或空间特征，把问题分为若干阶段。在划分阶段时，注意划分后的阶段一定要是要有序的或者是可排序的，否则问题就无法求解。 确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。 确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。 寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。 一般，只要解决问题的阶段，状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。 实际应用中可以按以下几个简化的步骤进行设计： 分析最优解的性质，并刻画其结构特征。 递归的定义最优解。 已自底向上或自顶向下的记忆化方式（备忘录法）计算出最优解。 根据计算最优值时得到的信息，构造问题的最优解。 五、算法实现的说明 动态规划的主要难点在于理论上的设计，也就是上面四个步骤的确定，一旦设计完成，实现部分就会非常简单。 使用动态规划求解问题，最重要的就是确定动态规划三要素： 问题的阶段 每个阶段的状态 从前一个阶段转化到后一个阶段之间的递推关系。 递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以利用递推程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。 确定了动态规划的这三个要素，整个求解过程就可以用一个最优决策表来描述，最有决策表是一个二维表，其中行表示决策的阶段，列表是问题状态，表格需要填写的数据一般对应此问题的在某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从 1 行 1 列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。 f(n, m) = max { f(n - 1, m), f(n - 1, m - w[n]) + P(n, m)}]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五大常用算法：贪心算法]]></title>
    <url>%2F2018%2F03%2F22%2F%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%EF%BC%9A%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、基本概念所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。 贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择贪心策略必须具备无后效性，即某个状态以后的过程中不会影响以前的状态，只与当前状态有关。 所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。 二、贪心算法的基本思路 建立数学模型来描述问题。 把求解的问题分成若干个子问题。 对每一子问题求解，得到子问题的局部最优解。 把子问题的解局部最优解合成原来问题的一个解。 三、贪心算法适用的问题贪心策略适用的前提是：局部最优解策略能导致产生全局最优解。 实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。 四、贪心算法的实现框架从问题的某一初始解出发； while (能朝给定总目标前进一步) { 利用可行的决策，求出可行解的一个解元素； } 由所有解元素组合成问题的一个可行解； 五、贪心策略的选择因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。 六、例题解析 下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。 [背包问题] 有一个背包，背包容量是 M = 150，有 7 个物品，物品可以分割成任意大小。 要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。 物品 A B C D E F G重量 35 30 60 50 40 10 25价值 10 40 30 50 35 40 30 分析： 目标函数：$\sum pi$ 最大 约束条件是装入的物品总重量不超过背包容量： $\sum wi &lt;= M ( M = 150)$ 根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？ 每次挑选所占重量最小的物品装入是否能得到最优解？ 每次选取单位重量价值最大的物品，成为解本题的策略。 值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。 贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。 可惜的是它需要证明后才能真正运用到题目的算法中。 一般来说，贪心算法的证明围绕着：整个问题的最优解一定在贪心策略中存在的子问题的最优解得来的。 对于例题中的 3 中贪心策略，都是无法成立的（ 无法被证明 ）的，解释如下： 贪心策略：选取价值最大者。 反例： W = 30物品： A B C重量： 28 12 12价值： 30 20 20 根据策略，首先选取物品 A，接下来就无法再选取了，可是，选取 B、C 则更好。 贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。 贪心策略：选取单位重量价值最大的物品。反例： W = 30物品：A B C重量：28 20 10价值：28 20 10 根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择 A，则答案错误。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五大常用算法：分治法]]></title>
    <url>%2F2018%2F03%2F22%2F%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%86%E6%B2%BB%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、基本概念 在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题解的合并。这个技巧是很多高效算法的基础，如排序算法（快速排序，归并排序），傅里叶变换（快速傅里叶变换）…… 任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于 n 个元素的排序问题，当 n = 1 时，不需要任何计算。n = 2 时，只要作一次比较即可排好序。n = 3 时只要作 3 次比较即可…… 。而当 n 较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。 二、基本思路及策略分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。 分治策略是：对于一个规模为 n 的问题，若该问题可以容易地解决（比如 n 规模较小）则直接解决，否则将其分解为 k 个规模较小的问题，这些子问题互相独立且与原问题形式相同，递归的解决这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。 如果原问题可以分割成 k 个子问题，1 &lt; k &lt;= n, 且这些子问题都可解并可以利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断减小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。 三、分治法适用的情况分治法所能解决的问题一般具有以下几个特征： 该问题的规模缩小到一定的程度就可以容易地解决 该问题可以分解为若干规模较小的相同问题，即该问题具有最优子结构性质 利用该问题分解出的子问题的解可以合并为该问题的解 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题 第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加； 第二条特征是应用分治法的前提，它也是大多数问题可以满足的，此特征反映了递归思想的应用； 第三条特征是关键，能否利用分治法完全取决于问题的是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。 第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解决公共的子问题，此时虽然可用分治法，但一般用动态规划较好。 四、分治法的基本步骤分治法在每一层递归上都有三个步骤： step 1 分解：将原问题分解为若干规模较小，相互独立，与原问题形式相同的子问题； step 2 解决：若子问题规模较小而容易被解决则直接求解，否则递归地解各个子问题； step 3 合并：将各个子问题的解合并为原问题的解。 五、可使用分治法求解的一些经典问题 二分搜索 大整数乘法 Strassen 矩阵乘法 棋盘覆盖 合并排序 快速排序 线性时间选择 最接近点对问题 循环赛日程表 汉诺塔 六、依据分治法设计程序时的思维过程实际上就是类似与数学归纳法，找到解决问题的求解方程式，然后根据方程式设计递归程序。 一定是先找到最小问题规模时的求解方法 然后考虑随着问题规模增大时的解决方法 找到求解的递归函数式后，设计递归程序即可]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五大常用算法：回溯法]]></title>
    <url>%2F2018%2F03%2F22%2F%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%EF%BC%9A%E5%9B%9E%E6%BA%AF%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、概念回溯算法实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。 回溯法是一种优选搜索法，按选优条件向前搜索，已到达目标。但当搜索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术称为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 许多复杂的，规模较大的的问题都可以使用回溯法，有“通用解题方法”的美称。 2、基本思想在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根节点出发深度搜索解空间树。当搜索到某一节点时，要先判断该节点是否包含问题的解，如果包含，就从该节点出发继续探索下去，如果该节点不包含问题的解，则逐层向其祖先节点回溯。（回溯法就是对隐式图的深度优先搜索算法）。 若用回溯法求问题的所有解时，要回溯到根，且根节点的所有可行的子树都要已被搜索遍才结束。 而若使用回溯法求人一个解时，只要搜索到问题的一个解就可以结束。 3、用回溯法解题的一般步骤 针对所给问题，确定问题的解空间： 首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。 确定节点的扩展搜索规则 以深度优先凡是搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。 4、算法框架 问题框架 设问题的解是一个n维向量（ a1，a2，…… ，an），约束条件是 ai（ i = 1，2，3，……，n ）之间满足某种条件，记为 f(ai)。 非递归回溯框架 1234567891011121314151617181920int a[n], i; // 初始化数组a[];i = 1;while (i &gt; 0 (有路可走) and (为达到目标)) &#123; // 还未回溯到头trueif (i &gt; n) &#123; // 搜索到叶节点truetrue搜索到一个解，输出。true&#125; else &#123; // 处理第i个节点truetruea[i]第一个可能的值；truetruewhile (a[i] 在不满足约束条件且在搜索空间内) &#123;truetruetruea[i]下一个可能的值；truetrue&#125;truetrueif (a[i] 在搜索空间内) &#123;truetruetrue标识占用的资源；truetruetruei = i + 1； // 扩展下一个节点truetrue&#125; else &#123;truetruetrue清理所占的状态空间； // 回溯truetruetruei = i - 1；truetrue&#125;true&#125;&#125; 递归的算法框架 回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中 i 为搜索的深度，框架如下： 123456789101112131415int a[n];try (int n) &#123;trueif (i &gt; n)truetrue输出结果；trueelse &#123;truetruefor (int j = 下界； j &lt;= 上界； j = j + 1) &#123;truetruetrueif (fun (j)) &#123;truetruetruetruea[i] = j;truetruetruetrue...truetruetruetruetry(i + 1)truetruetruetrue回溯前的清理工作(如 a[i] 置空值等)；truetruetrue&#125;truetrue&#125;true&#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux系统下用dd命令制作ISO镜像U盘启动盘]]></title>
    <url>%2F2018%2F03%2F22%2F%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%94%A8dd%E5%91%BD%E4%BB%A4%E5%88%B6%E4%BD%9CISO%E9%95%9C%E5%83%8FU%E7%9B%98%E5%90%AF%E5%8A%A8%E7%9B%98%2F</url>
    <content type="text"><![CDATA[首先在 Linux 系统中打开终端，确认 U 盘路径： 1sudo fdisk -l 格式化 U 盘，为了格式化首先需要 umount U 盘：/dev/sdb 是我的 U 盘设备。 1sudo umount /dev/sdb* 格式化 U 盘： 1sudo mkfs.vfat /dev/sdb -I 使用 dd 命令，格式如下： 1sudo dd if=xxx.iso of=U盘路径 完整示例： 1sudo dd if=~/images/ubuntu.iso of=/dev/sdb 向 sdb 磁盘写入位于～/images目录下的 ubuntu.iso 镜像文件 输完上述DD命令后回车执行，系统就开始制作启动盘了，期间终端命令窗口不会有任何反馈，但能通过U盘运行指示灯看到U盘在进行读写操作，这个过程可能持续5、6分钟才完成。当看到终端命令窗口有返回消息即制作完成。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 目录结构]]></title>
    <url>%2F2018%2F03%2F22%2FLinux_%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Linux 文件目录结构对于每一个Linux学习者来说，了解Linux文件系统的目录结构，是学好Linux的至关重要的一步.，深入了解Linux文件目录结构的标准和每个目录的详细功能，对于我们用好Linux系统至关重要，下面我们就开始了解一下Linux目录结构的相关知识。 当在使用Linux的时候，如果你通过ls -l / 就会发现，在 / 下包含很多的目录，比如etc、usr、var、bin 等目录，进入这些目录也会发现很多的目录或文件。我们把这种文件系统的结构称为树形结构。 文件系统是用来组织和排列文件存取的，所以我们可以通过 ls 等命令工具来查看其结构，在Linux系统中，我们见到的都是树形结构；比如操作系统安装在一个文件系统中，他表现为由 / 起始的树形结构。Linux文件系统的最顶端是 / ，我们称 / 为Linux的根目录，也就是Linux操作系统的文件系统。Linxu文件系统的入口就是 /，所有的目录，文件，设备都在 / 之下， / 就是Linux文件系统的组织者，也是最上级的领导者。 由于Linux是开放源代码，各大公司和团体根据Linux的核心代码做各自的操作，编程。这样就造成根下的目录不同。这样就造成个人不能使用他人的Linux系统的PC。因为你根本不知道一些基本的配置，文件在哪里。。。这就造成了混乱。这就是FHS（Filesystem Hierarchy Standard ）机构诞生的原因。该机构是Linux爱好者自发组成的一个团体，主要是是对Linux做一些基本的要求，不至于是操作者换一台主机就成了Linux的‘文盲’。 根据FHS(http://www.pathname.com/fhs/)的官方文件指出， 他们的主要目的是希望让使用者可以了解到已安装软件通常放置于那个目录下， 所以他们希望独立的软件开发商、操作系统制作者、以及想要维护系统的用户，都能够遵循FHS的标准。 也就是说，FHS的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。 这样做好处非常多，因为Linux操作系统就能够在既有的面貌下(目录架构不变)发展出开发者想要的独特风格。 事实上，FHS是根据过去的经验一直再持续的改版的，FHS依据文件系统使用的频繁与否与是否允许使用者随意更动， 而将目录定义成为四种交互作用的形态，用表格来说有点像底下这样： 四种类型：1.可分享的： 可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据，是能够分享给网络上其他主机挂载用的目录； 2.不可分享的： 自己机器上面运作的装置文件或者是与程序有关的socket文件等，由于仅与自身机器有关，所以不适合分享给其他的主机； 3.不变的： 有些数据是不会经常变动的，跟随着distribution而不变动。例如函式库，文件说明文件。系统管理员所管理的主机服务配置文件等等； 4.可变动的： 经常改变的数据，例如登陆文件，一般用户可自行收受的新闻组等。 事实上，FHS正对目录树架构仅定义出三层目录底下应该放置什么数据而已： / (root,根目录)：与开机系统有关；/usr (unix software resource)：与软件安装/执行有关；/var (variable)：与系统运作过程有关。 一.根目录( / )的意义与内容：根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的，同时根目录与开机/还原/系统修复等动作有关。由于系统开机时需要特定的开机软件，核心文件，开机所需程序，函式库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。因为根目录非常重要，所以在FHS的要求方面，他希望根目录下不要放在非常大的分区，因为越大的分区内你会放入越多的数据，如此一来根目录所在分区就可能会有较多的发生错误的机会。 因此FHS标准建议：根目录(/)所在分区应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。 如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。说白了，就是根目录和Windows的C盘一个样。 根据以上原因，FHS认为根目录下应该包含以下子目录： 目录 应放置档案内容 /bin 系统有很多放置执行文档的目录，但/bin比较特殊。因为/bin放置的是单人维护模式下还能够被操作的指令。在/bin底下的指令可以被root与普通用户所使用，主要有: ls, cd, pwd, cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的命令。 /boot 主要放置开机会使用的档案，包括Linux核心档案以及开机所需设定文档等。Linux kernel常用的文档名为: vmlinuz，如果使用的是grub这个开机管理程序，则还会存在/boot/grub 这个目录。 /dev 在linux系统上，任何装置与周边设备都是以文档的形式存在于这个目录当中。只要通过存取这个目录下的某个文档，就等于存取某个设备。例如重要的文档有 /dev/null, /dev/zero, /dev/tty, /dev/lp, /dev/hd, /dev/sd* 等等。 /etc 系统主要的配置文档几乎都放在这个目录内，例如用户的账号密码，各种服务的启动文档等等。一般来说，这个目录下的各个文档属性是可以让普通用户查阅的，但是只有root用户才有权力修改。FHS建议不要放置可执行文件(binary)在这个目录中。比较重要的档案有: /etc/inittab, /etc/init.d, /etc/modprobe.conf, /etc/X11, /etc/fstab, /etc/sysconfig 等等。另外，其下重要的目录有: /etc/init.d/ 所有服务的预设启动script都是放在这里的，例如要其启动或者关闭iptables的话 /etc/init.d/iptables start/stop ; /etc/xinetd.d/ 这就是所谓的super daemon管理的各项服务的配置文件目录。 /etc/X11/ 与X windows有各种配置文件都在这里，尤其是xorg.conf 或 XF86Config 这两个X server的配置文件。 /home 这是系统预设的普通用户的家目录(home directory)。在创建一个普通用户时，系统会自动在这个目录建一个与用户名相同的目录，作为新增用户的家目录。 /lib 系统的函式库非常的多，而 /lib 放置的则是在开机的时会用到的函式库，以及在 /bin 或 /sbin 底下的指令会呼叫的函式库。 /media 这个 /media 底下放置的就是可移除的装置。包括软碟，光碟，DVD等等装置都暂时挂载在这个目录。常见的挂载目录名有：/media/floppy /media/cdrom 等等。 /mnt 如果你想要暂时挂载某些额外的装置，如U盘。一般建议你可以挂载在这个目录。在早些时候没这个目录的用途与 /media 相同，只是有了 /media 之后，这个目录就用来暂时挂载临时装置了。 /opt 这个是给第三方协力软件放置的目录。举例来说，KDE 这个桌面管理系统是一个独立的计划，不过他可以安装到 Linux 系统中，因此 KDE 的软件就建议放置在此目录下。另外，如果你想要自行安装额外的软件，那么也可以将你的软件体安装到这里来。不过，以前的 Linux 系统中，我还是习惯放置在 /usr/local 目录下。 /root 系统管理员（root）的家目录。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有 root 的家目录，所以我们会希望 root 的家目录与根目录放置在同一分区中。 /sbin Linux有非常多指令是用来设定系统环境的，这些指令只有 root 才能够利用来设定系统，其他使用者最多只能用来查询而已。放在 /sbin 底下的为开机过程中所需要的，里面包括了开机，修复，还原系统所需要的指令。至与某些伺服器软体程式，一般则放置到 /usr/sbin 当中。至于本机自行安装的软体所产生的系统执行档（system binary），则放置到 /usr/local/sbin/ 当中了。常见的指令包括： fdisk， fsck， ifconfig， init， mkfs 等等。 /srv srv可以看作 service 的缩写，是一些网络服务启动之后，这些服务所需取用的资料目录。常见的服务例如 WWW, FTP 等等。举例来说， WWW 伺服器需要的网页资料就可以放置在 /srv/www/ 里面。 /tmp 这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录。因为 FHS 甚至建议在开机时，应该要将 /tmp 下的资料都删除。 事实上 FHS 针对根目录所定义的标准就仅限于上表，不过仍旧有些目录也需要我们了解一下，具体如下： 目录 应放置文件内容 /lost+found 这个目录是使用标准的 ext2 / ext3 文件系统格式时才会产生的一个目录， 目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。这个目录通常会在分割槽的最顶层存在，例如你加装一个硬盘于 /disk 中，那在这个系统下就会自动产生一个这样的目录 /disk/lost+found /proc 这个目录本身是一个虚拟文件系统（virtual filesystem)。他放置的资料都在内存当中，例如系统核心，行程资讯（process），因为这个目录下的资料都在内存当中，所以本身不占任何硬盘空间。比较重要的文件目录有： /proc/cpuinfo， /proc/dma， /proc/interrupts， /proc/ioports， /proc/net/* 等等。 /sys 这个目录其实跟 /proc 非常类似，也是一个虚拟的文件系统，主要也是记录与核心相关的文件。包括目前已载入的核心模组与核心侦测到的硬件装置文件等等。这个目录同样不占硬盘容量。 除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载，其他分区则是在开机完成之后才会持续进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录，就不能够与根目录，就不能够与根目录放到不同的分区去。不能与根目录分开的目录如下： /etc ： 配置文件/bin ： 重要的可执行文件/dev ： 所需要的装置文件/lib ： 可执行文件所需要的函式库与核心所需的模块/sbin ： 重要的系统执行文件 这五个目录千万不能与根目录分开在不同的分区。 二. /usr 的意义与内容：依据FHS的基本定义，/usr 里面放置的数据属于可分享的与不可变动的（shareable， static）。如果你知道如何通过网络进行分区的挂载，那么 /usr 确实可以分享给局域网络内的其他主机来使用。 /usr 不是 user 的缩写，其实 usr 是 Unix Software Resource 的缩写，也就是Unix操作系统软件资源所放置的目录，而不是用户的数据。这点要注意。FHS 建议所有软件开发者，应该将他们的数据合理的放置到这个目录下的此目录，而不是自行建立该软件自己的独立目录。 因为是所有系统默认的软件都会放置在 /usr 底下，因此这个目录有点类似 windows 系统的 C:Windows + C:Program files 这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。一般来说，/usr 的下级目录建议有底下这些： 目录 应放置文件内容 /usr/X11R6/ 为X Window System 重要数据所放置的目录，之所以取名为 X11R6 是因为最后的 X 版本为 11 版，且该版的第 6 次事出之意。 /usr/bin/ 绝大部分的用户可使用的命令都放在这里。请注意到他与 /bin 的不同之处。 /usr/include/ C/C++ 等程序语言的头文件（header）与函数库文件（include）放置处，当我们以 tar 方式（ *.tar.gz 的方式安装软件 ) 安装某些数据时，会使用到里面的许多包含文件。 /usr/lib/ 包含应用软件的函式库，目标文件（object file），以及不被一般使用者惯用的执行文件或脚本（script）。某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作，那就会被摆放到这个目录下。要注意的是，如果你使用的时X86_64的 Linux 系统，那可能会有 /usr/lib64/ 目录产生。 /usr/local/ root 用户在本机自行安装自己下的软件，建议安装到此目录，这样会比较便于管理。举例来说，你的系统默认提供的软件版本较旧，你想安装较新的软件但又不想移除旧版，此时你可以将新版软件安装于 /usr/local/ 目录下，可与原来的旧版软件又分别，你可以自行到 /usr/local 去看看，该目录下也是具有 bin， etc， include， lib 等等的下级目录。 /usr/sbin 非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的指令（daemon）。 /usr/share/ 放置共享文件的地方，在这个目录下方放置的数据几乎是不分硬件架构均可以读取的数据，因为几乎都是文本文件。在此目录下常见的目录有： /usr/share/man ：连机帮助文件。 /usr/src 一般源代码建议放置到这里，src 有 source 的意思。至于核心源代码则建议放置到 /usr/src/linux/ 目录下。 三. /var 的意义与内容：如果 /usr 是安装时会占用较大硬盘容量的目录，那么 /var 就是在系统运作后才会渐渐占用硬盘容量的目录。因为 /var 目录主要针对常态性变动的文件，包括缓存（cache），登陆文件（log file）以及某些软件运作时所产生的文件，包括程序文件（lock file， run file），或者例如 MySQL 数据库的文件等等。常见的下级目录如下： 目录 应放置文件内容 /var/cache/ 应用程序本身运作过程中会产生的一些数据文件暂存目录 /var/lib/ 程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该有各自的目录。举例来说，MySQL 的数据库放置到 /var/lib/mysql/ 而 rpm 的数据库则放到 /var/lib/rpm/ 去。 /var/lock/ 某些装置或者文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时，就可能产生一些错误的状况，因此就得要将该装置上锁，以确保该装置只会给单一软件所使用。举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时使用一个刻录机烧片？如果两个人同时刻录，那片子写入的时谁的数据？所以当第一个人在刻录时该刻录机就会被上锁，第二个人就得要等该装置解除锁定才能够继续使用。 /var/log/ 非常重要。这是登陆文件放置的目录。里面比较重要的文件如 /var/log/messages， /var/log/wtmp （记录登入者的信息）等。 /var/mail/ 放置个人电子邮件信箱的目录，不过这个目录也被放置到 /var/spool/mail/ 目录中，通常这两个目录是互为链接文件。 /var/run/ 某些程序或者是服务启动后，会将他们的PID放置在这个目录下 /var/spool/ 这个目录通常放置一些队列数据，所谓的“队列”就是排队等待其他程序所使用的数据。这些数据被使用后通常都会被删除。举例来说，系统收到信息会放置到 /var/spool/mail 中，但使用者收下该信件后该封信原则上就会被删除。信件如果是暂时寄不出去就会被放到 /var/spool/mqueue/ 中，等到被送出去后就被删除。如果是工作排程数据（crontab），就会被放置到 /var/spool/cron/ 目录中。 由于FHS仅是定义出最上层 （ / ）及次层（ /usr， /var ）的目录内容应该要放置的文件或目录数据，因此，在其他次目录层级内，就可以随开发者自行来配置了。 四. 目录树：在 Linux 底下，所有的文件与目录都是都是由根目录开始的。那是所有目录有文件的源头，然后再一个一个的分支下来，因此，我们也称这种目录配置方式为：目录树（directory tree），这个目录树的主要特性有： 目录树的起始点为根目录（ /， root）； 每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem。举例来说，可以利用 Network File System (NFS) 服务器挂载某特定目录等。 每一个文件在次目录树中的文件名(包含完整路径)都是独一无二的。 如果我们将整个目录树以图的方法来显示，并且将较为重要的文件数据列出来的话，那么目录树架构就如下图所示：]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim Editor Assistant]]></title>
    <url>%2F2018%2F03%2F22%2Fvim_Editor_Assistant%2F</url>
    <content type="text"><![CDATA[Start vi Editor12vi file// Opens 'file' in vi, or creates a file named 'file' if it does not exist. 12vi file1 file2// Opens files sequentially. 12view file// OPens 'file' in read-only mode. 12vi -R file// Opens 'file' in read-only mode. 12vi -r file// Recovers 'file' after system crash. 12vi + file// Opens 'file' at last line. Exit vi Editor12ZZ// Saves changes and exits. 12:x// Saves changes and exits. 12:wq// Saves changes and exits. 12:w// Saves changes. 12:q// Quit. 12:q!// Quit without saving changes. 12:wq file// Saves as 'file' and exits. Insert, append12i// Insert text before cursor. 12I// Insert text at beginning of current line. 12a// Append text after cursor. 12A// Append text at the end of current line. 12o// Open and insert text in new line below current line. 12O// Open and insert text ine new line above current line. 12r// Replace single character at cursor position. 12R// Replace multiple character starting with character at cursor position. 12s// Substitute a single character. 12S// Substitute entire line. Delete12x// Deletes a single character at cursor position. 12X// Deletes a single character before cursor positon. 12dw// Deletes from cursor position to next word. 12dd// Deletes entire line cursor is on. 12D// Deletes remainder of line, starting at cursor position. 12[Ctrl] u// Deletes from cursor to beginning of line. 12d$// Deletes from cursor to end of line. 12d^// Deletes to first character in line, preserving indentation. 12ndd// Deletes n number of lines (2dd deletes 2 lines). 12nx// Deletes n number of characters, starting with character under cursor (2x deletes 2 characters). Yank, Copy12yw// Yank word. 12yy// Yank current line. 12:y// Yank current line. 12y^// Yank from cursor to first character of line. 12y0// Yank from cursor to beginning of line. 12y$// Yank from cursor to end of line. 12Y// Yank current line. 12nyy or nY// Yank n number of lines (2yy or 2Y copies 2lines). Paste12p// Paste after cursor. 12P// Paste before cursor. Search12/word// Search forward for &apos;word&apos;. 12?// Repeats previous &apos;/&apos; search. 12n// Repeat last search in same direction. 12N// Repeat last search in opposite direction. 12*// Search forward for word under the cursor. 12#// Search backward for word under the cursor. 12fx// Search forward for next &apos;x&apos; on same line. 12Fx// Search backward for previous &apos;x&apos; on same line. 12tx// Search forwark for character before next &apos;x&apos;. 12Tx// Search backward for character after previous &apos;x&apos; on same line. Move cursor12H// Move to highest visible line on screen (top line). 12M// Move to middle of screen (center). 12L// Move to lowest visible line on screen (bottom line). 12l // Move right. 12h// Move left. 12KMove up. 12jMove down. 12^ // Move to first character on current line. 12$// Move to last column on current line. 120// Move to first column on current line. 12+// Move to first character on next line. 12-// Move to first character on previous line 12w// Move to beginning of next word. 12b// Move to beginning of previous word. 12345(// Move to beginning of current sentence.)// Move to beginning of next sentence. 12345&#123;// Move a paragraph back.&#125;// Move a paragraph forward. 12345G// Move to first character on last line.gg// Move to first character on first line. Move screen1234567891011121314151617[Ctrl] d// Move backward half screen.[Ctrl] f// Move backward full screen.[Ctrl] u// Move forword half screen.[Ctrl] b// Move forward full screen.[Ctrl] e// Move up one line.[Ctrl] y// Move down one line. 12345G// Move to last line in file.nG// Move to n number line. Other12.// Repeat last edit command. 12345u// Undo last change.U// Undo all changes on line. 12[Ctrl] g// Show current filename and line count. 12:f// Show current filename and line count. 12:f filename// Rename current file to &apos;filename&apos;. 12:cd dirname// Change directory to &apos;dirname&apos;. 12~// Change character case. 12:.=// Show current line number. 12:=// Show total number of lines.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用命令]]></title>
    <url>%2F2018%2F03%2F22%2FGit_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[初始化开始命令123git init或者git clone url 配置命令123456git config --global color.ui truegit config --global push.default currentgit config --global core.editor vimgit config --global user.name "~~"git config --global user.email "~~@~~.com"git config --global diff.tool meld 本地分支管理命令1234567891011121314151617181920212223242526272829303132333435363738// 查看本地分支列表git branch true// 切换到branchname本地分支 git checkout branchname // checkout当前分支到一个新分支，命名为new_branch_name git checkout -b new_branch_name // 将当前分支合并到branchname分支中git merge branchname// 查看所有 commitsgit log// 查看当前分支的状态git status// 添加已修改的filename文件到暂存区git add filename// 添加所有已修改的文件到暂存区git add .// Tell git not to track file anymoregit rm filename// 将以添加在暂存区的文件提交到储存区git commit// 将以添加在暂存区的文件提交到储存区，并提交commit messagegit commit -m "Some commit message"// 查看当前的改变与上次commit的区别git diff// Compare current branch to some other branchgit diff branch_name 远程分支管理命令1234567891011121314// See list of remote repos available.git remote// 从远程仓库添加一个项目到本地git remote add orgin url// 将当前分支推送到远程仓库git push// 将当前分支推送到远程项目的master分支git push orgin master// 拉取远程仓库中的与本地分支不同的commitgit pull]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 提交信息样式指南]]></title>
    <url>%2F2018%2F03%2F22%2FGit_%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF%E6%A0%B7%E5%BC%8F%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[Git 提交信息样式指南简介该指南是你在项目进行过程中所需遵守的官方指南。优达学城的评估人员会根据该指南为你的项目打分。在前端网页开发的世界中，有很“最佳”样式供你选择。因此，为了减少学生在项目过程中因选择何种样式所产生的困惑，我们强烈建议所有学生在其项目中遵循这个样式指南。提交信息 信息结构提交信息由三个不同的部分构成，这些部分均由空行分隔：标题、可选的消息体和可选的注释。其布局大致如此： 类型：主题消息正文注释标题由消息类型和主题构成。 类型类型位于在标题内，有以下几种可能： feat： 新功能 fix：错误修复 docs：文档修改 style：格式、分号缺失等，代码无变动 refactor：生产代码重构 test：测试添加、测试重构等，生产代码无变动 chore：构建任务更新、程序包管理器配置等，生产代码无变动。 标题主题不得超过50个字符，首字母大写，末尾不加句号。以祈使语气描述提交的任务，而不是其已完成的任务。例如，使用 change…，而不是 changed 或 changes 。 信息正文并不是所有的提交信息都复杂到需要主体，因此这是可选内容，仅在提交信息需要一定的解释和语境时使用。消息体是用于解释提交任务的内容和原因，而不是方法。在编写正文时，需要在标题和正文间加一个空行，且每行的内容应控制在72个字符内。 注释注释是可选内容，用于引用问题跟踪的 ID 。 提交信息示例Feat: 总结变动的内容，保持在50个字符内如有需要，使用更详细的说明性文字，将其大概控制在72个字符。在部分语境中，第一行被视为提交信息的主题，余下的文本被视为主体。分隔总结与主体的空行十分重要（除非你完全忽略主体）；否则log、shortlog和rebase等多个工具容易发生混淆。解释该提交信息所解决的问题，说明你进行该变动的原因，而不是方法（代码本身可以解释方法）。该变动是否存在副作用或其他直觉性后果？在这里进行解释。后续段落前需加空行。可以列出要点 通常情况下，要点会使用空格加上连字符或星号，中间用空行分隔，但该规定存在差别。如果你使用问题追踪，将其引用放在末尾，例如：解决了问题：#123另见：#456, #789]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
